// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ModuleDefinition.proto

#include "ModuleDefinition.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
#include "google/protobuf/generated_message_tctable_impl.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace ManufacturingScenarioRepository {
        template <typename>
PROTOBUF_CONSTEXPR OPCUAIdentification::OPCUAIdentification(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.name_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.nodeid_)*/ 0u,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct OPCUAIdentificationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OPCUAIdentificationDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OPCUAIdentificationDefaultTypeInternal() {}
  union {
    OPCUAIdentification _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OPCUAIdentificationDefaultTypeInternal _OPCUAIdentification_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR Module::Module(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.childmodules_)*/ {},
      /*decltype(_impl_.implementedservices_)*/ {},
      /*decltype(_impl_._implementedservices_cached_byte_size_)*/ {0},
      /*decltype(_impl_.consumedservices_)*/ {},
      /*decltype(_impl_.description_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.timeperstateinms_)*/ nullptr,
      /*decltype(_impl_.energyuseperstateinkwh_)*/ nullptr,
      /*decltype(_impl_.id_)*/ nullptr,
      /*decltype(_impl_.parameters_)*/ nullptr,
      /*decltype(_impl_.investmentcosts_)*/ 0,
      /*decltype(_impl_.currentstate_)*/ 0,
    } {}
struct ModuleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModuleDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModuleDefaultTypeInternal() {}
  union {
    Module _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModuleDefaultTypeInternal _Module_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR ParameterSet::ParameterSet(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.id_)*/ nullptr,
      /*decltype(_impl_.TypeAndParameters_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
    } {}
struct ParameterSetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ParameterSetDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ParameterSetDefaultTypeInternal() {}
  union {
    ParameterSet _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ParameterSetDefaultTypeInternal _ParameterSet_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR BasicLPBFMachineParams::BasicLPBFMachineParams(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.scanfields_)*/ {},
      /*decltype(_impl_.minlayerheightum_)*/ 0,
      /*decltype(_impl_.minzdistmm_)*/ 0,
      /*decltype(_impl_.minimalhatchlength_)*/ 0,
      /*decltype(_impl_.forcedminimumexposuretimeins_)*/ 0,
      /*decltype(_impl_.numberoflaserscannerunits_)*/ 0,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct BasicLPBFMachineParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BasicLPBFMachineParamsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BasicLPBFMachineParamsDefaultTypeInternal() {}
  union {
    BasicLPBFMachineParams _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BasicLPBFMachineParamsDefaultTypeInternal _BasicLPBFMachineParams_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR ServiceInterface::ServiceInterface(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.implementingmodule_)*/ nullptr,
      /*decltype(_impl_.consumedservice_)*/ 0,
    } {}
struct ServiceInterfaceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServiceInterfaceDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServiceInterfaceDefaultTypeInternal() {}
  union {
    ServiceInterface _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceInterfaceDefaultTypeInternal _ServiceInterface_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR BasicScannerParams::BasicScannerParams(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.jumpspeedinmms_)*/ 0,
      /*decltype(_impl_.markspeedinmms_)*/ 0,
      /*decltype(_impl_.laserfocusshiftinmm_)*/ 0,
      /*decltype(_impl_.maxaccelerationinmmperss_)*/ 0,
      /*decltype(_impl_.staticdelayins_)*/ 0,
      /*decltype(_impl_.jumpdelayinus_)*/ 0,
      /*decltype(_impl_.markdelayinus_)*/ 0,
      /*decltype(_impl_.laseroffdelayinus_)*/ 0,
      /*decltype(_impl_.laserondelayinus_)*/ 0,
      /*decltype(_impl_.polygondelayinus_)*/ 0,
      /*decltype(_impl_.vectorblockdelay_)*/ 0,
      /*decltype(_impl_.paramchangedelay_)*/ 0,
      /*decltype(_impl_.warpjumplengthlimit_)*/ 0,
      /*decltype(_impl_.jumpmode_)*/ 0,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct BasicScannerParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BasicScannerParamsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BasicScannerParamsDefaultTypeInternal() {}
  union {
    BasicScannerParams _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BasicScannerParamsDefaultTypeInternal _BasicScannerParams_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR CommonSkyWritingParams::CommonSkyWritingParams(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.nprevintenusticks_)*/ 0,
      /*decltype(_impl_.npostintenusticks_)*/ 0,
      /*decltype(_impl_.limitangle_)*/ 0,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct CommonSkyWritingParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommonSkyWritingParamsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommonSkyWritingParamsDefaultTypeInternal() {}
  union {
    CommonSkyWritingParams _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommonSkyWritingParamsDefaultTypeInternal _CommonSkyWritingParams_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR CoordinateTransformParams::CoordinateTransformParams(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.minimaljumplength_)*/ 0,
      /*decltype(_impl_.minimalmarklength_)*/ 0,
      /*decltype(_impl_.deletezerolengthjumps_)*/ false,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct CoordinateTransformParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CoordinateTransformParamsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CoordinateTransformParamsDefaultTypeInternal() {}
  union {
    CoordinateTransformParams _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CoordinateTransformParamsDefaultTypeInternal _CoordinateTransformParams_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR NovantaScannerParams::NovantaScannerParams(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.basicscannerparams_)*/ nullptr,
      /*decltype(_impl_.skywritingparams_)*/ nullptr,
      /*decltype(_impl_.coordtransformparams_)*/ nullptr,
      /*decltype(_impl_.skywritingmode_)*/ 0,
      /*decltype(_impl_.delaymode_)*/ 0,
      /*decltype(_impl_.radialerrorinum_)*/ 0,
      /*decltype(_impl_.safetyfactorflybylow_)*/ 0,
      /*decltype(_impl_.safetyfactorflybyhigh_)*/ 0,
      /*decltype(_impl_.safetyfactorradialerrorlimit_)*/ 0,
    } {}
struct NovantaScannerParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NovantaScannerParamsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~NovantaScannerParamsDefaultTypeInternal() {}
  union {
    NovantaScannerParams _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NovantaScannerParamsDefaultTypeInternal _NovantaScannerParams_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR ScanlabScannerParams::ScanlabScannerParams(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.basicscannerparams_)*/ nullptr,
      /*decltype(_impl_.skywritingparams_)*/ nullptr,
      /*decltype(_impl_.coordtransformparams_)*/ nullptr,
      /*decltype(_impl_.timelaginus_)*/ 0,
      /*decltype(_impl_.skywritingmode_)*/ 0,
      /*decltype(_impl_.skywritingparametringmode_)*/ 0,
      /*decltype(_impl_.delaymode_)*/ 0,
    } {}
struct ScanlabScannerParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ScanlabScannerParamsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ScanlabScannerParamsDefaultTypeInternal() {}
  union {
    ScanlabScannerParams _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ScanlabScannerParamsDefaultTypeInternal _ScanlabScannerParams_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR ScanField::ScanField(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.xmin_)*/ 0,
      /*decltype(_impl_.xmax_)*/ 0,
      /*decltype(_impl_.ymin_)*/ 0,
      /*decltype(_impl_.ymax_)*/ 0,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct ScanFieldDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ScanFieldDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ScanFieldDefaultTypeInternal() {}
  union {
    ScanField _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ScanFieldDefaultTypeInternal _ScanField_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR LaserParams::LaserParams(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.laserpowerinw_)*/ 0,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct LaserParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LaserParamsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LaserParamsDefaultTypeInternal() {}
  union {
    LaserParams _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LaserParamsDefaultTypeInternal _LaserParams_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR StandardCoaterParams::StandardCoaterParams(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.coatingspeedforwardinmmpersec_)*/ 0,
      /*decltype(_impl_.coatingspeedbackwardinmmpersec_)*/ 0,
      /*decltype(_impl_.distanceinmm_)*/ 0,
      /*decltype(_impl_.forwarddelayinsec_)*/ 0,
      /*decltype(_impl_.backwarddelayinsec_)*/ 0,
      /*decltype(_impl_.acceleration_)*/ 0,
      /*decltype(_impl_.isbidirectional_)*/ false,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct StandardCoaterParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StandardCoaterParamsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StandardCoaterParamsDefaultTypeInternal() {}
  union {
    StandardCoaterParams _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StandardCoaterParamsDefaultTypeInternal _StandardCoaterParams_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR BuildChamberParams::BuildChamberParams(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.platformliftrateinmmpersec_)*/ 0,
      /*decltype(_impl_.inertatmospheretimeins_)*/ 0,
      /*decltype(_impl_.releaseatmospheretimeins_)*/ 0,
      /*decltype(_impl_.maximumo2ppm_)*/ 0,
      /*decltype(_impl_.platformliftaccelerationinmmpersec2_)*/ 0,
      /*decltype(_impl_.platformliftdelayins_)*/ 0,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct BuildChamberParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BuildChamberParamsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BuildChamberParamsDefaultTypeInternal() {}
  union {
    BuildChamberParams _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BuildChamberParamsDefaultTypeInternal _BuildChamberParams_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR CuboidBuildVolumeParams::CuboidBuildVolumeParams(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.xmin_)*/ 0,
      /*decltype(_impl_.xmax_)*/ 0,
      /*decltype(_impl_.ymin_)*/ 0,
      /*decltype(_impl_.ymax_)*/ 0,
      /*decltype(_impl_.zmin_)*/ 0,
      /*decltype(_impl_.zmax_)*/ 0,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct CuboidBuildVolumeParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CuboidBuildVolumeParamsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CuboidBuildVolumeParamsDefaultTypeInternal() {}
  union {
    CuboidBuildVolumeParams _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CuboidBuildVolumeParamsDefaultTypeInternal _CuboidBuildVolumeParams_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR ZylinderBuildVolumeParams::ZylinderBuildVolumeParams(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.diameter_)*/ 0,
      /*decltype(_impl_.height_)*/ 0,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct ZylinderBuildVolumeParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ZylinderBuildVolumeParamsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ZylinderBuildVolumeParamsDefaultTypeInternal() {}
  union {
    ZylinderBuildVolumeParams _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ZylinderBuildVolumeParamsDefaultTypeInternal _ZylinderBuildVolumeParams_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR PreheaterParams::PreheaterParams(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.preheatingtemperature_)*/ 0,
      /*decltype(_impl_.maximumpreheatingtemperature_)*/ 0,
      /*decltype(_impl_.heatingrateinsecperk_)*/ 0,
      /*decltype(_impl_.roomtemperature_)*/ 0,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct PreheaterParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PreheaterParamsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PreheaterParamsDefaultTypeInternal() {}
  union {
    PreheaterParams _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PreheaterParamsDefaultTypeInternal _PreheaterParams_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR TimePerStateInMS::TimePerStateInMS(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.timeoff_)*/ 0,
      /*decltype(_impl_.timeidle_)*/ 0,
      /*decltype(_impl_.timeactive_)*/ 0,
      /*decltype(_impl_.timemaintenance_)*/ 0,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct TimePerStateInMSDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TimePerStateInMSDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TimePerStateInMSDefaultTypeInternal() {}
  union {
    TimePerStateInMS _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TimePerStateInMSDefaultTypeInternal _TimePerStateInMS_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR EnergyUsePerStateInkWh::EnergyUsePerStateInkWh(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.energyoff_)*/ 0,
      /*decltype(_impl_.energyidle_)*/ 0,
      /*decltype(_impl_.energyactive_)*/ 0,
      /*decltype(_impl_.energymaintenance_)*/ 0,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct EnergyUsePerStateInkWhDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EnergyUsePerStateInkWhDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EnergyUsePerStateInkWhDefaultTypeInternal() {}
  union {
    EnergyUsePerStateInkWh _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EnergyUsePerStateInkWhDefaultTypeInternal _EnergyUsePerStateInkWh_default_instance_;
}  // namespace ManufacturingScenarioRepository
static ::_pb::Metadata file_level_metadata_ModuleDefinition_2eproto[19];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_ModuleDefinition_2eproto[8];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_ModuleDefinition_2eproto = nullptr;
const ::uint32_t TableStruct_ModuleDefinition_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::OPCUAIdentification, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::OPCUAIdentification, _impl_.nodeid_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::OPCUAIdentification, _impl_.name_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::Module, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::Module, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::Module, _impl_.childmodules_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::Module, _impl_.currentstate_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::Module, _impl_.timeperstateinms_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::Module, _impl_.energyuseperstateinkwh_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::Module, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::Module, _impl_.description_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::Module, _impl_.investmentcosts_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::Module, _impl_.implementedservices_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::Module, _impl_.consumedservices_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::Module, _impl_.parameters_),
    ~0u,
    ~0u,
    0,
    1,
    2,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    3,
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::ParameterSet, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::ParameterSet, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::ParameterSet, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::ParameterSet, _impl_.id_),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::ParameterSet, _impl_.TypeAndParameters_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::BasicLPBFMachineParams, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::BasicLPBFMachineParams, _impl_.numberoflaserscannerunits_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::BasicLPBFMachineParams, _impl_.scanfields_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::BasicLPBFMachineParams, _impl_.minlayerheightum_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::BasicLPBFMachineParams, _impl_.minzdistmm_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::BasicLPBFMachineParams, _impl_.minimalhatchlength_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::BasicLPBFMachineParams, _impl_.forcedminimumexposuretimeins_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::ServiceInterface, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::ServiceInterface, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::ServiceInterface, _impl_.consumedservice_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::ServiceInterface, _impl_.implementingmodule_),
    ~0u,
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::BasicScannerParams, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::BasicScannerParams, _impl_.jumpspeedinmms_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::BasicScannerParams, _impl_.markspeedinmms_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::BasicScannerParams, _impl_.laserfocusshiftinmm_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::BasicScannerParams, _impl_.maxaccelerationinmmperss_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::BasicScannerParams, _impl_.staticdelayins_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::BasicScannerParams, _impl_.jumpdelayinus_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::BasicScannerParams, _impl_.markdelayinus_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::BasicScannerParams, _impl_.laseroffdelayinus_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::BasicScannerParams, _impl_.laserondelayinus_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::BasicScannerParams, _impl_.polygondelayinus_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::BasicScannerParams, _impl_.vectorblockdelay_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::BasicScannerParams, _impl_.paramchangedelay_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::BasicScannerParams, _impl_.warpjumplengthlimit_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::BasicScannerParams, _impl_.jumpmode_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::CommonSkyWritingParams, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::CommonSkyWritingParams, _impl_.nprevintenusticks_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::CommonSkyWritingParams, _impl_.npostintenusticks_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::CommonSkyWritingParams, _impl_.limitangle_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::CoordinateTransformParams, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::CoordinateTransformParams, _impl_.deletezerolengthjumps_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::CoordinateTransformParams, _impl_.minimaljumplength_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::CoordinateTransformParams, _impl_.minimalmarklength_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::NovantaScannerParams, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::NovantaScannerParams, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::NovantaScannerParams, _impl_.basicscannerparams_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::NovantaScannerParams, _impl_.skywritingparams_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::NovantaScannerParams, _impl_.coordtransformparams_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::NovantaScannerParams, _impl_.skywritingmode_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::NovantaScannerParams, _impl_.delaymode_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::NovantaScannerParams, _impl_.radialerrorinum_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::NovantaScannerParams, _impl_.safetyfactorflybylow_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::NovantaScannerParams, _impl_.safetyfactorflybyhigh_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::NovantaScannerParams, _impl_.safetyfactorradialerrorlimit_),
    0,
    1,
    2,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::ScanlabScannerParams, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::ScanlabScannerParams, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::ScanlabScannerParams, _impl_.basicscannerparams_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::ScanlabScannerParams, _impl_.skywritingparams_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::ScanlabScannerParams, _impl_.coordtransformparams_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::ScanlabScannerParams, _impl_.skywritingmode_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::ScanlabScannerParams, _impl_.timelaginus_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::ScanlabScannerParams, _impl_.skywritingparametringmode_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::ScanlabScannerParams, _impl_.delaymode_),
    0,
    1,
    2,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::ScanField, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::ScanField, _impl_.xmin_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::ScanField, _impl_.xmax_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::ScanField, _impl_.ymin_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::ScanField, _impl_.ymax_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::LaserParams, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::LaserParams, _impl_.laserpowerinw_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::StandardCoaterParams, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::StandardCoaterParams, _impl_.coatingspeedforwardinmmpersec_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::StandardCoaterParams, _impl_.coatingspeedbackwardinmmpersec_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::StandardCoaterParams, _impl_.distanceinmm_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::StandardCoaterParams, _impl_.forwarddelayinsec_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::StandardCoaterParams, _impl_.backwarddelayinsec_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::StandardCoaterParams, _impl_.acceleration_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::StandardCoaterParams, _impl_.isbidirectional_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::BuildChamberParams, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::BuildChamberParams, _impl_.platformliftrateinmmpersec_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::BuildChamberParams, _impl_.platformliftaccelerationinmmpersec2_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::BuildChamberParams, _impl_.platformliftdelayins_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::BuildChamberParams, _impl_.inertatmospheretimeins_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::BuildChamberParams, _impl_.releaseatmospheretimeins_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::BuildChamberParams, _impl_.maximumo2ppm_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::CuboidBuildVolumeParams, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::CuboidBuildVolumeParams, _impl_.xmin_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::CuboidBuildVolumeParams, _impl_.xmax_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::CuboidBuildVolumeParams, _impl_.ymin_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::CuboidBuildVolumeParams, _impl_.ymax_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::CuboidBuildVolumeParams, _impl_.zmin_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::CuboidBuildVolumeParams, _impl_.zmax_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::ZylinderBuildVolumeParams, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::ZylinderBuildVolumeParams, _impl_.diameter_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::ZylinderBuildVolumeParams, _impl_.height_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::PreheaterParams, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::PreheaterParams, _impl_.preheatingtemperature_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::PreheaterParams, _impl_.maximumpreheatingtemperature_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::PreheaterParams, _impl_.heatingrateinsecperk_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::PreheaterParams, _impl_.roomtemperature_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::TimePerStateInMS, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::TimePerStateInMS, _impl_.timeoff_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::TimePerStateInMS, _impl_.timeidle_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::TimePerStateInMS, _impl_.timeactive_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::TimePerStateInMS, _impl_.timemaintenance_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::EnergyUsePerStateInkWh, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::EnergyUsePerStateInkWh, _impl_.energyoff_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::EnergyUsePerStateInkWh, _impl_.energyidle_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::EnergyUsePerStateInkWh, _impl_.energyactive_),
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::EnergyUsePerStateInkWh, _impl_.energymaintenance_),
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        {0, -1, -1, sizeof(::ManufacturingScenarioRepository::OPCUAIdentification)},
        {10, 28, -1, sizeof(::ManufacturingScenarioRepository::Module)},
        {38, 57, -1, sizeof(::ManufacturingScenarioRepository::ParameterSet)},
        {67, -1, -1, sizeof(::ManufacturingScenarioRepository::BasicLPBFMachineParams)},
        {81, 91, -1, sizeof(::ManufacturingScenarioRepository::ServiceInterface)},
        {93, -1, -1, sizeof(::ManufacturingScenarioRepository::BasicScannerParams)},
        {115, -1, -1, sizeof(::ManufacturingScenarioRepository::CommonSkyWritingParams)},
        {126, -1, -1, sizeof(::ManufacturingScenarioRepository::CoordinateTransformParams)},
        {137, 154, -1, sizeof(::ManufacturingScenarioRepository::NovantaScannerParams)},
        {163, 178, -1, sizeof(::ManufacturingScenarioRepository::ScanlabScannerParams)},
        {185, -1, -1, sizeof(::ManufacturingScenarioRepository::ScanField)},
        {197, -1, -1, sizeof(::ManufacturingScenarioRepository::LaserParams)},
        {206, -1, -1, sizeof(::ManufacturingScenarioRepository::StandardCoaterParams)},
        {221, -1, -1, sizeof(::ManufacturingScenarioRepository::BuildChamberParams)},
        {235, -1, -1, sizeof(::ManufacturingScenarioRepository::CuboidBuildVolumeParams)},
        {249, -1, -1, sizeof(::ManufacturingScenarioRepository::ZylinderBuildVolumeParams)},
        {259, -1, -1, sizeof(::ManufacturingScenarioRepository::PreheaterParams)},
        {271, -1, -1, sizeof(::ManufacturingScenarioRepository::TimePerStateInMS)},
        {283, -1, -1, sizeof(::ManufacturingScenarioRepository::EnergyUsePerStateInkWh)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::ManufacturingScenarioRepository::_OPCUAIdentification_default_instance_._instance,
    &::ManufacturingScenarioRepository::_Module_default_instance_._instance,
    &::ManufacturingScenarioRepository::_ParameterSet_default_instance_._instance,
    &::ManufacturingScenarioRepository::_BasicLPBFMachineParams_default_instance_._instance,
    &::ManufacturingScenarioRepository::_ServiceInterface_default_instance_._instance,
    &::ManufacturingScenarioRepository::_BasicScannerParams_default_instance_._instance,
    &::ManufacturingScenarioRepository::_CommonSkyWritingParams_default_instance_._instance,
    &::ManufacturingScenarioRepository::_CoordinateTransformParams_default_instance_._instance,
    &::ManufacturingScenarioRepository::_NovantaScannerParams_default_instance_._instance,
    &::ManufacturingScenarioRepository::_ScanlabScannerParams_default_instance_._instance,
    &::ManufacturingScenarioRepository::_ScanField_default_instance_._instance,
    &::ManufacturingScenarioRepository::_LaserParams_default_instance_._instance,
    &::ManufacturingScenarioRepository::_StandardCoaterParams_default_instance_._instance,
    &::ManufacturingScenarioRepository::_BuildChamberParams_default_instance_._instance,
    &::ManufacturingScenarioRepository::_CuboidBuildVolumeParams_default_instance_._instance,
    &::ManufacturingScenarioRepository::_ZylinderBuildVolumeParams_default_instance_._instance,
    &::ManufacturingScenarioRepository::_PreheaterParams_default_instance_._instance,
    &::ManufacturingScenarioRepository::_TimePerStateInMS_default_instance_._instance,
    &::ManufacturingScenarioRepository::_EnergyUsePerStateInkWh_default_instance_._instance,
};
const char descriptor_table_protodef_ModuleDefinition_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\026ModuleDefinition.proto\022\037ManufacturingS"
    "cenarioRepository\"3\n\023OPCUAIdentification"
    "\022\016\n\006nodeId\030\001 \001(\r\022\014\n\004name\030\002 \001(\t\"\362\004\n\006Modul"
    "e\022=\n\014childModules\030\001 \003(\0132\'.ManufacturingS"
    "cenarioRepository.Module\022<\n\014currentState"
    "\030\002 \001(\0162&.ManufacturingScenarioRepository"
    ".state\022K\n\020timePerStateInMS\030\003 \001(\01321.Manuf"
    "acturingScenarioRepository.TimePerStateI"
    "nMS\022W\n\026energyUsePerStateInkWh\030\004 \001(\01327.Ma"
    "nufacturingScenarioRepository.EnergyUseP"
    "erStateInkWh\022@\n\002id\030\005 \001(\01324.Manufacturing"
    "ScenarioRepository.OPCUAIdentification\022\023"
    "\n\013description\030\006 \001(\t\022\027\n\017investmentCosts\030\007"
    " \001(\001\022E\n\023implementedServices\030\010 \003(\0162(.Manu"
    "facturingScenarioRepository.Service\022K\n\020c"
    "onsumedServices\030\t \003(\01321.ManufacturingSce"
    "narioRepository.ServiceInterface\022A\n\npara"
    "meters\030\n \001(\0132-.ManufacturingScenarioRepo"
    "sitory.ParameterSet\"\262\006\n\014ParameterSet\022@\n\002"
    "id\030\001 \001(\01324.ManufacturingScenarioReposito"
    "ry.OPCUAIdentification\022O\n\016scanlabScanner"
    "\030\n \001(\01325.ManufacturingScenarioRepository"
    ".ScanlabScannerParamsH\000\022=\n\005laser\030\013 \001(\0132,"
    ".ManufacturingScenarioRepository.LaserPa"
    "ramsH\000\022O\n\016standardCoater\030\014 \001(\01325.Manufac"
    "turingScenarioRepository.StandardCoaterP"
    "aramsH\000\022K\n\014buildChamber\030\017 \001(\01323.Manufact"
    "uringScenarioRepository.BuildChamberPara"
    "msH\000\022U\n\021cuboidBuildVolume\030\020 \001(\01328.Manufa"
    "cturingScenarioRepository.CuboidBuildVol"
    "umeParamsH\000\022Y\n\023zylinderBuildVolume\030\021 \001(\013"
    "2:.ManufacturingScenarioRepository.Zylin"
    "derBuildVolumeParamsH\000\022E\n\tpreheater\030\023 \001("
    "\01320.ManufacturingScenarioRepository.Preh"
    "eaterParamsH\000\022O\n\016novantaScanner\030\037 \001(\01325."
    "ManufacturingScenarioRepository.NovantaS"
    "cannerParamsH\000\022S\n\020basicLPBFMachine\030d \001(\013"
    "27.ManufacturingScenarioRepository.Basic"
    "LPBFMachineParamsH\000B\023\n\021TypeAndParameters"
    "\"\353\001\n\026BasicLPBFMachineParams\022!\n\031numberOfL"
    "aserScannerUnits\030\001 \001(\005\022>\n\nscanFields\030\024 \003"
    "(\0132*.ManufacturingScenarioRepository.Sca"
    "nField\022\030\n\020MinLayerHeightUM\030\n \001(\001\022\022\n\nMinZ"
    "DistMm\030\013 \001(\001\022\032\n\022MinimalHatchLength\030\014 \001(\001"
    "\022$\n\034ForcedMinimumExposureTimeInS\030\r \001(\001\"\247"
    "\001\n\020ServiceInterface\022A\n\017consumedService\030\001"
    " \001(\0162(.ManufacturingScenarioRepository.S"
    "ervice\022P\n\022implementingModule\030\002 \001(\01324.Man"
    "ufacturingScenarioRepository.OPCUAIdenti"
    "fication\"\342\003\n\022BasicScannerParams\022\026\n\016jumpS"
    "peedInMmS\030\001 \001(\001\022\026\n\016markSpeedInMmS\030\002 \001(\001\022"
    "\033\n\023laserFocusShiftInMm\030\003 \001(\001\022 \n\030maxAccel"
    "erationInMmPerSS\030\004 \001(\001\022\026\n\016staticDelayInS"
    "\030\005 \001(\001\022\025\n\rjumpDelayInUs\030\006 \001(\001\022\025\n\rmarkDel"
    "ayInUs\030\007 \001(\001\022\031\n\021laserOffDelayInUs\030\010 \001(\001\022"
    "\030\n\020laserOnDelayInUs\030\t \001(\001\022\030\n\020polygonDela"
    "yInUs\030\n \001(\001\022\030\n\020VectorBlockDelay\030\013 \001(\001\022\030\n"
    "\020ParamChangeDelay\030\014 \001(\001\022\033\n\023WarpJumpLengt"
    "hLimit\030\r \001(\001\022N\n\010jumpMode\030\016 \001(\0162<.Manufac"
    "turingScenarioRepository.BasicScannerPar"
    "ams.JumpMode\"\'\n\010JumpMode\022\n\n\006STATIC\020\000\022\017\n\013"
    "ACCELERATED\020\001\"b\n\026CommonSkyWritingParams\022"
    "\031\n\021NPrevInTenUsTicks\030\001 \001(\001\022\031\n\021NPostInTen"
    "UsTicks\030\002 \001(\001\022\022\n\nlimitAngle\030\003 \001(\001\"p\n\031Coo"
    "rdinateTransformParams\022\035\n\025DeleteZeroLeng"
    "thJumps\030\001 \001(\010\022\031\n\021MinimalJumpLength\030\002 \001(\001"
    "\022\031\n\021MinimalMarkLength\030\003 \001(\001\"\261\005\n\024NovantaS"
    "cannerParams\022O\n\022basicScannerParams\030\001 \001(\013"
    "23.ManufacturingScenarioRepository.Basic"
    "ScannerParams\022Q\n\020skyWritingParams\030\002 \001(\0132"
    "7.ManufacturingScenarioRepository.Common"
    "SkyWritingParams\022X\n\024coordTransformParams"
    "\030\003 \001(\0132:.ManufacturingScenarioRepository"
    ".CoordinateTransformParams\022\\\n\016skyWriting"
    "Mode\030\004 \001(\0162D.ManufacturingScenarioReposi"
    "tory.NovantaScannerParams.SkyWritingMode"
    "\022R\n\tdelayMode\030\005 \001(\0162\?.ManufacturingScena"
    "rioRepository.NovantaScannerParams.Delay"
    "Mode\022\027\n\017radialErrorInUm\030\006 \001(\001\022\034\n\024SafetyF"
    "actorFlyByLow\030\007 \001(\001\022\035\n\025SafetyFactorFlyBy"
    "High\030\010 \001(\001\022$\n\034SafetyFactorRadialErrorLim"
    "it\030\t \001(\001\"4\n\016SkyWritingMode\022\010\n\004NONE\020\000\022\t\n\005"
    "MODE3\020\001\022\r\n\tSCAN_PACK\020\002\"7\n\tDelayMode\022\021\n\rM"
    "ANUAL_DELAYS\020\000\022\027\n\023VARIABLE_POLY_DELAY\020\001\""
    "\355\006\n\024ScanlabScannerParams\022O\n\022basicScanner"
    "Params\030\001 \001(\01323.ManufacturingScenarioRepo"
    "sitory.BasicScannerParams\022Q\n\020skyWritingP"
    "arams\030\002 \001(\01327.ManufacturingScenarioRepos"
    "itory.CommonSkyWritingParams\022X\n\024coordTra"
    "nsformParams\030\003 \001(\0132:.ManufacturingScenar"
    "ioRepository.CoordinateTransformParams\022\\"
    "\n\016skyWritingMode\030\004 \001(\0162D.ManufacturingSc"
    "enarioRepository.ScanlabScannerParams.Sk"
    "yWritingMode\022\023\n\013timeLagInUs\030\005 \001(\001\022r\n\031sky"
    "WritingParametringMode\030\006 \001(\0162O.Manufactu"
    "ringScenarioRepository.ScanlabScannerPar"
    "ams.SkyWritingParametringMode\022R\n\tdelayMo"
    "de\030\007 \001(\0162\?.ManufacturingScenarioReposito"
    "ry.ScanlabScannerParams.DelayMode\";\n\016Sky"
    "WritingMode\022\010\n\004NONE\020\000\022\t\n\005MODE1\020\001\022\t\n\005MODE"
    "2\020\002\022\t\n\005MODE3\020\003\"\205\001\n\031SkyWritingParametring"
    "Mode\022\026\n\022MANUAL_NPREV_NPOST\020\000\022*\n&AUTOMATI"
    "C_NPREV_NPOST_BASED_ON_TIMELAG\020\001\022$\n MINI"
    "MUM_NPREV_NPOST_ACCELERATION\020\002\"W\n\tDelayM"
    "ode\022\021\n\rMANUAL_DELAYS\020\000\022\027\n\023VARIABLE_POLY_"
    "DELAY\020\001\022\036\n\032MINIMUM_DELAY_ACCELERATION\020\002\""
    "C\n\tScanField\022\014\n\004XMin\030\001 \001(\001\022\014\n\004XMax\030\002 \001(\001"
    "\022\014\n\004YMin\030\003 \001(\001\022\014\n\004YMax\030\004 \001(\001\"$\n\013LaserPar"
    "ams\022\025\n\rLaserPowerInW\030\002 \001(\001\"\341\001\n\024StandardC"
    "oaterParams\022%\n\035coatingSpeedForwardInMmPe"
    "rSec\030\001 \001(\001\022&\n\036coatingSpeedBackwardInMmPe"
    "rSec\030\002 \001(\001\022\024\n\014distanceInMm\030\003 \001(\001\022\031\n\021forw"
    "ardDelayInSec\030\004 \001(\001\022\032\n\022backwardDelayInSe"
    "c\030\005 \001(\001\022\024\n\014acceleration\030\006 \001(\001\022\027\n\017isBidir"
    "ectional\030\007 \001(\010\"\333\001\n\022BuildChamberParams\022\"\n"
    "\032platformLiftRateInMmPerSec\030\001 \001(\001\022+\n#pla"
    "tformLiftAccelerationInMmPerSec2\030\005 \001(\001\022\034"
    "\n\024platformLiftDelayInS\030\006 \001(\001\022\036\n\026inertAtm"
    "osphereTimeInS\030\002 \001(\001\022 \n\030releaseAtmospher"
    "eTimeInS\030\003 \001(\001\022\024\n\014maximumO2PPM\030\004 \001(\001\"m\n\027"
    "CuboidBuildVolumeParams\022\014\n\004XMin\030\001 \001(\001\022\014\n"
    "\004XMax\030\002 \001(\001\022\014\n\004YMin\030\003 \001(\001\022\014\n\004YMax\030\004 \001(\001\022"
    "\014\n\004ZMin\030\005 \001(\001\022\014\n\004ZMax\030\006 \001(\001\"=\n\031ZylinderB"
    "uildVolumeParams\022\020\n\010diameter\030\002 \001(\001\022\016\n\006he"
    "ight\030\003 \001(\001\"\215\001\n\017PreheaterParams\022\035\n\025prehea"
    "tingTemperature\030\002 \001(\001\022$\n\034maximumPreheati"
    "ngTemperature\030\003 \001(\001\022\034\n\024heatingRateInSecP"
    "erK\030\004 \001(\001\022\027\n\017roomTemperature\030\005 \001(\001\"b\n\020Ti"
    "mePerStateInMS\022\017\n\007timeOff\030\001 \001(\001\022\020\n\010timeI"
    "dle\030\002 \001(\001\022\022\n\ntimeActive\030\003 \001(\001\022\027\n\017timeMai"
    "ntenance\030\004 \001(\001\"p\n\026EnergyUsePerStateInkWh"
    "\022\021\n\tenergyOff\030\001 \001(\001\022\022\n\nenergyIdle\030\002 \001(\001\022"
    "\024\n\014energyActive\030\003 \001(\001\022\031\n\021energyMaintenan"
    "ce\030\004 \001(\001*\215\003\n\007Service\022\022\n\016LASERDEFLECTOR\020\000"
    "\022\017\n\013LASERSOURCE\020\001\022\n\n\006COATER\020\002\022\024\n\020INERT_A"
    "TMOSPHERE\020\003\022\n\n\006LOADER\020\004\022\022\n\016POSTPROCESSIN"
    "G\020\005\022\031\n\025POWDER_BED_MONITORING\020\006\022\017\n\013POWDER"
    "_FEED\020\007\022\024\n\020POWDER_RECYCLING\020\010\022\021\n\rPOWDER_"
    "UNLOAD\020\t\022\r\n\tPREHEATER\020\n\022\027\n\023PULSED_LASER_"
    "SOURCE\020\013\022\023\n\017REMOVE_SUPPORTS\020\014\022\033\n\027SUBSTRA"
    "TE_PLATE_MILLING\020\r\022\025\n\021THERMAL_TREATMENT\020"
    "\016\022\021\n\rPLATFORM_LIFT\020\017\022\030\n\024SCANFIELD_ALLOCA"
    "TION\020\020\022\020\n\014FILTER_CLEAN\020\021\022\026\n\022THERMAL_SIMU"
    "LATION\020\022*7\n\005state\022\007\n\003OFF\020\000\022\010\n\004IDLE\020\001\022\n\n\006"
    "ACTIVE\020\002\022\017\n\013MAINTENANCE\020\003b\006proto3"
};
static ::absl::once_flag descriptor_table_ModuleDefinition_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_ModuleDefinition_2eproto = {
    false,
    false,
    5793,
    descriptor_table_protodef_ModuleDefinition_2eproto,
    "ModuleDefinition.proto",
    &descriptor_table_ModuleDefinition_2eproto_once,
    nullptr,
    0,
    19,
    schemas,
    file_default_instances,
    TableStruct_ModuleDefinition_2eproto::offsets,
    file_level_metadata_ModuleDefinition_2eproto,
    file_level_enum_descriptors_ModuleDefinition_2eproto,
    file_level_service_descriptors_ModuleDefinition_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_ModuleDefinition_2eproto_getter() {
  return &descriptor_table_ModuleDefinition_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_ModuleDefinition_2eproto(&descriptor_table_ModuleDefinition_2eproto);
namespace ManufacturingScenarioRepository {
const ::google::protobuf::EnumDescriptor* BasicScannerParams_JumpMode_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_ModuleDefinition_2eproto);
  return file_level_enum_descriptors_ModuleDefinition_2eproto[0];
}
bool BasicScannerParams_JumpMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr BasicScannerParams_JumpMode BasicScannerParams::STATIC;
constexpr BasicScannerParams_JumpMode BasicScannerParams::ACCELERATED;
constexpr BasicScannerParams_JumpMode BasicScannerParams::JumpMode_MIN;
constexpr BasicScannerParams_JumpMode BasicScannerParams::JumpMode_MAX;
constexpr int BasicScannerParams::JumpMode_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::google::protobuf::EnumDescriptor* NovantaScannerParams_SkyWritingMode_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_ModuleDefinition_2eproto);
  return file_level_enum_descriptors_ModuleDefinition_2eproto[1];
}
bool NovantaScannerParams_SkyWritingMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr NovantaScannerParams_SkyWritingMode NovantaScannerParams::NONE;
constexpr NovantaScannerParams_SkyWritingMode NovantaScannerParams::MODE3;
constexpr NovantaScannerParams_SkyWritingMode NovantaScannerParams::SCAN_PACK;
constexpr NovantaScannerParams_SkyWritingMode NovantaScannerParams::SkyWritingMode_MIN;
constexpr NovantaScannerParams_SkyWritingMode NovantaScannerParams::SkyWritingMode_MAX;
constexpr int NovantaScannerParams::SkyWritingMode_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::google::protobuf::EnumDescriptor* NovantaScannerParams_DelayMode_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_ModuleDefinition_2eproto);
  return file_level_enum_descriptors_ModuleDefinition_2eproto[2];
}
bool NovantaScannerParams_DelayMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr NovantaScannerParams_DelayMode NovantaScannerParams::MANUAL_DELAYS;
constexpr NovantaScannerParams_DelayMode NovantaScannerParams::VARIABLE_POLY_DELAY;
constexpr NovantaScannerParams_DelayMode NovantaScannerParams::DelayMode_MIN;
constexpr NovantaScannerParams_DelayMode NovantaScannerParams::DelayMode_MAX;
constexpr int NovantaScannerParams::DelayMode_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::google::protobuf::EnumDescriptor* ScanlabScannerParams_SkyWritingMode_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_ModuleDefinition_2eproto);
  return file_level_enum_descriptors_ModuleDefinition_2eproto[3];
}
bool ScanlabScannerParams_SkyWritingMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr ScanlabScannerParams_SkyWritingMode ScanlabScannerParams::NONE;
constexpr ScanlabScannerParams_SkyWritingMode ScanlabScannerParams::MODE1;
constexpr ScanlabScannerParams_SkyWritingMode ScanlabScannerParams::MODE2;
constexpr ScanlabScannerParams_SkyWritingMode ScanlabScannerParams::MODE3;
constexpr ScanlabScannerParams_SkyWritingMode ScanlabScannerParams::SkyWritingMode_MIN;
constexpr ScanlabScannerParams_SkyWritingMode ScanlabScannerParams::SkyWritingMode_MAX;
constexpr int ScanlabScannerParams::SkyWritingMode_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::google::protobuf::EnumDescriptor* ScanlabScannerParams_SkyWritingParametringMode_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_ModuleDefinition_2eproto);
  return file_level_enum_descriptors_ModuleDefinition_2eproto[4];
}
bool ScanlabScannerParams_SkyWritingParametringMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr ScanlabScannerParams_SkyWritingParametringMode ScanlabScannerParams::MANUAL_NPREV_NPOST;
constexpr ScanlabScannerParams_SkyWritingParametringMode ScanlabScannerParams::AUTOMATIC_NPREV_NPOST_BASED_ON_TIMELAG;
constexpr ScanlabScannerParams_SkyWritingParametringMode ScanlabScannerParams::MINIMUM_NPREV_NPOST_ACCELERATION;
constexpr ScanlabScannerParams_SkyWritingParametringMode ScanlabScannerParams::SkyWritingParametringMode_MIN;
constexpr ScanlabScannerParams_SkyWritingParametringMode ScanlabScannerParams::SkyWritingParametringMode_MAX;
constexpr int ScanlabScannerParams::SkyWritingParametringMode_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::google::protobuf::EnumDescriptor* ScanlabScannerParams_DelayMode_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_ModuleDefinition_2eproto);
  return file_level_enum_descriptors_ModuleDefinition_2eproto[5];
}
bool ScanlabScannerParams_DelayMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr ScanlabScannerParams_DelayMode ScanlabScannerParams::MANUAL_DELAYS;
constexpr ScanlabScannerParams_DelayMode ScanlabScannerParams::VARIABLE_POLY_DELAY;
constexpr ScanlabScannerParams_DelayMode ScanlabScannerParams::MINIMUM_DELAY_ACCELERATION;
constexpr ScanlabScannerParams_DelayMode ScanlabScannerParams::DelayMode_MIN;
constexpr ScanlabScannerParams_DelayMode ScanlabScannerParams::DelayMode_MAX;
constexpr int ScanlabScannerParams::DelayMode_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::google::protobuf::EnumDescriptor* Service_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_ModuleDefinition_2eproto);
  return file_level_enum_descriptors_ModuleDefinition_2eproto[6];
}
bool Service_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
      return true;
    default:
      return false;
  }
}
const ::google::protobuf::EnumDescriptor* state_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_ModuleDefinition_2eproto);
  return file_level_enum_descriptors_ModuleDefinition_2eproto[7];
}
bool state_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}
// ===================================================================

class OPCUAIdentification::_Internal {
 public:
};

OPCUAIdentification::OPCUAIdentification(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ManufacturingScenarioRepository.OPCUAIdentification)
}
OPCUAIdentification::OPCUAIdentification(const OPCUAIdentification& from) : ::google::protobuf::Message() {
  OPCUAIdentification* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){},
      decltype(_impl_.nodeid_){},
      /*decltype(_impl_._cached_size_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
  }
  _this->_impl_.nodeid_ = from._impl_.nodeid_;

  // @@protoc_insertion_point(copy_constructor:ManufacturingScenarioRepository.OPCUAIdentification)
}
inline void OPCUAIdentification::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){},
      decltype(_impl_.nodeid_){0u},
      /*decltype(_impl_._cached_size_)*/ {},
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}
OPCUAIdentification::~OPCUAIdentification() {
  // @@protoc_insertion_point(destructor:ManufacturingScenarioRepository.OPCUAIdentification)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void OPCUAIdentification::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}
void OPCUAIdentification::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void OPCUAIdentification::Clear() {
// @@protoc_insertion_point(message_clear_start:ManufacturingScenarioRepository.OPCUAIdentification)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.nodeid_ = 0u;
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* OPCUAIdentification::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 64, 2> OPCUAIdentification::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_OPCUAIdentification_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // string name = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(OPCUAIdentification, _impl_.name_)}},
    // uint32 nodeId = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(OPCUAIdentification, _impl_.nodeid_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(OPCUAIdentification, _impl_.nodeid_)}},
  }}, {{
    65535, 65535
  }}, {{
    // uint32 nodeId = 1;
    {PROTOBUF_FIELD_OFFSET(OPCUAIdentification, _impl_.nodeid_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // string name = 2;
    {PROTOBUF_FIELD_OFFSET(OPCUAIdentification, _impl_.name_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\63\0\4\0\0\0\0\0"
    "ManufacturingScenarioRepository.OPCUAIdentification"
    "name"
  }},
};

::uint8_t* OPCUAIdentification::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ManufacturingScenarioRepository.OPCUAIdentification)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // uint32 nodeId = 1;
  if (this->_internal_nodeid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_nodeid(), target);
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    const std::string& _s = this->_internal_name();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "ManufacturingScenarioRepository.OPCUAIdentification.name");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ManufacturingScenarioRepository.OPCUAIdentification)
  return target;
}

::size_t OPCUAIdentification::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ManufacturingScenarioRepository.OPCUAIdentification)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 2;
  if (!this->_internal_name().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_name());
  }

  // uint32 nodeId = 1;
  if (this->_internal_nodeid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_nodeid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData OPCUAIdentification::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    OPCUAIdentification::MergeImpl
};
const ::google::protobuf::Message::ClassData*OPCUAIdentification::GetClassData() const { return &_class_data_; }


void OPCUAIdentification::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<OPCUAIdentification*>(&to_msg);
  auto& from = static_cast<const OPCUAIdentification&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ManufacturingScenarioRepository.OPCUAIdentification)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_nodeid() != 0) {
    _this->_internal_set_nodeid(from._internal_nodeid());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void OPCUAIdentification::CopyFrom(const OPCUAIdentification& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ManufacturingScenarioRepository.OPCUAIdentification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool OPCUAIdentification::IsInitialized() const {
  return true;
}

void OPCUAIdentification::InternalSwap(OPCUAIdentification* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena,
                                       &other->_impl_.name_, rhs_arena);
        swap(_impl_.nodeid_, other->_impl_.nodeid_);
}

::google::protobuf::Metadata OPCUAIdentification::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ModuleDefinition_2eproto_getter, &descriptor_table_ModuleDefinition_2eproto_once,
      file_level_metadata_ModuleDefinition_2eproto[0]);
}
// ===================================================================

class Module::_Internal {
 public:
  using HasBits = decltype(std::declval<Module>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Module, _impl_._has_bits_);
  static const ::ManufacturingScenarioRepository::TimePerStateInMS& timeperstateinms(const Module* msg);
  static void set_has_timeperstateinms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::ManufacturingScenarioRepository::EnergyUsePerStateInkWh& energyuseperstateinkwh(const Module* msg);
  static void set_has_energyuseperstateinkwh(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::ManufacturingScenarioRepository::OPCUAIdentification& id(const Module* msg);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::ManufacturingScenarioRepository::ParameterSet& parameters(const Module* msg);
  static void set_has_parameters(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::ManufacturingScenarioRepository::TimePerStateInMS& Module::_Internal::timeperstateinms(const Module* msg) {
  return *msg->_impl_.timeperstateinms_;
}
const ::ManufacturingScenarioRepository::EnergyUsePerStateInkWh& Module::_Internal::energyuseperstateinkwh(const Module* msg) {
  return *msg->_impl_.energyuseperstateinkwh_;
}
const ::ManufacturingScenarioRepository::OPCUAIdentification& Module::_Internal::id(const Module* msg) {
  return *msg->_impl_.id_;
}
const ::ManufacturingScenarioRepository::ParameterSet& Module::_Internal::parameters(const Module* msg) {
  return *msg->_impl_.parameters_;
}
Module::Module(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ManufacturingScenarioRepository.Module)
}
Module::Module(const Module& from) : ::google::protobuf::Message() {
  Module* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.childmodules_){from._impl_.childmodules_},
      decltype(_impl_.implementedservices_){from._internal_implementedservices()},
      /*decltype(_impl_._implementedservices_cached_byte_size_)*/ {0},
      decltype(_impl_.consumedservices_){from._impl_.consumedservices_},
      decltype(_impl_.description_){},
      decltype(_impl_.timeperstateinms_){nullptr},
      decltype(_impl_.energyuseperstateinkwh_){nullptr},
      decltype(_impl_.id_){nullptr},
      decltype(_impl_.parameters_){nullptr},
      decltype(_impl_.investmentcosts_){},
      decltype(_impl_.currentstate_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.description_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.timeperstateinms_ = new ::ManufacturingScenarioRepository::TimePerStateInMS(*from._impl_.timeperstateinms_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.energyuseperstateinkwh_ = new ::ManufacturingScenarioRepository::EnergyUsePerStateInkWh(*from._impl_.energyuseperstateinkwh_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.id_ = new ::ManufacturingScenarioRepository::OPCUAIdentification(*from._impl_.id_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.parameters_ = new ::ManufacturingScenarioRepository::ParameterSet(*from._impl_.parameters_);
  }
  ::memcpy(&_impl_.investmentcosts_, &from._impl_.investmentcosts_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.currentstate_) -
    reinterpret_cast<char*>(&_impl_.investmentcosts_)) + sizeof(_impl_.currentstate_));

  // @@protoc_insertion_point(copy_constructor:ManufacturingScenarioRepository.Module)
}
inline void Module::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.childmodules_){arena},
      decltype(_impl_.implementedservices_){arena},
      /*decltype(_impl_._implementedservices_cached_byte_size_)*/ {0},
      decltype(_impl_.consumedservices_){arena},
      decltype(_impl_.description_){},
      decltype(_impl_.timeperstateinms_){nullptr},
      decltype(_impl_.energyuseperstateinkwh_){nullptr},
      decltype(_impl_.id_){nullptr},
      decltype(_impl_.parameters_){nullptr},
      decltype(_impl_.investmentcosts_){0},
      decltype(_impl_.currentstate_){0},
  };
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.description_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}
Module::~Module() {
  // @@protoc_insertion_point(destructor:ManufacturingScenarioRepository.Module)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Module::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.childmodules_.~RepeatedPtrField();
  _internal_mutable_implementedservices()->~RepeatedField();
  _impl_.consumedservices_.~RepeatedPtrField();
  _impl_.description_.Destroy();
  if (this != internal_default_instance()) delete _impl_.timeperstateinms_;
  if (this != internal_default_instance()) delete _impl_.energyuseperstateinkwh_;
  if (this != internal_default_instance()) delete _impl_.id_;
  if (this != internal_default_instance()) delete _impl_.parameters_;
}
void Module::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void Module::Clear() {
// @@protoc_insertion_point(message_clear_start:ManufacturingScenarioRepository.Module)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_childmodules()->Clear();
  _internal_mutable_implementedservices()->Clear();
  _internal_mutable_consumedservices()->Clear();
  _impl_.description_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.timeperstateinms_ != nullptr);
      _impl_.timeperstateinms_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.energyuseperstateinkwh_ != nullptr);
      _impl_.energyuseperstateinkwh_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.id_ != nullptr);
      _impl_.id_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.parameters_ != nullptr);
      _impl_.parameters_->Clear();
    }
  }
  ::memset(&_impl_.investmentcosts_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.currentstate_) -
      reinterpret_cast<char*>(&_impl_.investmentcosts_)) + sizeof(_impl_.currentstate_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Module::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 10, 6, 66, 2> Module::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Module, _impl_._has_bits_),
    0, // no _extensions_
    10, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966272,  // skipmap
    offsetof(decltype(_table_), field_entries),
    10,  // num_field_entries
    6,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_Module_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .ManufacturingScenarioRepository.Module childModules = 1;
    {::_pbi::TcParser::FastMtR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(Module, _impl_.childmodules_)}},
    // .ManufacturingScenarioRepository.state currentState = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Module, _impl_.currentstate_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(Module, _impl_.currentstate_)}},
    // .ManufacturingScenarioRepository.TimePerStateInMS timePerStateInMS = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 0, 1, PROTOBUF_FIELD_OFFSET(Module, _impl_.timeperstateinms_)}},
    // .ManufacturingScenarioRepository.EnergyUsePerStateInkWh energyUsePerStateInkWh = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 1, 2, PROTOBUF_FIELD_OFFSET(Module, _impl_.energyuseperstateinkwh_)}},
    // .ManufacturingScenarioRepository.OPCUAIdentification id = 5;
    {::_pbi::TcParser::FastMtS1,
     {42, 2, 3, PROTOBUF_FIELD_OFFSET(Module, _impl_.id_)}},
    // string description = 6;
    {::_pbi::TcParser::FastUS1,
     {50, 63, 0, PROTOBUF_FIELD_OFFSET(Module, _impl_.description_)}},
    // double investmentCosts = 7;
    {::_pbi::TcParser::FastF64S1,
     {57, 63, 0, PROTOBUF_FIELD_OFFSET(Module, _impl_.investmentcosts_)}},
    // repeated .ManufacturingScenarioRepository.Service implementedServices = 8;
    {::_pbi::TcParser::FastV32P1,
     {66, 63, 0, PROTOBUF_FIELD_OFFSET(Module, _impl_.implementedservices_)}},
    // repeated .ManufacturingScenarioRepository.ServiceInterface consumedServices = 9;
    {::_pbi::TcParser::FastMtR1,
     {74, 63, 4, PROTOBUF_FIELD_OFFSET(Module, _impl_.consumedservices_)}},
    // .ManufacturingScenarioRepository.ParameterSet parameters = 10;
    {::_pbi::TcParser::FastMtS1,
     {82, 3, 5, PROTOBUF_FIELD_OFFSET(Module, _impl_.parameters_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .ManufacturingScenarioRepository.Module childModules = 1;
    {PROTOBUF_FIELD_OFFSET(Module, _impl_.childmodules_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // .ManufacturingScenarioRepository.state currentState = 2;
    {PROTOBUF_FIELD_OFFSET(Module, _impl_.currentstate_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .ManufacturingScenarioRepository.TimePerStateInMS timePerStateInMS = 3;
    {PROTOBUF_FIELD_OFFSET(Module, _impl_.timeperstateinms_), _Internal::kHasBitsOffset + 0, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .ManufacturingScenarioRepository.EnergyUsePerStateInkWh energyUsePerStateInkWh = 4;
    {PROTOBUF_FIELD_OFFSET(Module, _impl_.energyuseperstateinkwh_), _Internal::kHasBitsOffset + 1, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .ManufacturingScenarioRepository.OPCUAIdentification id = 5;
    {PROTOBUF_FIELD_OFFSET(Module, _impl_.id_), _Internal::kHasBitsOffset + 2, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // string description = 6;
    {PROTOBUF_FIELD_OFFSET(Module, _impl_.description_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // double investmentCosts = 7;
    {PROTOBUF_FIELD_OFFSET(Module, _impl_.investmentcosts_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // repeated .ManufacturingScenarioRepository.Service implementedServices = 8;
    {PROTOBUF_FIELD_OFFSET(Module, _impl_.implementedservices_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedOpenEnum)},
    // repeated .ManufacturingScenarioRepository.ServiceInterface consumedServices = 9;
    {PROTOBUF_FIELD_OFFSET(Module, _impl_.consumedservices_), -1, 4,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // .ManufacturingScenarioRepository.ParameterSet parameters = 10;
    {PROTOBUF_FIELD_OFFSET(Module, _impl_.parameters_), _Internal::kHasBitsOffset + 3, 5,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::ManufacturingScenarioRepository::Module>()},
    {::_pbi::TcParser::GetTable<::ManufacturingScenarioRepository::TimePerStateInMS>()},
    {::_pbi::TcParser::GetTable<::ManufacturingScenarioRepository::EnergyUsePerStateInkWh>()},
    {::_pbi::TcParser::GetTable<::ManufacturingScenarioRepository::OPCUAIdentification>()},
    {::_pbi::TcParser::GetTable<::ManufacturingScenarioRepository::ServiceInterface>()},
    {::_pbi::TcParser::GetTable<::ManufacturingScenarioRepository::ParameterSet>()},
  }}, {{
    "\46\0\0\0\0\0\13\0\0\0\0\0\0\0\0\0"
    "ManufacturingScenarioRepository.Module"
    "description"
  }},
};

::uint8_t* Module::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ManufacturingScenarioRepository.Module)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .ManufacturingScenarioRepository.Module childModules = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_childmodules_size()); i < n; i++) {
    const auto& repfield = this->_internal_childmodules().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .ManufacturingScenarioRepository.state currentState = 2;
  if (this->_internal_currentstate() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_currentstate(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .ManufacturingScenarioRepository.TimePerStateInMS timePerStateInMS = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::timeperstateinms(this),
        _Internal::timeperstateinms(this).GetCachedSize(), target, stream);
  }

  // .ManufacturingScenarioRepository.EnergyUsePerStateInkWh energyUsePerStateInkWh = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::energyuseperstateinkwh(this),
        _Internal::energyuseperstateinkwh(this).GetCachedSize(), target, stream);
  }

  // .ManufacturingScenarioRepository.OPCUAIdentification id = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::id(this),
        _Internal::id(this).GetCachedSize(), target, stream);
  }

  // string description = 6;
  if (!this->_internal_description().empty()) {
    const std::string& _s = this->_internal_description();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "ManufacturingScenarioRepository.Module.description");
    target = stream->WriteStringMaybeAliased(6, _s, target);
  }

  // double investmentCosts = 7;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_investmentcosts = this->_internal_investmentcosts();
  ::uint64_t raw_investmentcosts;
  memcpy(&raw_investmentcosts, &tmp_investmentcosts, sizeof(tmp_investmentcosts));
  if (raw_investmentcosts != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        7, this->_internal_investmentcosts(), target);
  }

  // repeated .ManufacturingScenarioRepository.Service implementedServices = 8;
  {
    int byte_size = _impl_._implementedservices_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(8, _internal_implementedservices(),
                                       byte_size, target);
    }
  }

  // repeated .ManufacturingScenarioRepository.ServiceInterface consumedServices = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_consumedservices_size()); i < n; i++) {
    const auto& repfield = this->_internal_consumedservices().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .ManufacturingScenarioRepository.ParameterSet parameters = 10;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::parameters(this),
        _Internal::parameters(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ManufacturingScenarioRepository.Module)
  return target;
}

::size_t Module::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ManufacturingScenarioRepository.Module)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ManufacturingScenarioRepository.Module childModules = 1;
  total_size += 1UL * this->_internal_childmodules_size();
  for (const auto& msg : this->_internal_childmodules()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .ManufacturingScenarioRepository.Service implementedServices = 8;
  {
    std::size_t data_size = 0;
    auto count = static_cast<std::size_t>(this->_internal_implementedservices_size());

    for (std::size_t i = 0; i < count; ++i) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
          this->_internal_implementedservices().Get(static_cast<int>(i)));
    }
    total_size += data_size;
    if (data_size > 0) {
      total_size += 1;
      total_size += ::_pbi::WireFormatLite::Int32Size(
          static_cast<int32_t>(data_size));
    }
    _impl_._implementedservices_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
  }
  // repeated .ManufacturingScenarioRepository.ServiceInterface consumedServices = 9;
  total_size += 1UL * this->_internal_consumedservices_size();
  for (const auto& msg : this->_internal_consumedservices()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // string description = 6;
  if (!this->_internal_description().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_description());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // .ManufacturingScenarioRepository.TimePerStateInMS timePerStateInMS = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.timeperstateinms_);
    }

    // .ManufacturingScenarioRepository.EnergyUsePerStateInkWh energyUsePerStateInkWh = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.energyuseperstateinkwh_);
    }

    // .ManufacturingScenarioRepository.OPCUAIdentification id = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.id_);
    }

    // .ManufacturingScenarioRepository.ParameterSet parameters = 10;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.parameters_);
    }

  }
  // double investmentCosts = 7;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_investmentcosts = this->_internal_investmentcosts();
  ::uint64_t raw_investmentcosts;
  memcpy(&raw_investmentcosts, &tmp_investmentcosts, sizeof(tmp_investmentcosts));
  if (raw_investmentcosts != 0) {
    total_size += 9;
  }

  // .ManufacturingScenarioRepository.state currentState = 2;
  if (this->_internal_currentstate() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_currentstate());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Module::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    Module::MergeImpl
};
const ::google::protobuf::Message::ClassData*Module::GetClassData() const { return &_class_data_; }


void Module::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Module*>(&to_msg);
  auto& from = static_cast<const Module&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ManufacturingScenarioRepository.Module)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_childmodules()->MergeFrom(from._internal_childmodules());
  _this->_internal_mutable_implementedservices()->MergeFrom(from._internal_implementedservices());
  _this->_internal_mutable_consumedservices()->MergeFrom(from._internal_consumedservices());
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_timeperstateinms()->::ManufacturingScenarioRepository::TimePerStateInMS::MergeFrom(
          from._internal_timeperstateinms());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_energyuseperstateinkwh()->::ManufacturingScenarioRepository::EnergyUsePerStateInkWh::MergeFrom(
          from._internal_energyuseperstateinkwh());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_id()->::ManufacturingScenarioRepository::OPCUAIdentification::MergeFrom(
          from._internal_id());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_parameters()->::ManufacturingScenarioRepository::ParameterSet::MergeFrom(
          from._internal_parameters());
    }
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_investmentcosts = from._internal_investmentcosts();
  ::uint64_t raw_investmentcosts;
  memcpy(&raw_investmentcosts, &tmp_investmentcosts, sizeof(tmp_investmentcosts));
  if (raw_investmentcosts != 0) {
    _this->_internal_set_investmentcosts(from._internal_investmentcosts());
  }
  if (from._internal_currentstate() != 0) {
    _this->_internal_set_currentstate(from._internal_currentstate());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Module::CopyFrom(const Module& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ManufacturingScenarioRepository.Module)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Module::IsInitialized() const {
  return true;
}

void Module::InternalSwap(Module* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.childmodules_.InternalSwap(&other->_impl_.childmodules_);
  _impl_.implementedservices_.InternalSwap(&other->_impl_.implementedservices_);
  _impl_.consumedservices_.InternalSwap(&other->_impl_.consumedservices_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.description_, lhs_arena,
                                       &other->_impl_.description_, rhs_arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Module, _impl_.currentstate_)
      + sizeof(Module::_impl_.currentstate_)
      - PROTOBUF_FIELD_OFFSET(Module, _impl_.timeperstateinms_)>(
          reinterpret_cast<char*>(&_impl_.timeperstateinms_),
          reinterpret_cast<char*>(&other->_impl_.timeperstateinms_));
}

::google::protobuf::Metadata Module::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ModuleDefinition_2eproto_getter, &descriptor_table_ModuleDefinition_2eproto_once,
      file_level_metadata_ModuleDefinition_2eproto[1]);
}
// ===================================================================

class ParameterSet::_Internal {
 public:
  using HasBits = decltype(std::declval<ParameterSet>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ParameterSet, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::ManufacturingScenarioRepository::ParameterSet, _impl_._oneof_case_);
  static const ::ManufacturingScenarioRepository::OPCUAIdentification& id(const ParameterSet* msg);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::ManufacturingScenarioRepository::ScanlabScannerParams& scanlabscanner(const ParameterSet* msg);
  static const ::ManufacturingScenarioRepository::LaserParams& laser(const ParameterSet* msg);
  static const ::ManufacturingScenarioRepository::StandardCoaterParams& standardcoater(const ParameterSet* msg);
  static const ::ManufacturingScenarioRepository::BuildChamberParams& buildchamber(const ParameterSet* msg);
  static const ::ManufacturingScenarioRepository::CuboidBuildVolumeParams& cuboidbuildvolume(const ParameterSet* msg);
  static const ::ManufacturingScenarioRepository::ZylinderBuildVolumeParams& zylinderbuildvolume(const ParameterSet* msg);
  static const ::ManufacturingScenarioRepository::PreheaterParams& preheater(const ParameterSet* msg);
  static const ::ManufacturingScenarioRepository::NovantaScannerParams& novantascanner(const ParameterSet* msg);
  static const ::ManufacturingScenarioRepository::BasicLPBFMachineParams& basiclpbfmachine(const ParameterSet* msg);
};

const ::ManufacturingScenarioRepository::OPCUAIdentification& ParameterSet::_Internal::id(const ParameterSet* msg) {
  return *msg->_impl_.id_;
}
const ::ManufacturingScenarioRepository::ScanlabScannerParams& ParameterSet::_Internal::scanlabscanner(const ParameterSet* msg) {
  return *msg->_impl_.TypeAndParameters_.scanlabscanner_;
}
const ::ManufacturingScenarioRepository::LaserParams& ParameterSet::_Internal::laser(const ParameterSet* msg) {
  return *msg->_impl_.TypeAndParameters_.laser_;
}
const ::ManufacturingScenarioRepository::StandardCoaterParams& ParameterSet::_Internal::standardcoater(const ParameterSet* msg) {
  return *msg->_impl_.TypeAndParameters_.standardcoater_;
}
const ::ManufacturingScenarioRepository::BuildChamberParams& ParameterSet::_Internal::buildchamber(const ParameterSet* msg) {
  return *msg->_impl_.TypeAndParameters_.buildchamber_;
}
const ::ManufacturingScenarioRepository::CuboidBuildVolumeParams& ParameterSet::_Internal::cuboidbuildvolume(const ParameterSet* msg) {
  return *msg->_impl_.TypeAndParameters_.cuboidbuildvolume_;
}
const ::ManufacturingScenarioRepository::ZylinderBuildVolumeParams& ParameterSet::_Internal::zylinderbuildvolume(const ParameterSet* msg) {
  return *msg->_impl_.TypeAndParameters_.zylinderbuildvolume_;
}
const ::ManufacturingScenarioRepository::PreheaterParams& ParameterSet::_Internal::preheater(const ParameterSet* msg) {
  return *msg->_impl_.TypeAndParameters_.preheater_;
}
const ::ManufacturingScenarioRepository::NovantaScannerParams& ParameterSet::_Internal::novantascanner(const ParameterSet* msg) {
  return *msg->_impl_.TypeAndParameters_.novantascanner_;
}
const ::ManufacturingScenarioRepository::BasicLPBFMachineParams& ParameterSet::_Internal::basiclpbfmachine(const ParameterSet* msg) {
  return *msg->_impl_.TypeAndParameters_.basiclpbfmachine_;
}
void ParameterSet::set_allocated_scanlabscanner(::ManufacturingScenarioRepository::ScanlabScannerParams* scanlabscanner) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_TypeAndParameters();
  if (scanlabscanner) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(scanlabscanner);
    if (message_arena != submessage_arena) {
      scanlabscanner = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, scanlabscanner, submessage_arena);
    }
    set_has_scanlabscanner();
    _impl_.TypeAndParameters_.scanlabscanner_ = scanlabscanner;
  }
  // @@protoc_insertion_point(field_set_allocated:ManufacturingScenarioRepository.ParameterSet.scanlabScanner)
}
void ParameterSet::set_allocated_laser(::ManufacturingScenarioRepository::LaserParams* laser) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_TypeAndParameters();
  if (laser) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(laser);
    if (message_arena != submessage_arena) {
      laser = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, laser, submessage_arena);
    }
    set_has_laser();
    _impl_.TypeAndParameters_.laser_ = laser;
  }
  // @@protoc_insertion_point(field_set_allocated:ManufacturingScenarioRepository.ParameterSet.laser)
}
void ParameterSet::set_allocated_standardcoater(::ManufacturingScenarioRepository::StandardCoaterParams* standardcoater) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_TypeAndParameters();
  if (standardcoater) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(standardcoater);
    if (message_arena != submessage_arena) {
      standardcoater = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, standardcoater, submessage_arena);
    }
    set_has_standardcoater();
    _impl_.TypeAndParameters_.standardcoater_ = standardcoater;
  }
  // @@protoc_insertion_point(field_set_allocated:ManufacturingScenarioRepository.ParameterSet.standardCoater)
}
void ParameterSet::set_allocated_buildchamber(::ManufacturingScenarioRepository::BuildChamberParams* buildchamber) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_TypeAndParameters();
  if (buildchamber) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(buildchamber);
    if (message_arena != submessage_arena) {
      buildchamber = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, buildchamber, submessage_arena);
    }
    set_has_buildchamber();
    _impl_.TypeAndParameters_.buildchamber_ = buildchamber;
  }
  // @@protoc_insertion_point(field_set_allocated:ManufacturingScenarioRepository.ParameterSet.buildChamber)
}
void ParameterSet::set_allocated_cuboidbuildvolume(::ManufacturingScenarioRepository::CuboidBuildVolumeParams* cuboidbuildvolume) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_TypeAndParameters();
  if (cuboidbuildvolume) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(cuboidbuildvolume);
    if (message_arena != submessage_arena) {
      cuboidbuildvolume = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cuboidbuildvolume, submessage_arena);
    }
    set_has_cuboidbuildvolume();
    _impl_.TypeAndParameters_.cuboidbuildvolume_ = cuboidbuildvolume;
  }
  // @@protoc_insertion_point(field_set_allocated:ManufacturingScenarioRepository.ParameterSet.cuboidBuildVolume)
}
void ParameterSet::set_allocated_zylinderbuildvolume(::ManufacturingScenarioRepository::ZylinderBuildVolumeParams* zylinderbuildvolume) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_TypeAndParameters();
  if (zylinderbuildvolume) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(zylinderbuildvolume);
    if (message_arena != submessage_arena) {
      zylinderbuildvolume = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, zylinderbuildvolume, submessage_arena);
    }
    set_has_zylinderbuildvolume();
    _impl_.TypeAndParameters_.zylinderbuildvolume_ = zylinderbuildvolume;
  }
  // @@protoc_insertion_point(field_set_allocated:ManufacturingScenarioRepository.ParameterSet.zylinderBuildVolume)
}
void ParameterSet::set_allocated_preheater(::ManufacturingScenarioRepository::PreheaterParams* preheater) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_TypeAndParameters();
  if (preheater) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(preheater);
    if (message_arena != submessage_arena) {
      preheater = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, preheater, submessage_arena);
    }
    set_has_preheater();
    _impl_.TypeAndParameters_.preheater_ = preheater;
  }
  // @@protoc_insertion_point(field_set_allocated:ManufacturingScenarioRepository.ParameterSet.preheater)
}
void ParameterSet::set_allocated_novantascanner(::ManufacturingScenarioRepository::NovantaScannerParams* novantascanner) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_TypeAndParameters();
  if (novantascanner) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(novantascanner);
    if (message_arena != submessage_arena) {
      novantascanner = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, novantascanner, submessage_arena);
    }
    set_has_novantascanner();
    _impl_.TypeAndParameters_.novantascanner_ = novantascanner;
  }
  // @@protoc_insertion_point(field_set_allocated:ManufacturingScenarioRepository.ParameterSet.novantaScanner)
}
void ParameterSet::set_allocated_basiclpbfmachine(::ManufacturingScenarioRepository::BasicLPBFMachineParams* basiclpbfmachine) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_TypeAndParameters();
  if (basiclpbfmachine) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(basiclpbfmachine);
    if (message_arena != submessage_arena) {
      basiclpbfmachine = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, basiclpbfmachine, submessage_arena);
    }
    set_has_basiclpbfmachine();
    _impl_.TypeAndParameters_.basiclpbfmachine_ = basiclpbfmachine;
  }
  // @@protoc_insertion_point(field_set_allocated:ManufacturingScenarioRepository.ParameterSet.basicLPBFMachine)
}
ParameterSet::ParameterSet(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ManufacturingScenarioRepository.ParameterSet)
}
ParameterSet::ParameterSet(const ParameterSet& from) : ::google::protobuf::Message() {
  ParameterSet* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.id_){nullptr},
      decltype(_impl_.TypeAndParameters_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.id_ = new ::ManufacturingScenarioRepository::OPCUAIdentification(*from._impl_.id_);
  }
  clear_has_TypeAndParameters();
  switch (from.TypeAndParameters_case()) {
    case kScanlabScanner: {
      _this->_internal_mutable_scanlabscanner()->::ManufacturingScenarioRepository::ScanlabScannerParams::MergeFrom(
          from._internal_scanlabscanner());
      break;
    }
    case kLaser: {
      _this->_internal_mutable_laser()->::ManufacturingScenarioRepository::LaserParams::MergeFrom(
          from._internal_laser());
      break;
    }
    case kStandardCoater: {
      _this->_internal_mutable_standardcoater()->::ManufacturingScenarioRepository::StandardCoaterParams::MergeFrom(
          from._internal_standardcoater());
      break;
    }
    case kBuildChamber: {
      _this->_internal_mutable_buildchamber()->::ManufacturingScenarioRepository::BuildChamberParams::MergeFrom(
          from._internal_buildchamber());
      break;
    }
    case kCuboidBuildVolume: {
      _this->_internal_mutable_cuboidbuildvolume()->::ManufacturingScenarioRepository::CuboidBuildVolumeParams::MergeFrom(
          from._internal_cuboidbuildvolume());
      break;
    }
    case kZylinderBuildVolume: {
      _this->_internal_mutable_zylinderbuildvolume()->::ManufacturingScenarioRepository::ZylinderBuildVolumeParams::MergeFrom(
          from._internal_zylinderbuildvolume());
      break;
    }
    case kPreheater: {
      _this->_internal_mutable_preheater()->::ManufacturingScenarioRepository::PreheaterParams::MergeFrom(
          from._internal_preheater());
      break;
    }
    case kNovantaScanner: {
      _this->_internal_mutable_novantascanner()->::ManufacturingScenarioRepository::NovantaScannerParams::MergeFrom(
          from._internal_novantascanner());
      break;
    }
    case kBasicLPBFMachine: {
      _this->_internal_mutable_basiclpbfmachine()->::ManufacturingScenarioRepository::BasicLPBFMachineParams::MergeFrom(
          from._internal_basiclpbfmachine());
      break;
    }
    case TYPEANDPARAMETERS_NOT_SET: {
      break;
    }
  }

  // @@protoc_insertion_point(copy_constructor:ManufacturingScenarioRepository.ParameterSet)
}
inline void ParameterSet::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.id_){nullptr},
      decltype(_impl_.TypeAndParameters_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  clear_has_TypeAndParameters();
}
ParameterSet::~ParameterSet() {
  // @@protoc_insertion_point(destructor:ManufacturingScenarioRepository.ParameterSet)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void ParameterSet::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.id_;
  if (has_TypeAndParameters()) {
    clear_TypeAndParameters();
  }
}
void ParameterSet::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ParameterSet::clear_TypeAndParameters() {
// @@protoc_insertion_point(one_of_clear_start:ManufacturingScenarioRepository.ParameterSet)
  switch (TypeAndParameters_case()) {
    case kScanlabScanner: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.TypeAndParameters_.scanlabscanner_;
      }
      break;
    }
    case kLaser: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.TypeAndParameters_.laser_;
      }
      break;
    }
    case kStandardCoater: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.TypeAndParameters_.standardcoater_;
      }
      break;
    }
    case kBuildChamber: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.TypeAndParameters_.buildchamber_;
      }
      break;
    }
    case kCuboidBuildVolume: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.TypeAndParameters_.cuboidbuildvolume_;
      }
      break;
    }
    case kZylinderBuildVolume: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.TypeAndParameters_.zylinderbuildvolume_;
      }
      break;
    }
    case kPreheater: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.TypeAndParameters_.preheater_;
      }
      break;
    }
    case kNovantaScanner: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.TypeAndParameters_.novantascanner_;
      }
      break;
    }
    case kBasicLPBFMachine: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.TypeAndParameters_.basiclpbfmachine_;
      }
      break;
    }
    case TYPEANDPARAMETERS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = TYPEANDPARAMETERS_NOT_SET;
}


PROTOBUF_NOINLINE void ParameterSet::Clear() {
// @@protoc_insertion_point(message_clear_start:ManufacturingScenarioRepository.ParameterSet)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.id_ != nullptr);
    _impl_.id_->Clear();
  }
  clear_TypeAndParameters();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* ParameterSet::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 10, 10, 0, 7> ParameterSet::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ParameterSet, _impl_._has_bits_),
    0, // no _extensions_
    100, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    3220845054,  // skipmap
    offsetof(decltype(_table_), field_entries),
    10,  // num_field_entries
    10,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_ParameterSet_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // .ManufacturingScenarioRepository.OPCUAIdentification id = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(ParameterSet, _impl_.id_)}},
  }}, {{
    100, 0, 1,
    65534, 9,
    65535, 65535
  }}, {{
    // .ManufacturingScenarioRepository.OPCUAIdentification id = 1;
    {PROTOBUF_FIELD_OFFSET(ParameterSet, _impl_.id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .ManufacturingScenarioRepository.ScanlabScannerParams scanlabScanner = 10;
    {PROTOBUF_FIELD_OFFSET(ParameterSet, _impl_.TypeAndParameters_.scanlabscanner_), _Internal::kOneofCaseOffset + 0, 1,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .ManufacturingScenarioRepository.LaserParams laser = 11;
    {PROTOBUF_FIELD_OFFSET(ParameterSet, _impl_.TypeAndParameters_.laser_), _Internal::kOneofCaseOffset + 0, 2,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .ManufacturingScenarioRepository.StandardCoaterParams standardCoater = 12;
    {PROTOBUF_FIELD_OFFSET(ParameterSet, _impl_.TypeAndParameters_.standardcoater_), _Internal::kOneofCaseOffset + 0, 3,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .ManufacturingScenarioRepository.BuildChamberParams buildChamber = 15;
    {PROTOBUF_FIELD_OFFSET(ParameterSet, _impl_.TypeAndParameters_.buildchamber_), _Internal::kOneofCaseOffset + 0, 4,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .ManufacturingScenarioRepository.CuboidBuildVolumeParams cuboidBuildVolume = 16;
    {PROTOBUF_FIELD_OFFSET(ParameterSet, _impl_.TypeAndParameters_.cuboidbuildvolume_), _Internal::kOneofCaseOffset + 0, 5,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .ManufacturingScenarioRepository.ZylinderBuildVolumeParams zylinderBuildVolume = 17;
    {PROTOBUF_FIELD_OFFSET(ParameterSet, _impl_.TypeAndParameters_.zylinderbuildvolume_), _Internal::kOneofCaseOffset + 0, 6,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .ManufacturingScenarioRepository.PreheaterParams preheater = 19;
    {PROTOBUF_FIELD_OFFSET(ParameterSet, _impl_.TypeAndParameters_.preheater_), _Internal::kOneofCaseOffset + 0, 7,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .ManufacturingScenarioRepository.NovantaScannerParams novantaScanner = 31;
    {PROTOBUF_FIELD_OFFSET(ParameterSet, _impl_.TypeAndParameters_.novantascanner_), _Internal::kOneofCaseOffset + 0, 8,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .ManufacturingScenarioRepository.BasicLPBFMachineParams basicLPBFMachine = 100;
    {PROTOBUF_FIELD_OFFSET(ParameterSet, _impl_.TypeAndParameters_.basiclpbfmachine_), _Internal::kOneofCaseOffset + 0, 9,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::ManufacturingScenarioRepository::OPCUAIdentification>()},
    {::_pbi::TcParser::GetTable<::ManufacturingScenarioRepository::ScanlabScannerParams>()},
    {::_pbi::TcParser::GetTable<::ManufacturingScenarioRepository::LaserParams>()},
    {::_pbi::TcParser::GetTable<::ManufacturingScenarioRepository::StandardCoaterParams>()},
    {::_pbi::TcParser::GetTable<::ManufacturingScenarioRepository::BuildChamberParams>()},
    {::_pbi::TcParser::GetTable<::ManufacturingScenarioRepository::CuboidBuildVolumeParams>()},
    {::_pbi::TcParser::GetTable<::ManufacturingScenarioRepository::ZylinderBuildVolumeParams>()},
    {::_pbi::TcParser::GetTable<::ManufacturingScenarioRepository::PreheaterParams>()},
    {::_pbi::TcParser::GetTable<::ManufacturingScenarioRepository::NovantaScannerParams>()},
    {::_pbi::TcParser::GetTable<::ManufacturingScenarioRepository::BasicLPBFMachineParams>()},
  }}, {{
  }},
};

::uint8_t* ParameterSet::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ManufacturingScenarioRepository.ParameterSet)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .ManufacturingScenarioRepository.OPCUAIdentification id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::id(this),
        _Internal::id(this).GetCachedSize(), target, stream);
  }

  switch (TypeAndParameters_case()) {
    case kScanlabScanner: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(10, _Internal::scanlabscanner(this),
          _Internal::scanlabscanner(this).GetCachedSize(), target, stream);
      break;
    }
    case kLaser: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(11, _Internal::laser(this),
          _Internal::laser(this).GetCachedSize(), target, stream);
      break;
    }
    case kStandardCoater: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(12, _Internal::standardcoater(this),
          _Internal::standardcoater(this).GetCachedSize(), target, stream);
      break;
    }
    case kBuildChamber: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(15, _Internal::buildchamber(this),
          _Internal::buildchamber(this).GetCachedSize(), target, stream);
      break;
    }
    case kCuboidBuildVolume: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(16, _Internal::cuboidbuildvolume(this),
          _Internal::cuboidbuildvolume(this).GetCachedSize(), target, stream);
      break;
    }
    case kZylinderBuildVolume: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(17, _Internal::zylinderbuildvolume(this),
          _Internal::zylinderbuildvolume(this).GetCachedSize(), target, stream);
      break;
    }
    case kPreheater: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(19, _Internal::preheater(this),
          _Internal::preheater(this).GetCachedSize(), target, stream);
      break;
    }
    case kNovantaScanner: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(31, _Internal::novantascanner(this),
          _Internal::novantascanner(this).GetCachedSize(), target, stream);
      break;
    }
    case kBasicLPBFMachine: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(100, _Internal::basiclpbfmachine(this),
          _Internal::basiclpbfmachine(this).GetCachedSize(), target, stream);
      break;
    }
    default:
      break;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ManufacturingScenarioRepository.ParameterSet)
  return target;
}

::size_t ParameterSet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ManufacturingScenarioRepository.ParameterSet)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .ManufacturingScenarioRepository.OPCUAIdentification id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *_impl_.id_);
  }

  switch (TypeAndParameters_case()) {
    // .ManufacturingScenarioRepository.ScanlabScannerParams scanlabScanner = 10;
    case kScanlabScanner: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.TypeAndParameters_.scanlabscanner_);
      break;
    }
    // .ManufacturingScenarioRepository.LaserParams laser = 11;
    case kLaser: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.TypeAndParameters_.laser_);
      break;
    }
    // .ManufacturingScenarioRepository.StandardCoaterParams standardCoater = 12;
    case kStandardCoater: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.TypeAndParameters_.standardcoater_);
      break;
    }
    // .ManufacturingScenarioRepository.BuildChamberParams buildChamber = 15;
    case kBuildChamber: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.TypeAndParameters_.buildchamber_);
      break;
    }
    // .ManufacturingScenarioRepository.CuboidBuildVolumeParams cuboidBuildVolume = 16;
    case kCuboidBuildVolume: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.TypeAndParameters_.cuboidbuildvolume_);
      break;
    }
    // .ManufacturingScenarioRepository.ZylinderBuildVolumeParams zylinderBuildVolume = 17;
    case kZylinderBuildVolume: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.TypeAndParameters_.zylinderbuildvolume_);
      break;
    }
    // .ManufacturingScenarioRepository.PreheaterParams preheater = 19;
    case kPreheater: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.TypeAndParameters_.preheater_);
      break;
    }
    // .ManufacturingScenarioRepository.NovantaScannerParams novantaScanner = 31;
    case kNovantaScanner: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.TypeAndParameters_.novantascanner_);
      break;
    }
    // .ManufacturingScenarioRepository.BasicLPBFMachineParams basicLPBFMachine = 100;
    case kBasicLPBFMachine: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.TypeAndParameters_.basiclpbfmachine_);
      break;
    }
    case TYPEANDPARAMETERS_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData ParameterSet::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    ParameterSet::MergeImpl
};
const ::google::protobuf::Message::ClassData*ParameterSet::GetClassData() const { return &_class_data_; }


void ParameterSet::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<ParameterSet*>(&to_msg);
  auto& from = static_cast<const ParameterSet&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ManufacturingScenarioRepository.ParameterSet)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_id()->::ManufacturingScenarioRepository::OPCUAIdentification::MergeFrom(
        from._internal_id());
  }
  switch (from.TypeAndParameters_case()) {
    case kScanlabScanner: {
      _this->_internal_mutable_scanlabscanner()->::ManufacturingScenarioRepository::ScanlabScannerParams::MergeFrom(
          from._internal_scanlabscanner());
      break;
    }
    case kLaser: {
      _this->_internal_mutable_laser()->::ManufacturingScenarioRepository::LaserParams::MergeFrom(
          from._internal_laser());
      break;
    }
    case kStandardCoater: {
      _this->_internal_mutable_standardcoater()->::ManufacturingScenarioRepository::StandardCoaterParams::MergeFrom(
          from._internal_standardcoater());
      break;
    }
    case kBuildChamber: {
      _this->_internal_mutable_buildchamber()->::ManufacturingScenarioRepository::BuildChamberParams::MergeFrom(
          from._internal_buildchamber());
      break;
    }
    case kCuboidBuildVolume: {
      _this->_internal_mutable_cuboidbuildvolume()->::ManufacturingScenarioRepository::CuboidBuildVolumeParams::MergeFrom(
          from._internal_cuboidbuildvolume());
      break;
    }
    case kZylinderBuildVolume: {
      _this->_internal_mutable_zylinderbuildvolume()->::ManufacturingScenarioRepository::ZylinderBuildVolumeParams::MergeFrom(
          from._internal_zylinderbuildvolume());
      break;
    }
    case kPreheater: {
      _this->_internal_mutable_preheater()->::ManufacturingScenarioRepository::PreheaterParams::MergeFrom(
          from._internal_preheater());
      break;
    }
    case kNovantaScanner: {
      _this->_internal_mutable_novantascanner()->::ManufacturingScenarioRepository::NovantaScannerParams::MergeFrom(
          from._internal_novantascanner());
      break;
    }
    case kBasicLPBFMachine: {
      _this->_internal_mutable_basiclpbfmachine()->::ManufacturingScenarioRepository::BasicLPBFMachineParams::MergeFrom(
          from._internal_basiclpbfmachine());
      break;
    }
    case TYPEANDPARAMETERS_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ParameterSet::CopyFrom(const ParameterSet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ManufacturingScenarioRepository.ParameterSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool ParameterSet::IsInitialized() const {
  return true;
}

void ParameterSet::InternalSwap(ParameterSet* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.id_, other->_impl_.id_);
  swap(_impl_.TypeAndParameters_, other->_impl_.TypeAndParameters_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata ParameterSet::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ModuleDefinition_2eproto_getter, &descriptor_table_ModuleDefinition_2eproto_once,
      file_level_metadata_ModuleDefinition_2eproto[2]);
}
// ===================================================================

class BasicLPBFMachineParams::_Internal {
 public:
};

BasicLPBFMachineParams::BasicLPBFMachineParams(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ManufacturingScenarioRepository.BasicLPBFMachineParams)
}
BasicLPBFMachineParams::BasicLPBFMachineParams(const BasicLPBFMachineParams& from) : ::google::protobuf::Message() {
  BasicLPBFMachineParams* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.scanfields_){from._impl_.scanfields_},
      decltype(_impl_.minlayerheightum_){},
      decltype(_impl_.minzdistmm_){},
      decltype(_impl_.minimalhatchlength_){},
      decltype(_impl_.forcedminimumexposuretimeins_){},
      decltype(_impl_.numberoflaserscannerunits_){},
      /*decltype(_impl_._cached_size_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  ::memcpy(&_impl_.minlayerheightum_, &from._impl_.minlayerheightum_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.numberoflaserscannerunits_) -
    reinterpret_cast<char*>(&_impl_.minlayerheightum_)) + sizeof(_impl_.numberoflaserscannerunits_));

  // @@protoc_insertion_point(copy_constructor:ManufacturingScenarioRepository.BasicLPBFMachineParams)
}
inline void BasicLPBFMachineParams::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.scanfields_){arena},
      decltype(_impl_.minlayerheightum_){0},
      decltype(_impl_.minzdistmm_){0},
      decltype(_impl_.minimalhatchlength_){0},
      decltype(_impl_.forcedminimumexposuretimeins_){0},
      decltype(_impl_.numberoflaserscannerunits_){0},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
BasicLPBFMachineParams::~BasicLPBFMachineParams() {
  // @@protoc_insertion_point(destructor:ManufacturingScenarioRepository.BasicLPBFMachineParams)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void BasicLPBFMachineParams::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.scanfields_.~RepeatedPtrField();
}
void BasicLPBFMachineParams::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void BasicLPBFMachineParams::Clear() {
// @@protoc_insertion_point(message_clear_start:ManufacturingScenarioRepository.BasicLPBFMachineParams)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_scanfields()->Clear();
  ::memset(&_impl_.minlayerheightum_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.numberoflaserscannerunits_) -
      reinterpret_cast<char*>(&_impl_.minlayerheightum_)) + sizeof(_impl_.numberoflaserscannerunits_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* BasicLPBFMachineParams::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 1, 0, 2> BasicLPBFMachineParams::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    20, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294435326,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_BasicLPBFMachineParams_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // int32 numberOfLaserScannerUnits = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(BasicLPBFMachineParams, _impl_.numberoflaserscannerunits_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(BasicLPBFMachineParams, _impl_.numberoflaserscannerunits_)}},
    // double MinLayerHeightUM = 10;
    {::_pbi::TcParser::FastF64S1,
     {81, 63, 0, PROTOBUF_FIELD_OFFSET(BasicLPBFMachineParams, _impl_.minlayerheightum_)}},
    // double MinZDistMm = 11;
    {::_pbi::TcParser::FastF64S1,
     {89, 63, 0, PROTOBUF_FIELD_OFFSET(BasicLPBFMachineParams, _impl_.minzdistmm_)}},
    // double MinimalHatchLength = 12;
    {::_pbi::TcParser::FastF64S1,
     {97, 63, 0, PROTOBUF_FIELD_OFFSET(BasicLPBFMachineParams, _impl_.minimalhatchlength_)}},
    // double ForcedMinimumExposureTimeInS = 13;
    {::_pbi::TcParser::FastF64S1,
     {105, 63, 0, PROTOBUF_FIELD_OFFSET(BasicLPBFMachineParams, _impl_.forcedminimumexposuretimeins_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // int32 numberOfLaserScannerUnits = 1;
    {PROTOBUF_FIELD_OFFSET(BasicLPBFMachineParams, _impl_.numberoflaserscannerunits_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // double MinLayerHeightUM = 10;
    {PROTOBUF_FIELD_OFFSET(BasicLPBFMachineParams, _impl_.minlayerheightum_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double MinZDistMm = 11;
    {PROTOBUF_FIELD_OFFSET(BasicLPBFMachineParams, _impl_.minzdistmm_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double MinimalHatchLength = 12;
    {PROTOBUF_FIELD_OFFSET(BasicLPBFMachineParams, _impl_.minimalhatchlength_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double ForcedMinimumExposureTimeInS = 13;
    {PROTOBUF_FIELD_OFFSET(BasicLPBFMachineParams, _impl_.forcedminimumexposuretimeins_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // repeated .ManufacturingScenarioRepository.ScanField scanFields = 20;
    {PROTOBUF_FIELD_OFFSET(BasicLPBFMachineParams, _impl_.scanfields_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::ManufacturingScenarioRepository::ScanField>()},
  }}, {{
  }},
};

::uint8_t* BasicLPBFMachineParams::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ManufacturingScenarioRepository.BasicLPBFMachineParams)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // int32 numberOfLaserScannerUnits = 1;
  if (this->_internal_numberoflaserscannerunits() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<1>(
            stream, this->_internal_numberoflaserscannerunits(), target);
  }

  // double MinLayerHeightUM = 10;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_minlayerheightum = this->_internal_minlayerheightum();
  ::uint64_t raw_minlayerheightum;
  memcpy(&raw_minlayerheightum, &tmp_minlayerheightum, sizeof(tmp_minlayerheightum));
  if (raw_minlayerheightum != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        10, this->_internal_minlayerheightum(), target);
  }

  // double MinZDistMm = 11;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_minzdistmm = this->_internal_minzdistmm();
  ::uint64_t raw_minzdistmm;
  memcpy(&raw_minzdistmm, &tmp_minzdistmm, sizeof(tmp_minzdistmm));
  if (raw_minzdistmm != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        11, this->_internal_minzdistmm(), target);
  }

  // double MinimalHatchLength = 12;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_minimalhatchlength = this->_internal_minimalhatchlength();
  ::uint64_t raw_minimalhatchlength;
  memcpy(&raw_minimalhatchlength, &tmp_minimalhatchlength, sizeof(tmp_minimalhatchlength));
  if (raw_minimalhatchlength != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        12, this->_internal_minimalhatchlength(), target);
  }

  // double ForcedMinimumExposureTimeInS = 13;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_forcedminimumexposuretimeins = this->_internal_forcedminimumexposuretimeins();
  ::uint64_t raw_forcedminimumexposuretimeins;
  memcpy(&raw_forcedminimumexposuretimeins, &tmp_forcedminimumexposuretimeins, sizeof(tmp_forcedminimumexposuretimeins));
  if (raw_forcedminimumexposuretimeins != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        13, this->_internal_forcedminimumexposuretimeins(), target);
  }

  // repeated .ManufacturingScenarioRepository.ScanField scanFields = 20;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_scanfields_size()); i < n; i++) {
    const auto& repfield = this->_internal_scanfields().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(20, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ManufacturingScenarioRepository.BasicLPBFMachineParams)
  return target;
}

::size_t BasicLPBFMachineParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ManufacturingScenarioRepository.BasicLPBFMachineParams)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ManufacturingScenarioRepository.ScanField scanFields = 20;
  total_size += 2UL * this->_internal_scanfields_size();
  for (const auto& msg : this->_internal_scanfields()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // double MinLayerHeightUM = 10;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_minlayerheightum = this->_internal_minlayerheightum();
  ::uint64_t raw_minlayerheightum;
  memcpy(&raw_minlayerheightum, &tmp_minlayerheightum, sizeof(tmp_minlayerheightum));
  if (raw_minlayerheightum != 0) {
    total_size += 9;
  }

  // double MinZDistMm = 11;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_minzdistmm = this->_internal_minzdistmm();
  ::uint64_t raw_minzdistmm;
  memcpy(&raw_minzdistmm, &tmp_minzdistmm, sizeof(tmp_minzdistmm));
  if (raw_minzdistmm != 0) {
    total_size += 9;
  }

  // double MinimalHatchLength = 12;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_minimalhatchlength = this->_internal_minimalhatchlength();
  ::uint64_t raw_minimalhatchlength;
  memcpy(&raw_minimalhatchlength, &tmp_minimalhatchlength, sizeof(tmp_minimalhatchlength));
  if (raw_minimalhatchlength != 0) {
    total_size += 9;
  }

  // double ForcedMinimumExposureTimeInS = 13;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_forcedminimumexposuretimeins = this->_internal_forcedminimumexposuretimeins();
  ::uint64_t raw_forcedminimumexposuretimeins;
  memcpy(&raw_forcedminimumexposuretimeins, &tmp_forcedminimumexposuretimeins, sizeof(tmp_forcedminimumexposuretimeins));
  if (raw_forcedminimumexposuretimeins != 0) {
    total_size += 9;
  }

  // int32 numberOfLaserScannerUnits = 1;
  if (this->_internal_numberoflaserscannerunits() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_numberoflaserscannerunits());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData BasicLPBFMachineParams::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    BasicLPBFMachineParams::MergeImpl
};
const ::google::protobuf::Message::ClassData*BasicLPBFMachineParams::GetClassData() const { return &_class_data_; }


void BasicLPBFMachineParams::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<BasicLPBFMachineParams*>(&to_msg);
  auto& from = static_cast<const BasicLPBFMachineParams&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ManufacturingScenarioRepository.BasicLPBFMachineParams)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_scanfields()->MergeFrom(from._internal_scanfields());
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_minlayerheightum = from._internal_minlayerheightum();
  ::uint64_t raw_minlayerheightum;
  memcpy(&raw_minlayerheightum, &tmp_minlayerheightum, sizeof(tmp_minlayerheightum));
  if (raw_minlayerheightum != 0) {
    _this->_internal_set_minlayerheightum(from._internal_minlayerheightum());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_minzdistmm = from._internal_minzdistmm();
  ::uint64_t raw_minzdistmm;
  memcpy(&raw_minzdistmm, &tmp_minzdistmm, sizeof(tmp_minzdistmm));
  if (raw_minzdistmm != 0) {
    _this->_internal_set_minzdistmm(from._internal_minzdistmm());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_minimalhatchlength = from._internal_minimalhatchlength();
  ::uint64_t raw_minimalhatchlength;
  memcpy(&raw_minimalhatchlength, &tmp_minimalhatchlength, sizeof(tmp_minimalhatchlength));
  if (raw_minimalhatchlength != 0) {
    _this->_internal_set_minimalhatchlength(from._internal_minimalhatchlength());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_forcedminimumexposuretimeins = from._internal_forcedminimumexposuretimeins();
  ::uint64_t raw_forcedminimumexposuretimeins;
  memcpy(&raw_forcedminimumexposuretimeins, &tmp_forcedminimumexposuretimeins, sizeof(tmp_forcedminimumexposuretimeins));
  if (raw_forcedminimumexposuretimeins != 0) {
    _this->_internal_set_forcedminimumexposuretimeins(from._internal_forcedminimumexposuretimeins());
  }
  if (from._internal_numberoflaserscannerunits() != 0) {
    _this->_internal_set_numberoflaserscannerunits(from._internal_numberoflaserscannerunits());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void BasicLPBFMachineParams::CopyFrom(const BasicLPBFMachineParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ManufacturingScenarioRepository.BasicLPBFMachineParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool BasicLPBFMachineParams::IsInitialized() const {
  return true;
}

void BasicLPBFMachineParams::InternalSwap(BasicLPBFMachineParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.scanfields_.InternalSwap(&other->_impl_.scanfields_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BasicLPBFMachineParams, _impl_.numberoflaserscannerunits_)
      + sizeof(BasicLPBFMachineParams::_impl_.numberoflaserscannerunits_)
      - PROTOBUF_FIELD_OFFSET(BasicLPBFMachineParams, _impl_.minlayerheightum_)>(
          reinterpret_cast<char*>(&_impl_.minlayerheightum_),
          reinterpret_cast<char*>(&other->_impl_.minlayerheightum_));
}

::google::protobuf::Metadata BasicLPBFMachineParams::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ModuleDefinition_2eproto_getter, &descriptor_table_ModuleDefinition_2eproto_once,
      file_level_metadata_ModuleDefinition_2eproto[3]);
}
// ===================================================================

class ServiceInterface::_Internal {
 public:
  using HasBits = decltype(std::declval<ServiceInterface>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ServiceInterface, _impl_._has_bits_);
  static const ::ManufacturingScenarioRepository::OPCUAIdentification& implementingmodule(const ServiceInterface* msg);
  static void set_has_implementingmodule(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::ManufacturingScenarioRepository::OPCUAIdentification& ServiceInterface::_Internal::implementingmodule(const ServiceInterface* msg) {
  return *msg->_impl_.implementingmodule_;
}
ServiceInterface::ServiceInterface(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ManufacturingScenarioRepository.ServiceInterface)
}
ServiceInterface::ServiceInterface(const ServiceInterface& from) : ::google::protobuf::Message() {
  ServiceInterface* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.implementingmodule_){nullptr},
      decltype(_impl_.consumedservice_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.implementingmodule_ = new ::ManufacturingScenarioRepository::OPCUAIdentification(*from._impl_.implementingmodule_);
  }
  _this->_impl_.consumedservice_ = from._impl_.consumedservice_;

  // @@protoc_insertion_point(copy_constructor:ManufacturingScenarioRepository.ServiceInterface)
}
inline void ServiceInterface::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.implementingmodule_){nullptr},
      decltype(_impl_.consumedservice_){0},
  };
}
ServiceInterface::~ServiceInterface() {
  // @@protoc_insertion_point(destructor:ManufacturingScenarioRepository.ServiceInterface)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void ServiceInterface::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.implementingmodule_;
}
void ServiceInterface::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void ServiceInterface::Clear() {
// @@protoc_insertion_point(message_clear_start:ManufacturingScenarioRepository.ServiceInterface)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.implementingmodule_ != nullptr);
    _impl_.implementingmodule_->Clear();
  }
  _impl_.consumedservice_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* ServiceInterface::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 1, 0, 2> ServiceInterface::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ServiceInterface, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_ServiceInterface_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // .ManufacturingScenarioRepository.OPCUAIdentification implementingModule = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(ServiceInterface, _impl_.implementingmodule_)}},
    // .ManufacturingScenarioRepository.Service consumedService = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ServiceInterface, _impl_.consumedservice_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(ServiceInterface, _impl_.consumedservice_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .ManufacturingScenarioRepository.Service consumedService = 1;
    {PROTOBUF_FIELD_OFFSET(ServiceInterface, _impl_.consumedservice_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .ManufacturingScenarioRepository.OPCUAIdentification implementingModule = 2;
    {PROTOBUF_FIELD_OFFSET(ServiceInterface, _impl_.implementingmodule_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::ManufacturingScenarioRepository::OPCUAIdentification>()},
  }}, {{
  }},
};

::uint8_t* ServiceInterface::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ManufacturingScenarioRepository.ServiceInterface)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // .ManufacturingScenarioRepository.Service consumedService = 1;
  if (this->_internal_consumedservice() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_consumedservice(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .ManufacturingScenarioRepository.OPCUAIdentification implementingModule = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::implementingmodule(this),
        _Internal::implementingmodule(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ManufacturingScenarioRepository.ServiceInterface)
  return target;
}

::size_t ServiceInterface::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ManufacturingScenarioRepository.ServiceInterface)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .ManufacturingScenarioRepository.OPCUAIdentification implementingModule = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *_impl_.implementingmodule_);
  }

  // .ManufacturingScenarioRepository.Service consumedService = 1;
  if (this->_internal_consumedservice() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_consumedservice());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData ServiceInterface::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    ServiceInterface::MergeImpl
};
const ::google::protobuf::Message::ClassData*ServiceInterface::GetClassData() const { return &_class_data_; }


void ServiceInterface::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<ServiceInterface*>(&to_msg);
  auto& from = static_cast<const ServiceInterface&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ManufacturingScenarioRepository.ServiceInterface)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_implementingmodule()->::ManufacturingScenarioRepository::OPCUAIdentification::MergeFrom(
        from._internal_implementingmodule());
  }
  if (from._internal_consumedservice() != 0) {
    _this->_internal_set_consumedservice(from._internal_consumedservice());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ServiceInterface::CopyFrom(const ServiceInterface& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ManufacturingScenarioRepository.ServiceInterface)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool ServiceInterface::IsInitialized() const {
  return true;
}

void ServiceInterface::InternalSwap(ServiceInterface* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ServiceInterface, _impl_.consumedservice_)
      + sizeof(ServiceInterface::_impl_.consumedservice_)
      - PROTOBUF_FIELD_OFFSET(ServiceInterface, _impl_.implementingmodule_)>(
          reinterpret_cast<char*>(&_impl_.implementingmodule_),
          reinterpret_cast<char*>(&other->_impl_.implementingmodule_));
}

::google::protobuf::Metadata ServiceInterface::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ModuleDefinition_2eproto_getter, &descriptor_table_ModuleDefinition_2eproto_once,
      file_level_metadata_ModuleDefinition_2eproto[4]);
}
// ===================================================================

class BasicScannerParams::_Internal {
 public:
};

BasicScannerParams::BasicScannerParams(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ManufacturingScenarioRepository.BasicScannerParams)
}
BasicScannerParams::BasicScannerParams(const BasicScannerParams& from)
    : ::google::protobuf::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ManufacturingScenarioRepository.BasicScannerParams)
}
inline void BasicScannerParams::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.jumpspeedinmms_){0},
      decltype(_impl_.markspeedinmms_){0},
      decltype(_impl_.laserfocusshiftinmm_){0},
      decltype(_impl_.maxaccelerationinmmperss_){0},
      decltype(_impl_.staticdelayins_){0},
      decltype(_impl_.jumpdelayinus_){0},
      decltype(_impl_.markdelayinus_){0},
      decltype(_impl_.laseroffdelayinus_){0},
      decltype(_impl_.laserondelayinus_){0},
      decltype(_impl_.polygondelayinus_){0},
      decltype(_impl_.vectorblockdelay_){0},
      decltype(_impl_.paramchangedelay_){0},
      decltype(_impl_.warpjumplengthlimit_){0},
      decltype(_impl_.jumpmode_){0},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
BasicScannerParams::~BasicScannerParams() {
  // @@protoc_insertion_point(destructor:ManufacturingScenarioRepository.BasicScannerParams)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void BasicScannerParams::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}
void BasicScannerParams::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void BasicScannerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:ManufacturingScenarioRepository.BasicScannerParams)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.jumpspeedinmms_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.jumpmode_) -
      reinterpret_cast<char*>(&_impl_.jumpspeedinmms_)) + sizeof(_impl_.jumpmode_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* BasicScannerParams::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 14, 0, 0, 2> BasicScannerParams::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    14, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950912,  // skipmap
    offsetof(decltype(_table_), field_entries),
    14,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_BasicScannerParams_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // double jumpSpeedInMmS = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(BasicScannerParams, _impl_.jumpspeedinmms_)}},
    // double markSpeedInMmS = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(BasicScannerParams, _impl_.markspeedinmms_)}},
    // double laserFocusShiftInMm = 3;
    {::_pbi::TcParser::FastF64S1,
     {25, 63, 0, PROTOBUF_FIELD_OFFSET(BasicScannerParams, _impl_.laserfocusshiftinmm_)}},
    // double maxAccelerationInMmPerSS = 4;
    {::_pbi::TcParser::FastF64S1,
     {33, 63, 0, PROTOBUF_FIELD_OFFSET(BasicScannerParams, _impl_.maxaccelerationinmmperss_)}},
    // double staticDelayInS = 5;
    {::_pbi::TcParser::FastF64S1,
     {41, 63, 0, PROTOBUF_FIELD_OFFSET(BasicScannerParams, _impl_.staticdelayins_)}},
    // double jumpDelayInUs = 6;
    {::_pbi::TcParser::FastF64S1,
     {49, 63, 0, PROTOBUF_FIELD_OFFSET(BasicScannerParams, _impl_.jumpdelayinus_)}},
    // double markDelayInUs = 7;
    {::_pbi::TcParser::FastF64S1,
     {57, 63, 0, PROTOBUF_FIELD_OFFSET(BasicScannerParams, _impl_.markdelayinus_)}},
    // double laserOffDelayInUs = 8;
    {::_pbi::TcParser::FastF64S1,
     {65, 63, 0, PROTOBUF_FIELD_OFFSET(BasicScannerParams, _impl_.laseroffdelayinus_)}},
    // double laserOnDelayInUs = 9;
    {::_pbi::TcParser::FastF64S1,
     {73, 63, 0, PROTOBUF_FIELD_OFFSET(BasicScannerParams, _impl_.laserondelayinus_)}},
    // double polygonDelayInUs = 10;
    {::_pbi::TcParser::FastF64S1,
     {81, 63, 0, PROTOBUF_FIELD_OFFSET(BasicScannerParams, _impl_.polygondelayinus_)}},
    // double VectorBlockDelay = 11;
    {::_pbi::TcParser::FastF64S1,
     {89, 63, 0, PROTOBUF_FIELD_OFFSET(BasicScannerParams, _impl_.vectorblockdelay_)}},
    // double ParamChangeDelay = 12;
    {::_pbi::TcParser::FastF64S1,
     {97, 63, 0, PROTOBUF_FIELD_OFFSET(BasicScannerParams, _impl_.paramchangedelay_)}},
    // double WarpJumpLengthLimit = 13;
    {::_pbi::TcParser::FastF64S1,
     {105, 63, 0, PROTOBUF_FIELD_OFFSET(BasicScannerParams, _impl_.warpjumplengthlimit_)}},
    // .ManufacturingScenarioRepository.BasicScannerParams.JumpMode jumpMode = 14;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(BasicScannerParams, _impl_.jumpmode_), 63>(),
     {112, 63, 0, PROTOBUF_FIELD_OFFSET(BasicScannerParams, _impl_.jumpmode_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // double jumpSpeedInMmS = 1;
    {PROTOBUF_FIELD_OFFSET(BasicScannerParams, _impl_.jumpspeedinmms_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double markSpeedInMmS = 2;
    {PROTOBUF_FIELD_OFFSET(BasicScannerParams, _impl_.markspeedinmms_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double laserFocusShiftInMm = 3;
    {PROTOBUF_FIELD_OFFSET(BasicScannerParams, _impl_.laserfocusshiftinmm_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double maxAccelerationInMmPerSS = 4;
    {PROTOBUF_FIELD_OFFSET(BasicScannerParams, _impl_.maxaccelerationinmmperss_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double staticDelayInS = 5;
    {PROTOBUF_FIELD_OFFSET(BasicScannerParams, _impl_.staticdelayins_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double jumpDelayInUs = 6;
    {PROTOBUF_FIELD_OFFSET(BasicScannerParams, _impl_.jumpdelayinus_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double markDelayInUs = 7;
    {PROTOBUF_FIELD_OFFSET(BasicScannerParams, _impl_.markdelayinus_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double laserOffDelayInUs = 8;
    {PROTOBUF_FIELD_OFFSET(BasicScannerParams, _impl_.laseroffdelayinus_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double laserOnDelayInUs = 9;
    {PROTOBUF_FIELD_OFFSET(BasicScannerParams, _impl_.laserondelayinus_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double polygonDelayInUs = 10;
    {PROTOBUF_FIELD_OFFSET(BasicScannerParams, _impl_.polygondelayinus_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double VectorBlockDelay = 11;
    {PROTOBUF_FIELD_OFFSET(BasicScannerParams, _impl_.vectorblockdelay_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double ParamChangeDelay = 12;
    {PROTOBUF_FIELD_OFFSET(BasicScannerParams, _impl_.paramchangedelay_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double WarpJumpLengthLimit = 13;
    {PROTOBUF_FIELD_OFFSET(BasicScannerParams, _impl_.warpjumplengthlimit_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // .ManufacturingScenarioRepository.BasicScannerParams.JumpMode jumpMode = 14;
    {PROTOBUF_FIELD_OFFSET(BasicScannerParams, _impl_.jumpmode_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* BasicScannerParams::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ManufacturingScenarioRepository.BasicScannerParams)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double jumpSpeedInMmS = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_jumpspeedinmms = this->_internal_jumpspeedinmms();
  ::uint64_t raw_jumpspeedinmms;
  memcpy(&raw_jumpspeedinmms, &tmp_jumpspeedinmms, sizeof(tmp_jumpspeedinmms));
  if (raw_jumpspeedinmms != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_jumpspeedinmms(), target);
  }

  // double markSpeedInMmS = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_markspeedinmms = this->_internal_markspeedinmms();
  ::uint64_t raw_markspeedinmms;
  memcpy(&raw_markspeedinmms, &tmp_markspeedinmms, sizeof(tmp_markspeedinmms));
  if (raw_markspeedinmms != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_markspeedinmms(), target);
  }

  // double laserFocusShiftInMm = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_laserfocusshiftinmm = this->_internal_laserfocusshiftinmm();
  ::uint64_t raw_laserfocusshiftinmm;
  memcpy(&raw_laserfocusshiftinmm, &tmp_laserfocusshiftinmm, sizeof(tmp_laserfocusshiftinmm));
  if (raw_laserfocusshiftinmm != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_laserfocusshiftinmm(), target);
  }

  // double maxAccelerationInMmPerSS = 4;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_maxaccelerationinmmperss = this->_internal_maxaccelerationinmmperss();
  ::uint64_t raw_maxaccelerationinmmperss;
  memcpy(&raw_maxaccelerationinmmperss, &tmp_maxaccelerationinmmperss, sizeof(tmp_maxaccelerationinmmperss));
  if (raw_maxaccelerationinmmperss != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        4, this->_internal_maxaccelerationinmmperss(), target);
  }

  // double staticDelayInS = 5;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_staticdelayins = this->_internal_staticdelayins();
  ::uint64_t raw_staticdelayins;
  memcpy(&raw_staticdelayins, &tmp_staticdelayins, sizeof(tmp_staticdelayins));
  if (raw_staticdelayins != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        5, this->_internal_staticdelayins(), target);
  }

  // double jumpDelayInUs = 6;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_jumpdelayinus = this->_internal_jumpdelayinus();
  ::uint64_t raw_jumpdelayinus;
  memcpy(&raw_jumpdelayinus, &tmp_jumpdelayinus, sizeof(tmp_jumpdelayinus));
  if (raw_jumpdelayinus != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        6, this->_internal_jumpdelayinus(), target);
  }

  // double markDelayInUs = 7;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_markdelayinus = this->_internal_markdelayinus();
  ::uint64_t raw_markdelayinus;
  memcpy(&raw_markdelayinus, &tmp_markdelayinus, sizeof(tmp_markdelayinus));
  if (raw_markdelayinus != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        7, this->_internal_markdelayinus(), target);
  }

  // double laserOffDelayInUs = 8;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_laseroffdelayinus = this->_internal_laseroffdelayinus();
  ::uint64_t raw_laseroffdelayinus;
  memcpy(&raw_laseroffdelayinus, &tmp_laseroffdelayinus, sizeof(tmp_laseroffdelayinus));
  if (raw_laseroffdelayinus != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        8, this->_internal_laseroffdelayinus(), target);
  }

  // double laserOnDelayInUs = 9;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_laserondelayinus = this->_internal_laserondelayinus();
  ::uint64_t raw_laserondelayinus;
  memcpy(&raw_laserondelayinus, &tmp_laserondelayinus, sizeof(tmp_laserondelayinus));
  if (raw_laserondelayinus != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        9, this->_internal_laserondelayinus(), target);
  }

  // double polygonDelayInUs = 10;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_polygondelayinus = this->_internal_polygondelayinus();
  ::uint64_t raw_polygondelayinus;
  memcpy(&raw_polygondelayinus, &tmp_polygondelayinus, sizeof(tmp_polygondelayinus));
  if (raw_polygondelayinus != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        10, this->_internal_polygondelayinus(), target);
  }

  // double VectorBlockDelay = 11;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_vectorblockdelay = this->_internal_vectorblockdelay();
  ::uint64_t raw_vectorblockdelay;
  memcpy(&raw_vectorblockdelay, &tmp_vectorblockdelay, sizeof(tmp_vectorblockdelay));
  if (raw_vectorblockdelay != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        11, this->_internal_vectorblockdelay(), target);
  }

  // double ParamChangeDelay = 12;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_paramchangedelay = this->_internal_paramchangedelay();
  ::uint64_t raw_paramchangedelay;
  memcpy(&raw_paramchangedelay, &tmp_paramchangedelay, sizeof(tmp_paramchangedelay));
  if (raw_paramchangedelay != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        12, this->_internal_paramchangedelay(), target);
  }

  // double WarpJumpLengthLimit = 13;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_warpjumplengthlimit = this->_internal_warpjumplengthlimit();
  ::uint64_t raw_warpjumplengthlimit;
  memcpy(&raw_warpjumplengthlimit, &tmp_warpjumplengthlimit, sizeof(tmp_warpjumplengthlimit));
  if (raw_warpjumplengthlimit != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        13, this->_internal_warpjumplengthlimit(), target);
  }

  // .ManufacturingScenarioRepository.BasicScannerParams.JumpMode jumpMode = 14;
  if (this->_internal_jumpmode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        14, this->_internal_jumpmode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ManufacturingScenarioRepository.BasicScannerParams)
  return target;
}

::size_t BasicScannerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ManufacturingScenarioRepository.BasicScannerParams)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double jumpSpeedInMmS = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_jumpspeedinmms = this->_internal_jumpspeedinmms();
  ::uint64_t raw_jumpspeedinmms;
  memcpy(&raw_jumpspeedinmms, &tmp_jumpspeedinmms, sizeof(tmp_jumpspeedinmms));
  if (raw_jumpspeedinmms != 0) {
    total_size += 9;
  }

  // double markSpeedInMmS = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_markspeedinmms = this->_internal_markspeedinmms();
  ::uint64_t raw_markspeedinmms;
  memcpy(&raw_markspeedinmms, &tmp_markspeedinmms, sizeof(tmp_markspeedinmms));
  if (raw_markspeedinmms != 0) {
    total_size += 9;
  }

  // double laserFocusShiftInMm = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_laserfocusshiftinmm = this->_internal_laserfocusshiftinmm();
  ::uint64_t raw_laserfocusshiftinmm;
  memcpy(&raw_laserfocusshiftinmm, &tmp_laserfocusshiftinmm, sizeof(tmp_laserfocusshiftinmm));
  if (raw_laserfocusshiftinmm != 0) {
    total_size += 9;
  }

  // double maxAccelerationInMmPerSS = 4;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_maxaccelerationinmmperss = this->_internal_maxaccelerationinmmperss();
  ::uint64_t raw_maxaccelerationinmmperss;
  memcpy(&raw_maxaccelerationinmmperss, &tmp_maxaccelerationinmmperss, sizeof(tmp_maxaccelerationinmmperss));
  if (raw_maxaccelerationinmmperss != 0) {
    total_size += 9;
  }

  // double staticDelayInS = 5;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_staticdelayins = this->_internal_staticdelayins();
  ::uint64_t raw_staticdelayins;
  memcpy(&raw_staticdelayins, &tmp_staticdelayins, sizeof(tmp_staticdelayins));
  if (raw_staticdelayins != 0) {
    total_size += 9;
  }

  // double jumpDelayInUs = 6;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_jumpdelayinus = this->_internal_jumpdelayinus();
  ::uint64_t raw_jumpdelayinus;
  memcpy(&raw_jumpdelayinus, &tmp_jumpdelayinus, sizeof(tmp_jumpdelayinus));
  if (raw_jumpdelayinus != 0) {
    total_size += 9;
  }

  // double markDelayInUs = 7;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_markdelayinus = this->_internal_markdelayinus();
  ::uint64_t raw_markdelayinus;
  memcpy(&raw_markdelayinus, &tmp_markdelayinus, sizeof(tmp_markdelayinus));
  if (raw_markdelayinus != 0) {
    total_size += 9;
  }

  // double laserOffDelayInUs = 8;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_laseroffdelayinus = this->_internal_laseroffdelayinus();
  ::uint64_t raw_laseroffdelayinus;
  memcpy(&raw_laseroffdelayinus, &tmp_laseroffdelayinus, sizeof(tmp_laseroffdelayinus));
  if (raw_laseroffdelayinus != 0) {
    total_size += 9;
  }

  // double laserOnDelayInUs = 9;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_laserondelayinus = this->_internal_laserondelayinus();
  ::uint64_t raw_laserondelayinus;
  memcpy(&raw_laserondelayinus, &tmp_laserondelayinus, sizeof(tmp_laserondelayinus));
  if (raw_laserondelayinus != 0) {
    total_size += 9;
  }

  // double polygonDelayInUs = 10;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_polygondelayinus = this->_internal_polygondelayinus();
  ::uint64_t raw_polygondelayinus;
  memcpy(&raw_polygondelayinus, &tmp_polygondelayinus, sizeof(tmp_polygondelayinus));
  if (raw_polygondelayinus != 0) {
    total_size += 9;
  }

  // double VectorBlockDelay = 11;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_vectorblockdelay = this->_internal_vectorblockdelay();
  ::uint64_t raw_vectorblockdelay;
  memcpy(&raw_vectorblockdelay, &tmp_vectorblockdelay, sizeof(tmp_vectorblockdelay));
  if (raw_vectorblockdelay != 0) {
    total_size += 9;
  }

  // double ParamChangeDelay = 12;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_paramchangedelay = this->_internal_paramchangedelay();
  ::uint64_t raw_paramchangedelay;
  memcpy(&raw_paramchangedelay, &tmp_paramchangedelay, sizeof(tmp_paramchangedelay));
  if (raw_paramchangedelay != 0) {
    total_size += 9;
  }

  // double WarpJumpLengthLimit = 13;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_warpjumplengthlimit = this->_internal_warpjumplengthlimit();
  ::uint64_t raw_warpjumplengthlimit;
  memcpy(&raw_warpjumplengthlimit, &tmp_warpjumplengthlimit, sizeof(tmp_warpjumplengthlimit));
  if (raw_warpjumplengthlimit != 0) {
    total_size += 9;
  }

  // .ManufacturingScenarioRepository.BasicScannerParams.JumpMode jumpMode = 14;
  if (this->_internal_jumpmode() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_jumpmode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData BasicScannerParams::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    BasicScannerParams::MergeImpl
};
const ::google::protobuf::Message::ClassData*BasicScannerParams::GetClassData() const { return &_class_data_; }


void BasicScannerParams::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<BasicScannerParams*>(&to_msg);
  auto& from = static_cast<const BasicScannerParams&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ManufacturingScenarioRepository.BasicScannerParams)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_jumpspeedinmms = from._internal_jumpspeedinmms();
  ::uint64_t raw_jumpspeedinmms;
  memcpy(&raw_jumpspeedinmms, &tmp_jumpspeedinmms, sizeof(tmp_jumpspeedinmms));
  if (raw_jumpspeedinmms != 0) {
    _this->_internal_set_jumpspeedinmms(from._internal_jumpspeedinmms());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_markspeedinmms = from._internal_markspeedinmms();
  ::uint64_t raw_markspeedinmms;
  memcpy(&raw_markspeedinmms, &tmp_markspeedinmms, sizeof(tmp_markspeedinmms));
  if (raw_markspeedinmms != 0) {
    _this->_internal_set_markspeedinmms(from._internal_markspeedinmms());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_laserfocusshiftinmm = from._internal_laserfocusshiftinmm();
  ::uint64_t raw_laserfocusshiftinmm;
  memcpy(&raw_laserfocusshiftinmm, &tmp_laserfocusshiftinmm, sizeof(tmp_laserfocusshiftinmm));
  if (raw_laserfocusshiftinmm != 0) {
    _this->_internal_set_laserfocusshiftinmm(from._internal_laserfocusshiftinmm());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_maxaccelerationinmmperss = from._internal_maxaccelerationinmmperss();
  ::uint64_t raw_maxaccelerationinmmperss;
  memcpy(&raw_maxaccelerationinmmperss, &tmp_maxaccelerationinmmperss, sizeof(tmp_maxaccelerationinmmperss));
  if (raw_maxaccelerationinmmperss != 0) {
    _this->_internal_set_maxaccelerationinmmperss(from._internal_maxaccelerationinmmperss());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_staticdelayins = from._internal_staticdelayins();
  ::uint64_t raw_staticdelayins;
  memcpy(&raw_staticdelayins, &tmp_staticdelayins, sizeof(tmp_staticdelayins));
  if (raw_staticdelayins != 0) {
    _this->_internal_set_staticdelayins(from._internal_staticdelayins());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_jumpdelayinus = from._internal_jumpdelayinus();
  ::uint64_t raw_jumpdelayinus;
  memcpy(&raw_jumpdelayinus, &tmp_jumpdelayinus, sizeof(tmp_jumpdelayinus));
  if (raw_jumpdelayinus != 0) {
    _this->_internal_set_jumpdelayinus(from._internal_jumpdelayinus());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_markdelayinus = from._internal_markdelayinus();
  ::uint64_t raw_markdelayinus;
  memcpy(&raw_markdelayinus, &tmp_markdelayinus, sizeof(tmp_markdelayinus));
  if (raw_markdelayinus != 0) {
    _this->_internal_set_markdelayinus(from._internal_markdelayinus());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_laseroffdelayinus = from._internal_laseroffdelayinus();
  ::uint64_t raw_laseroffdelayinus;
  memcpy(&raw_laseroffdelayinus, &tmp_laseroffdelayinus, sizeof(tmp_laseroffdelayinus));
  if (raw_laseroffdelayinus != 0) {
    _this->_internal_set_laseroffdelayinus(from._internal_laseroffdelayinus());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_laserondelayinus = from._internal_laserondelayinus();
  ::uint64_t raw_laserondelayinus;
  memcpy(&raw_laserondelayinus, &tmp_laserondelayinus, sizeof(tmp_laserondelayinus));
  if (raw_laserondelayinus != 0) {
    _this->_internal_set_laserondelayinus(from._internal_laserondelayinus());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_polygondelayinus = from._internal_polygondelayinus();
  ::uint64_t raw_polygondelayinus;
  memcpy(&raw_polygondelayinus, &tmp_polygondelayinus, sizeof(tmp_polygondelayinus));
  if (raw_polygondelayinus != 0) {
    _this->_internal_set_polygondelayinus(from._internal_polygondelayinus());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_vectorblockdelay = from._internal_vectorblockdelay();
  ::uint64_t raw_vectorblockdelay;
  memcpy(&raw_vectorblockdelay, &tmp_vectorblockdelay, sizeof(tmp_vectorblockdelay));
  if (raw_vectorblockdelay != 0) {
    _this->_internal_set_vectorblockdelay(from._internal_vectorblockdelay());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_paramchangedelay = from._internal_paramchangedelay();
  ::uint64_t raw_paramchangedelay;
  memcpy(&raw_paramchangedelay, &tmp_paramchangedelay, sizeof(tmp_paramchangedelay));
  if (raw_paramchangedelay != 0) {
    _this->_internal_set_paramchangedelay(from._internal_paramchangedelay());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_warpjumplengthlimit = from._internal_warpjumplengthlimit();
  ::uint64_t raw_warpjumplengthlimit;
  memcpy(&raw_warpjumplengthlimit, &tmp_warpjumplengthlimit, sizeof(tmp_warpjumplengthlimit));
  if (raw_warpjumplengthlimit != 0) {
    _this->_internal_set_warpjumplengthlimit(from._internal_warpjumplengthlimit());
  }
  if (from._internal_jumpmode() != 0) {
    _this->_internal_set_jumpmode(from._internal_jumpmode());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void BasicScannerParams::CopyFrom(const BasicScannerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ManufacturingScenarioRepository.BasicScannerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool BasicScannerParams::IsInitialized() const {
  return true;
}

void BasicScannerParams::InternalSwap(BasicScannerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BasicScannerParams, _impl_.jumpmode_)
      + sizeof(BasicScannerParams::_impl_.jumpmode_)
      - PROTOBUF_FIELD_OFFSET(BasicScannerParams, _impl_.jumpspeedinmms_)>(
          reinterpret_cast<char*>(&_impl_.jumpspeedinmms_),
          reinterpret_cast<char*>(&other->_impl_.jumpspeedinmms_));
}

::google::protobuf::Metadata BasicScannerParams::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ModuleDefinition_2eproto_getter, &descriptor_table_ModuleDefinition_2eproto_once,
      file_level_metadata_ModuleDefinition_2eproto[5]);
}
// ===================================================================

class CommonSkyWritingParams::_Internal {
 public:
};

CommonSkyWritingParams::CommonSkyWritingParams(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ManufacturingScenarioRepository.CommonSkyWritingParams)
}
CommonSkyWritingParams::CommonSkyWritingParams(const CommonSkyWritingParams& from)
    : ::google::protobuf::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ManufacturingScenarioRepository.CommonSkyWritingParams)
}
inline void CommonSkyWritingParams::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.nprevintenusticks_){0},
      decltype(_impl_.npostintenusticks_){0},
      decltype(_impl_.limitangle_){0},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
CommonSkyWritingParams::~CommonSkyWritingParams() {
  // @@protoc_insertion_point(destructor:ManufacturingScenarioRepository.CommonSkyWritingParams)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CommonSkyWritingParams::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}
void CommonSkyWritingParams::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void CommonSkyWritingParams::Clear() {
// @@protoc_insertion_point(message_clear_start:ManufacturingScenarioRepository.CommonSkyWritingParams)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.nprevintenusticks_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.limitangle_) -
      reinterpret_cast<char*>(&_impl_.nprevintenusticks_)) + sizeof(_impl_.limitangle_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CommonSkyWritingParams::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2> CommonSkyWritingParams::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_CommonSkyWritingParams_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // double NPrevInTenUsTicks = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(CommonSkyWritingParams, _impl_.nprevintenusticks_)}},
    // double NPostInTenUsTicks = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(CommonSkyWritingParams, _impl_.npostintenusticks_)}},
    // double limitAngle = 3;
    {::_pbi::TcParser::FastF64S1,
     {25, 63, 0, PROTOBUF_FIELD_OFFSET(CommonSkyWritingParams, _impl_.limitangle_)}},
  }}, {{
    65535, 65535
  }}, {{
    // double NPrevInTenUsTicks = 1;
    {PROTOBUF_FIELD_OFFSET(CommonSkyWritingParams, _impl_.nprevintenusticks_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double NPostInTenUsTicks = 2;
    {PROTOBUF_FIELD_OFFSET(CommonSkyWritingParams, _impl_.npostintenusticks_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double limitAngle = 3;
    {PROTOBUF_FIELD_OFFSET(CommonSkyWritingParams, _impl_.limitangle_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* CommonSkyWritingParams::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ManufacturingScenarioRepository.CommonSkyWritingParams)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double NPrevInTenUsTicks = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_nprevintenusticks = this->_internal_nprevintenusticks();
  ::uint64_t raw_nprevintenusticks;
  memcpy(&raw_nprevintenusticks, &tmp_nprevintenusticks, sizeof(tmp_nprevintenusticks));
  if (raw_nprevintenusticks != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_nprevintenusticks(), target);
  }

  // double NPostInTenUsTicks = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_npostintenusticks = this->_internal_npostintenusticks();
  ::uint64_t raw_npostintenusticks;
  memcpy(&raw_npostintenusticks, &tmp_npostintenusticks, sizeof(tmp_npostintenusticks));
  if (raw_npostintenusticks != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_npostintenusticks(), target);
  }

  // double limitAngle = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_limitangle = this->_internal_limitangle();
  ::uint64_t raw_limitangle;
  memcpy(&raw_limitangle, &tmp_limitangle, sizeof(tmp_limitangle));
  if (raw_limitangle != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_limitangle(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ManufacturingScenarioRepository.CommonSkyWritingParams)
  return target;
}

::size_t CommonSkyWritingParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ManufacturingScenarioRepository.CommonSkyWritingParams)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double NPrevInTenUsTicks = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_nprevintenusticks = this->_internal_nprevintenusticks();
  ::uint64_t raw_nprevintenusticks;
  memcpy(&raw_nprevintenusticks, &tmp_nprevintenusticks, sizeof(tmp_nprevintenusticks));
  if (raw_nprevintenusticks != 0) {
    total_size += 9;
  }

  // double NPostInTenUsTicks = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_npostintenusticks = this->_internal_npostintenusticks();
  ::uint64_t raw_npostintenusticks;
  memcpy(&raw_npostintenusticks, &tmp_npostintenusticks, sizeof(tmp_npostintenusticks));
  if (raw_npostintenusticks != 0) {
    total_size += 9;
  }

  // double limitAngle = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_limitangle = this->_internal_limitangle();
  ::uint64_t raw_limitangle;
  memcpy(&raw_limitangle, &tmp_limitangle, sizeof(tmp_limitangle));
  if (raw_limitangle != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CommonSkyWritingParams::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    CommonSkyWritingParams::MergeImpl
};
const ::google::protobuf::Message::ClassData*CommonSkyWritingParams::GetClassData() const { return &_class_data_; }


void CommonSkyWritingParams::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CommonSkyWritingParams*>(&to_msg);
  auto& from = static_cast<const CommonSkyWritingParams&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ManufacturingScenarioRepository.CommonSkyWritingParams)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_nprevintenusticks = from._internal_nprevintenusticks();
  ::uint64_t raw_nprevintenusticks;
  memcpy(&raw_nprevintenusticks, &tmp_nprevintenusticks, sizeof(tmp_nprevintenusticks));
  if (raw_nprevintenusticks != 0) {
    _this->_internal_set_nprevintenusticks(from._internal_nprevintenusticks());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_npostintenusticks = from._internal_npostintenusticks();
  ::uint64_t raw_npostintenusticks;
  memcpy(&raw_npostintenusticks, &tmp_npostintenusticks, sizeof(tmp_npostintenusticks));
  if (raw_npostintenusticks != 0) {
    _this->_internal_set_npostintenusticks(from._internal_npostintenusticks());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_limitangle = from._internal_limitangle();
  ::uint64_t raw_limitangle;
  memcpy(&raw_limitangle, &tmp_limitangle, sizeof(tmp_limitangle));
  if (raw_limitangle != 0) {
    _this->_internal_set_limitangle(from._internal_limitangle());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CommonSkyWritingParams::CopyFrom(const CommonSkyWritingParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ManufacturingScenarioRepository.CommonSkyWritingParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommonSkyWritingParams::IsInitialized() const {
  return true;
}

void CommonSkyWritingParams::InternalSwap(CommonSkyWritingParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommonSkyWritingParams, _impl_.limitangle_)
      + sizeof(CommonSkyWritingParams::_impl_.limitangle_)
      - PROTOBUF_FIELD_OFFSET(CommonSkyWritingParams, _impl_.nprevintenusticks_)>(
          reinterpret_cast<char*>(&_impl_.nprevintenusticks_),
          reinterpret_cast<char*>(&other->_impl_.nprevintenusticks_));
}

::google::protobuf::Metadata CommonSkyWritingParams::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ModuleDefinition_2eproto_getter, &descriptor_table_ModuleDefinition_2eproto_once,
      file_level_metadata_ModuleDefinition_2eproto[6]);
}
// ===================================================================

class CoordinateTransformParams::_Internal {
 public:
};

CoordinateTransformParams::CoordinateTransformParams(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ManufacturingScenarioRepository.CoordinateTransformParams)
}
CoordinateTransformParams::CoordinateTransformParams(const CoordinateTransformParams& from)
    : ::google::protobuf::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ManufacturingScenarioRepository.CoordinateTransformParams)
}
inline void CoordinateTransformParams::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.minimaljumplength_){0},
      decltype(_impl_.minimalmarklength_){0},
      decltype(_impl_.deletezerolengthjumps_){false},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
CoordinateTransformParams::~CoordinateTransformParams() {
  // @@protoc_insertion_point(destructor:ManufacturingScenarioRepository.CoordinateTransformParams)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CoordinateTransformParams::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}
void CoordinateTransformParams::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void CoordinateTransformParams::Clear() {
// @@protoc_insertion_point(message_clear_start:ManufacturingScenarioRepository.CoordinateTransformParams)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.minimaljumplength_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.deletezerolengthjumps_) -
      reinterpret_cast<char*>(&_impl_.minimaljumplength_)) + sizeof(_impl_.deletezerolengthjumps_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CoordinateTransformParams::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2> CoordinateTransformParams::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_CoordinateTransformParams_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // bool DeleteZeroLengthJumps = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(CoordinateTransformParams, _impl_.deletezerolengthjumps_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(CoordinateTransformParams, _impl_.deletezerolengthjumps_)}},
    // double MinimalJumpLength = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(CoordinateTransformParams, _impl_.minimaljumplength_)}},
    // double MinimalMarkLength = 3;
    {::_pbi::TcParser::FastF64S1,
     {25, 63, 0, PROTOBUF_FIELD_OFFSET(CoordinateTransformParams, _impl_.minimalmarklength_)}},
  }}, {{
    65535, 65535
  }}, {{
    // bool DeleteZeroLengthJumps = 1;
    {PROTOBUF_FIELD_OFFSET(CoordinateTransformParams, _impl_.deletezerolengthjumps_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // double MinimalJumpLength = 2;
    {PROTOBUF_FIELD_OFFSET(CoordinateTransformParams, _impl_.minimaljumplength_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double MinimalMarkLength = 3;
    {PROTOBUF_FIELD_OFFSET(CoordinateTransformParams, _impl_.minimalmarklength_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* CoordinateTransformParams::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ManufacturingScenarioRepository.CoordinateTransformParams)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // bool DeleteZeroLengthJumps = 1;
  if (this->_internal_deletezerolengthjumps() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_deletezerolengthjumps(), target);
  }

  // double MinimalJumpLength = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_minimaljumplength = this->_internal_minimaljumplength();
  ::uint64_t raw_minimaljumplength;
  memcpy(&raw_minimaljumplength, &tmp_minimaljumplength, sizeof(tmp_minimaljumplength));
  if (raw_minimaljumplength != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_minimaljumplength(), target);
  }

  // double MinimalMarkLength = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_minimalmarklength = this->_internal_minimalmarklength();
  ::uint64_t raw_minimalmarklength;
  memcpy(&raw_minimalmarklength, &tmp_minimalmarklength, sizeof(tmp_minimalmarklength));
  if (raw_minimalmarklength != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_minimalmarklength(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ManufacturingScenarioRepository.CoordinateTransformParams)
  return target;
}

::size_t CoordinateTransformParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ManufacturingScenarioRepository.CoordinateTransformParams)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double MinimalJumpLength = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_minimaljumplength = this->_internal_minimaljumplength();
  ::uint64_t raw_minimaljumplength;
  memcpy(&raw_minimaljumplength, &tmp_minimaljumplength, sizeof(tmp_minimaljumplength));
  if (raw_minimaljumplength != 0) {
    total_size += 9;
  }

  // double MinimalMarkLength = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_minimalmarklength = this->_internal_minimalmarklength();
  ::uint64_t raw_minimalmarklength;
  memcpy(&raw_minimalmarklength, &tmp_minimalmarklength, sizeof(tmp_minimalmarklength));
  if (raw_minimalmarklength != 0) {
    total_size += 9;
  }

  // bool DeleteZeroLengthJumps = 1;
  if (this->_internal_deletezerolengthjumps() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CoordinateTransformParams::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    CoordinateTransformParams::MergeImpl
};
const ::google::protobuf::Message::ClassData*CoordinateTransformParams::GetClassData() const { return &_class_data_; }


void CoordinateTransformParams::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CoordinateTransformParams*>(&to_msg);
  auto& from = static_cast<const CoordinateTransformParams&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ManufacturingScenarioRepository.CoordinateTransformParams)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_minimaljumplength = from._internal_minimaljumplength();
  ::uint64_t raw_minimaljumplength;
  memcpy(&raw_minimaljumplength, &tmp_minimaljumplength, sizeof(tmp_minimaljumplength));
  if (raw_minimaljumplength != 0) {
    _this->_internal_set_minimaljumplength(from._internal_minimaljumplength());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_minimalmarklength = from._internal_minimalmarklength();
  ::uint64_t raw_minimalmarklength;
  memcpy(&raw_minimalmarklength, &tmp_minimalmarklength, sizeof(tmp_minimalmarklength));
  if (raw_minimalmarklength != 0) {
    _this->_internal_set_minimalmarklength(from._internal_minimalmarklength());
  }
  if (from._internal_deletezerolengthjumps() != 0) {
    _this->_internal_set_deletezerolengthjumps(from._internal_deletezerolengthjumps());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CoordinateTransformParams::CopyFrom(const CoordinateTransformParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ManufacturingScenarioRepository.CoordinateTransformParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CoordinateTransformParams::IsInitialized() const {
  return true;
}

void CoordinateTransformParams::InternalSwap(CoordinateTransformParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CoordinateTransformParams, _impl_.deletezerolengthjumps_)
      + sizeof(CoordinateTransformParams::_impl_.deletezerolengthjumps_)
      - PROTOBUF_FIELD_OFFSET(CoordinateTransformParams, _impl_.minimaljumplength_)>(
          reinterpret_cast<char*>(&_impl_.minimaljumplength_),
          reinterpret_cast<char*>(&other->_impl_.minimaljumplength_));
}

::google::protobuf::Metadata CoordinateTransformParams::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ModuleDefinition_2eproto_getter, &descriptor_table_ModuleDefinition_2eproto_once,
      file_level_metadata_ModuleDefinition_2eproto[7]);
}
// ===================================================================

class NovantaScannerParams::_Internal {
 public:
  using HasBits = decltype(std::declval<NovantaScannerParams>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(NovantaScannerParams, _impl_._has_bits_);
  static const ::ManufacturingScenarioRepository::BasicScannerParams& basicscannerparams(const NovantaScannerParams* msg);
  static void set_has_basicscannerparams(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::ManufacturingScenarioRepository::CommonSkyWritingParams& skywritingparams(const NovantaScannerParams* msg);
  static void set_has_skywritingparams(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::ManufacturingScenarioRepository::CoordinateTransformParams& coordtransformparams(const NovantaScannerParams* msg);
  static void set_has_coordtransformparams(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::ManufacturingScenarioRepository::BasicScannerParams& NovantaScannerParams::_Internal::basicscannerparams(const NovantaScannerParams* msg) {
  return *msg->_impl_.basicscannerparams_;
}
const ::ManufacturingScenarioRepository::CommonSkyWritingParams& NovantaScannerParams::_Internal::skywritingparams(const NovantaScannerParams* msg) {
  return *msg->_impl_.skywritingparams_;
}
const ::ManufacturingScenarioRepository::CoordinateTransformParams& NovantaScannerParams::_Internal::coordtransformparams(const NovantaScannerParams* msg) {
  return *msg->_impl_.coordtransformparams_;
}
NovantaScannerParams::NovantaScannerParams(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ManufacturingScenarioRepository.NovantaScannerParams)
}
NovantaScannerParams::NovantaScannerParams(const NovantaScannerParams& from) : ::google::protobuf::Message() {
  NovantaScannerParams* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.basicscannerparams_){nullptr},
      decltype(_impl_.skywritingparams_){nullptr},
      decltype(_impl_.coordtransformparams_){nullptr},
      decltype(_impl_.skywritingmode_){},
      decltype(_impl_.delaymode_){},
      decltype(_impl_.radialerrorinum_){},
      decltype(_impl_.safetyfactorflybylow_){},
      decltype(_impl_.safetyfactorflybyhigh_){},
      decltype(_impl_.safetyfactorradialerrorlimit_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.basicscannerparams_ = new ::ManufacturingScenarioRepository::BasicScannerParams(*from._impl_.basicscannerparams_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.skywritingparams_ = new ::ManufacturingScenarioRepository::CommonSkyWritingParams(*from._impl_.skywritingparams_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.coordtransformparams_ = new ::ManufacturingScenarioRepository::CoordinateTransformParams(*from._impl_.coordtransformparams_);
  }
  ::memcpy(&_impl_.skywritingmode_, &from._impl_.skywritingmode_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.safetyfactorradialerrorlimit_) -
    reinterpret_cast<char*>(&_impl_.skywritingmode_)) + sizeof(_impl_.safetyfactorradialerrorlimit_));

  // @@protoc_insertion_point(copy_constructor:ManufacturingScenarioRepository.NovantaScannerParams)
}
inline void NovantaScannerParams::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.basicscannerparams_){nullptr},
      decltype(_impl_.skywritingparams_){nullptr},
      decltype(_impl_.coordtransformparams_){nullptr},
      decltype(_impl_.skywritingmode_){0},
      decltype(_impl_.delaymode_){0},
      decltype(_impl_.radialerrorinum_){0},
      decltype(_impl_.safetyfactorflybylow_){0},
      decltype(_impl_.safetyfactorflybyhigh_){0},
      decltype(_impl_.safetyfactorradialerrorlimit_){0},
  };
}
NovantaScannerParams::~NovantaScannerParams() {
  // @@protoc_insertion_point(destructor:ManufacturingScenarioRepository.NovantaScannerParams)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void NovantaScannerParams::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.basicscannerparams_;
  if (this != internal_default_instance()) delete _impl_.skywritingparams_;
  if (this != internal_default_instance()) delete _impl_.coordtransformparams_;
}
void NovantaScannerParams::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void NovantaScannerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:ManufacturingScenarioRepository.NovantaScannerParams)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.basicscannerparams_ != nullptr);
      _impl_.basicscannerparams_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.skywritingparams_ != nullptr);
      _impl_.skywritingparams_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.coordtransformparams_ != nullptr);
      _impl_.coordtransformparams_->Clear();
    }
  }
  ::memset(&_impl_.skywritingmode_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.safetyfactorradialerrorlimit_) -
      reinterpret_cast<char*>(&_impl_.skywritingmode_)) + sizeof(_impl_.safetyfactorradialerrorlimit_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* NovantaScannerParams::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 9, 3, 0, 2> NovantaScannerParams::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(NovantaScannerParams, _impl_._has_bits_),
    0, // no _extensions_
    9, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966784,  // skipmap
    offsetof(decltype(_table_), field_entries),
    9,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_NovantaScannerParams_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .ManufacturingScenarioRepository.BasicScannerParams basicScannerParams = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(NovantaScannerParams, _impl_.basicscannerparams_)}},
    // .ManufacturingScenarioRepository.CommonSkyWritingParams skyWritingParams = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(NovantaScannerParams, _impl_.skywritingparams_)}},
    // .ManufacturingScenarioRepository.CoordinateTransformParams coordTransformParams = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(NovantaScannerParams, _impl_.coordtransformparams_)}},
    // .ManufacturingScenarioRepository.NovantaScannerParams.SkyWritingMode skyWritingMode = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(NovantaScannerParams, _impl_.skywritingmode_), 63>(),
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(NovantaScannerParams, _impl_.skywritingmode_)}},
    // .ManufacturingScenarioRepository.NovantaScannerParams.DelayMode delayMode = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(NovantaScannerParams, _impl_.delaymode_), 63>(),
     {40, 63, 0, PROTOBUF_FIELD_OFFSET(NovantaScannerParams, _impl_.delaymode_)}},
    // double radialErrorInUm = 6;
    {::_pbi::TcParser::FastF64S1,
     {49, 63, 0, PROTOBUF_FIELD_OFFSET(NovantaScannerParams, _impl_.radialerrorinum_)}},
    // double SafetyFactorFlyByLow = 7;
    {::_pbi::TcParser::FastF64S1,
     {57, 63, 0, PROTOBUF_FIELD_OFFSET(NovantaScannerParams, _impl_.safetyfactorflybylow_)}},
    // double SafetyFactorFlyByHigh = 8;
    {::_pbi::TcParser::FastF64S1,
     {65, 63, 0, PROTOBUF_FIELD_OFFSET(NovantaScannerParams, _impl_.safetyfactorflybyhigh_)}},
    // double SafetyFactorRadialErrorLimit = 9;
    {::_pbi::TcParser::FastF64S1,
     {73, 63, 0, PROTOBUF_FIELD_OFFSET(NovantaScannerParams, _impl_.safetyfactorradialerrorlimit_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // .ManufacturingScenarioRepository.BasicScannerParams basicScannerParams = 1;
    {PROTOBUF_FIELD_OFFSET(NovantaScannerParams, _impl_.basicscannerparams_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .ManufacturingScenarioRepository.CommonSkyWritingParams skyWritingParams = 2;
    {PROTOBUF_FIELD_OFFSET(NovantaScannerParams, _impl_.skywritingparams_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .ManufacturingScenarioRepository.CoordinateTransformParams coordTransformParams = 3;
    {PROTOBUF_FIELD_OFFSET(NovantaScannerParams, _impl_.coordtransformparams_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .ManufacturingScenarioRepository.NovantaScannerParams.SkyWritingMode skyWritingMode = 4;
    {PROTOBUF_FIELD_OFFSET(NovantaScannerParams, _impl_.skywritingmode_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .ManufacturingScenarioRepository.NovantaScannerParams.DelayMode delayMode = 5;
    {PROTOBUF_FIELD_OFFSET(NovantaScannerParams, _impl_.delaymode_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // double radialErrorInUm = 6;
    {PROTOBUF_FIELD_OFFSET(NovantaScannerParams, _impl_.radialerrorinum_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double SafetyFactorFlyByLow = 7;
    {PROTOBUF_FIELD_OFFSET(NovantaScannerParams, _impl_.safetyfactorflybylow_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double SafetyFactorFlyByHigh = 8;
    {PROTOBUF_FIELD_OFFSET(NovantaScannerParams, _impl_.safetyfactorflybyhigh_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double SafetyFactorRadialErrorLimit = 9;
    {PROTOBUF_FIELD_OFFSET(NovantaScannerParams, _impl_.safetyfactorradialerrorlimit_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
  }}, {{
    {::_pbi::TcParser::GetTable<::ManufacturingScenarioRepository::BasicScannerParams>()},
    {::_pbi::TcParser::GetTable<::ManufacturingScenarioRepository::CommonSkyWritingParams>()},
    {::_pbi::TcParser::GetTable<::ManufacturingScenarioRepository::CoordinateTransformParams>()},
  }}, {{
  }},
};

::uint8_t* NovantaScannerParams::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ManufacturingScenarioRepository.NovantaScannerParams)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .ManufacturingScenarioRepository.BasicScannerParams basicScannerParams = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::basicscannerparams(this),
        _Internal::basicscannerparams(this).GetCachedSize(), target, stream);
  }

  // .ManufacturingScenarioRepository.CommonSkyWritingParams skyWritingParams = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::skywritingparams(this),
        _Internal::skywritingparams(this).GetCachedSize(), target, stream);
  }

  // .ManufacturingScenarioRepository.CoordinateTransformParams coordTransformParams = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::coordtransformparams(this),
        _Internal::coordtransformparams(this).GetCachedSize(), target, stream);
  }

  // .ManufacturingScenarioRepository.NovantaScannerParams.SkyWritingMode skyWritingMode = 4;
  if (this->_internal_skywritingmode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_skywritingmode(), target);
  }

  // .ManufacturingScenarioRepository.NovantaScannerParams.DelayMode delayMode = 5;
  if (this->_internal_delaymode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        5, this->_internal_delaymode(), target);
  }

  // double radialErrorInUm = 6;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_radialerrorinum = this->_internal_radialerrorinum();
  ::uint64_t raw_radialerrorinum;
  memcpy(&raw_radialerrorinum, &tmp_radialerrorinum, sizeof(tmp_radialerrorinum));
  if (raw_radialerrorinum != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        6, this->_internal_radialerrorinum(), target);
  }

  // double SafetyFactorFlyByLow = 7;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_safetyfactorflybylow = this->_internal_safetyfactorflybylow();
  ::uint64_t raw_safetyfactorflybylow;
  memcpy(&raw_safetyfactorflybylow, &tmp_safetyfactorflybylow, sizeof(tmp_safetyfactorflybylow));
  if (raw_safetyfactorflybylow != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        7, this->_internal_safetyfactorflybylow(), target);
  }

  // double SafetyFactorFlyByHigh = 8;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_safetyfactorflybyhigh = this->_internal_safetyfactorflybyhigh();
  ::uint64_t raw_safetyfactorflybyhigh;
  memcpy(&raw_safetyfactorflybyhigh, &tmp_safetyfactorflybyhigh, sizeof(tmp_safetyfactorflybyhigh));
  if (raw_safetyfactorflybyhigh != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        8, this->_internal_safetyfactorflybyhigh(), target);
  }

  // double SafetyFactorRadialErrorLimit = 9;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_safetyfactorradialerrorlimit = this->_internal_safetyfactorradialerrorlimit();
  ::uint64_t raw_safetyfactorradialerrorlimit;
  memcpy(&raw_safetyfactorradialerrorlimit, &tmp_safetyfactorradialerrorlimit, sizeof(tmp_safetyfactorradialerrorlimit));
  if (raw_safetyfactorradialerrorlimit != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        9, this->_internal_safetyfactorradialerrorlimit(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ManufacturingScenarioRepository.NovantaScannerParams)
  return target;
}

::size_t NovantaScannerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ManufacturingScenarioRepository.NovantaScannerParams)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // .ManufacturingScenarioRepository.BasicScannerParams basicScannerParams = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.basicscannerparams_);
    }

    // .ManufacturingScenarioRepository.CommonSkyWritingParams skyWritingParams = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.skywritingparams_);
    }

    // .ManufacturingScenarioRepository.CoordinateTransformParams coordTransformParams = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.coordtransformparams_);
    }

  }
  // .ManufacturingScenarioRepository.NovantaScannerParams.SkyWritingMode skyWritingMode = 4;
  if (this->_internal_skywritingmode() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_skywritingmode());
  }

  // .ManufacturingScenarioRepository.NovantaScannerParams.DelayMode delayMode = 5;
  if (this->_internal_delaymode() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_delaymode());
  }

  // double radialErrorInUm = 6;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_radialerrorinum = this->_internal_radialerrorinum();
  ::uint64_t raw_radialerrorinum;
  memcpy(&raw_radialerrorinum, &tmp_radialerrorinum, sizeof(tmp_radialerrorinum));
  if (raw_radialerrorinum != 0) {
    total_size += 9;
  }

  // double SafetyFactorFlyByLow = 7;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_safetyfactorflybylow = this->_internal_safetyfactorflybylow();
  ::uint64_t raw_safetyfactorflybylow;
  memcpy(&raw_safetyfactorflybylow, &tmp_safetyfactorflybylow, sizeof(tmp_safetyfactorflybylow));
  if (raw_safetyfactorflybylow != 0) {
    total_size += 9;
  }

  // double SafetyFactorFlyByHigh = 8;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_safetyfactorflybyhigh = this->_internal_safetyfactorflybyhigh();
  ::uint64_t raw_safetyfactorflybyhigh;
  memcpy(&raw_safetyfactorflybyhigh, &tmp_safetyfactorflybyhigh, sizeof(tmp_safetyfactorflybyhigh));
  if (raw_safetyfactorflybyhigh != 0) {
    total_size += 9;
  }

  // double SafetyFactorRadialErrorLimit = 9;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_safetyfactorradialerrorlimit = this->_internal_safetyfactorradialerrorlimit();
  ::uint64_t raw_safetyfactorradialerrorlimit;
  memcpy(&raw_safetyfactorradialerrorlimit, &tmp_safetyfactorradialerrorlimit, sizeof(tmp_safetyfactorradialerrorlimit));
  if (raw_safetyfactorradialerrorlimit != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData NovantaScannerParams::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    NovantaScannerParams::MergeImpl
};
const ::google::protobuf::Message::ClassData*NovantaScannerParams::GetClassData() const { return &_class_data_; }


void NovantaScannerParams::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<NovantaScannerParams*>(&to_msg);
  auto& from = static_cast<const NovantaScannerParams&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ManufacturingScenarioRepository.NovantaScannerParams)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_basicscannerparams()->::ManufacturingScenarioRepository::BasicScannerParams::MergeFrom(
          from._internal_basicscannerparams());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_skywritingparams()->::ManufacturingScenarioRepository::CommonSkyWritingParams::MergeFrom(
          from._internal_skywritingparams());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_coordtransformparams()->::ManufacturingScenarioRepository::CoordinateTransformParams::MergeFrom(
          from._internal_coordtransformparams());
    }
  }
  if (from._internal_skywritingmode() != 0) {
    _this->_internal_set_skywritingmode(from._internal_skywritingmode());
  }
  if (from._internal_delaymode() != 0) {
    _this->_internal_set_delaymode(from._internal_delaymode());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_radialerrorinum = from._internal_radialerrorinum();
  ::uint64_t raw_radialerrorinum;
  memcpy(&raw_radialerrorinum, &tmp_radialerrorinum, sizeof(tmp_radialerrorinum));
  if (raw_radialerrorinum != 0) {
    _this->_internal_set_radialerrorinum(from._internal_radialerrorinum());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_safetyfactorflybylow = from._internal_safetyfactorflybylow();
  ::uint64_t raw_safetyfactorflybylow;
  memcpy(&raw_safetyfactorflybylow, &tmp_safetyfactorflybylow, sizeof(tmp_safetyfactorflybylow));
  if (raw_safetyfactorflybylow != 0) {
    _this->_internal_set_safetyfactorflybylow(from._internal_safetyfactorflybylow());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_safetyfactorflybyhigh = from._internal_safetyfactorflybyhigh();
  ::uint64_t raw_safetyfactorflybyhigh;
  memcpy(&raw_safetyfactorflybyhigh, &tmp_safetyfactorflybyhigh, sizeof(tmp_safetyfactorflybyhigh));
  if (raw_safetyfactorflybyhigh != 0) {
    _this->_internal_set_safetyfactorflybyhigh(from._internal_safetyfactorflybyhigh());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_safetyfactorradialerrorlimit = from._internal_safetyfactorradialerrorlimit();
  ::uint64_t raw_safetyfactorradialerrorlimit;
  memcpy(&raw_safetyfactorradialerrorlimit, &tmp_safetyfactorradialerrorlimit, sizeof(tmp_safetyfactorradialerrorlimit));
  if (raw_safetyfactorradialerrorlimit != 0) {
    _this->_internal_set_safetyfactorradialerrorlimit(from._internal_safetyfactorradialerrorlimit());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void NovantaScannerParams::CopyFrom(const NovantaScannerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ManufacturingScenarioRepository.NovantaScannerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool NovantaScannerParams::IsInitialized() const {
  return true;
}

void NovantaScannerParams::InternalSwap(NovantaScannerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NovantaScannerParams, _impl_.safetyfactorradialerrorlimit_)
      + sizeof(NovantaScannerParams::_impl_.safetyfactorradialerrorlimit_)
      - PROTOBUF_FIELD_OFFSET(NovantaScannerParams, _impl_.basicscannerparams_)>(
          reinterpret_cast<char*>(&_impl_.basicscannerparams_),
          reinterpret_cast<char*>(&other->_impl_.basicscannerparams_));
}

::google::protobuf::Metadata NovantaScannerParams::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ModuleDefinition_2eproto_getter, &descriptor_table_ModuleDefinition_2eproto_once,
      file_level_metadata_ModuleDefinition_2eproto[8]);
}
// ===================================================================

class ScanlabScannerParams::_Internal {
 public:
  using HasBits = decltype(std::declval<ScanlabScannerParams>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ScanlabScannerParams, _impl_._has_bits_);
  static const ::ManufacturingScenarioRepository::BasicScannerParams& basicscannerparams(const ScanlabScannerParams* msg);
  static void set_has_basicscannerparams(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::ManufacturingScenarioRepository::CommonSkyWritingParams& skywritingparams(const ScanlabScannerParams* msg);
  static void set_has_skywritingparams(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::ManufacturingScenarioRepository::CoordinateTransformParams& coordtransformparams(const ScanlabScannerParams* msg);
  static void set_has_coordtransformparams(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::ManufacturingScenarioRepository::BasicScannerParams& ScanlabScannerParams::_Internal::basicscannerparams(const ScanlabScannerParams* msg) {
  return *msg->_impl_.basicscannerparams_;
}
const ::ManufacturingScenarioRepository::CommonSkyWritingParams& ScanlabScannerParams::_Internal::skywritingparams(const ScanlabScannerParams* msg) {
  return *msg->_impl_.skywritingparams_;
}
const ::ManufacturingScenarioRepository::CoordinateTransformParams& ScanlabScannerParams::_Internal::coordtransformparams(const ScanlabScannerParams* msg) {
  return *msg->_impl_.coordtransformparams_;
}
ScanlabScannerParams::ScanlabScannerParams(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ManufacturingScenarioRepository.ScanlabScannerParams)
}
ScanlabScannerParams::ScanlabScannerParams(const ScanlabScannerParams& from) : ::google::protobuf::Message() {
  ScanlabScannerParams* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.basicscannerparams_){nullptr},
      decltype(_impl_.skywritingparams_){nullptr},
      decltype(_impl_.coordtransformparams_){nullptr},
      decltype(_impl_.timelaginus_){},
      decltype(_impl_.skywritingmode_){},
      decltype(_impl_.skywritingparametringmode_){},
      decltype(_impl_.delaymode_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.basicscannerparams_ = new ::ManufacturingScenarioRepository::BasicScannerParams(*from._impl_.basicscannerparams_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.skywritingparams_ = new ::ManufacturingScenarioRepository::CommonSkyWritingParams(*from._impl_.skywritingparams_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.coordtransformparams_ = new ::ManufacturingScenarioRepository::CoordinateTransformParams(*from._impl_.coordtransformparams_);
  }
  ::memcpy(&_impl_.timelaginus_, &from._impl_.timelaginus_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.delaymode_) -
    reinterpret_cast<char*>(&_impl_.timelaginus_)) + sizeof(_impl_.delaymode_));

  // @@protoc_insertion_point(copy_constructor:ManufacturingScenarioRepository.ScanlabScannerParams)
}
inline void ScanlabScannerParams::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.basicscannerparams_){nullptr},
      decltype(_impl_.skywritingparams_){nullptr},
      decltype(_impl_.coordtransformparams_){nullptr},
      decltype(_impl_.timelaginus_){0},
      decltype(_impl_.skywritingmode_){0},
      decltype(_impl_.skywritingparametringmode_){0},
      decltype(_impl_.delaymode_){0},
  };
}
ScanlabScannerParams::~ScanlabScannerParams() {
  // @@protoc_insertion_point(destructor:ManufacturingScenarioRepository.ScanlabScannerParams)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void ScanlabScannerParams::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.basicscannerparams_;
  if (this != internal_default_instance()) delete _impl_.skywritingparams_;
  if (this != internal_default_instance()) delete _impl_.coordtransformparams_;
}
void ScanlabScannerParams::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void ScanlabScannerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:ManufacturingScenarioRepository.ScanlabScannerParams)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.basicscannerparams_ != nullptr);
      _impl_.basicscannerparams_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.skywritingparams_ != nullptr);
      _impl_.skywritingparams_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.coordtransformparams_ != nullptr);
      _impl_.coordtransformparams_->Clear();
    }
  }
  ::memset(&_impl_.timelaginus_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.delaymode_) -
      reinterpret_cast<char*>(&_impl_.timelaginus_)) + sizeof(_impl_.delaymode_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* ScanlabScannerParams::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 3, 0, 2> ScanlabScannerParams::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ScanlabScannerParams, _impl_._has_bits_),
    0, // no _extensions_
    7, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_ScanlabScannerParams_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .ManufacturingScenarioRepository.BasicScannerParams basicScannerParams = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(ScanlabScannerParams, _impl_.basicscannerparams_)}},
    // .ManufacturingScenarioRepository.CommonSkyWritingParams skyWritingParams = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(ScanlabScannerParams, _impl_.skywritingparams_)}},
    // .ManufacturingScenarioRepository.CoordinateTransformParams coordTransformParams = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(ScanlabScannerParams, _impl_.coordtransformparams_)}},
    // .ManufacturingScenarioRepository.ScanlabScannerParams.SkyWritingMode skyWritingMode = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ScanlabScannerParams, _impl_.skywritingmode_), 63>(),
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(ScanlabScannerParams, _impl_.skywritingmode_)}},
    // double timeLagInUs = 5;
    {::_pbi::TcParser::FastF64S1,
     {41, 63, 0, PROTOBUF_FIELD_OFFSET(ScanlabScannerParams, _impl_.timelaginus_)}},
    // .ManufacturingScenarioRepository.ScanlabScannerParams.SkyWritingParametringMode skyWritingParametringMode = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ScanlabScannerParams, _impl_.skywritingparametringmode_), 63>(),
     {48, 63, 0, PROTOBUF_FIELD_OFFSET(ScanlabScannerParams, _impl_.skywritingparametringmode_)}},
    // .ManufacturingScenarioRepository.ScanlabScannerParams.DelayMode delayMode = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ScanlabScannerParams, _impl_.delaymode_), 63>(),
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(ScanlabScannerParams, _impl_.delaymode_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .ManufacturingScenarioRepository.BasicScannerParams basicScannerParams = 1;
    {PROTOBUF_FIELD_OFFSET(ScanlabScannerParams, _impl_.basicscannerparams_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .ManufacturingScenarioRepository.CommonSkyWritingParams skyWritingParams = 2;
    {PROTOBUF_FIELD_OFFSET(ScanlabScannerParams, _impl_.skywritingparams_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .ManufacturingScenarioRepository.CoordinateTransformParams coordTransformParams = 3;
    {PROTOBUF_FIELD_OFFSET(ScanlabScannerParams, _impl_.coordtransformparams_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .ManufacturingScenarioRepository.ScanlabScannerParams.SkyWritingMode skyWritingMode = 4;
    {PROTOBUF_FIELD_OFFSET(ScanlabScannerParams, _impl_.skywritingmode_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // double timeLagInUs = 5;
    {PROTOBUF_FIELD_OFFSET(ScanlabScannerParams, _impl_.timelaginus_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // .ManufacturingScenarioRepository.ScanlabScannerParams.SkyWritingParametringMode skyWritingParametringMode = 6;
    {PROTOBUF_FIELD_OFFSET(ScanlabScannerParams, _impl_.skywritingparametringmode_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .ManufacturingScenarioRepository.ScanlabScannerParams.DelayMode delayMode = 7;
    {PROTOBUF_FIELD_OFFSET(ScanlabScannerParams, _impl_.delaymode_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
  }}, {{
    {::_pbi::TcParser::GetTable<::ManufacturingScenarioRepository::BasicScannerParams>()},
    {::_pbi::TcParser::GetTable<::ManufacturingScenarioRepository::CommonSkyWritingParams>()},
    {::_pbi::TcParser::GetTable<::ManufacturingScenarioRepository::CoordinateTransformParams>()},
  }}, {{
  }},
};

::uint8_t* ScanlabScannerParams::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ManufacturingScenarioRepository.ScanlabScannerParams)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .ManufacturingScenarioRepository.BasicScannerParams basicScannerParams = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::basicscannerparams(this),
        _Internal::basicscannerparams(this).GetCachedSize(), target, stream);
  }

  // .ManufacturingScenarioRepository.CommonSkyWritingParams skyWritingParams = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::skywritingparams(this),
        _Internal::skywritingparams(this).GetCachedSize(), target, stream);
  }

  // .ManufacturingScenarioRepository.CoordinateTransformParams coordTransformParams = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::coordtransformparams(this),
        _Internal::coordtransformparams(this).GetCachedSize(), target, stream);
  }

  // .ManufacturingScenarioRepository.ScanlabScannerParams.SkyWritingMode skyWritingMode = 4;
  if (this->_internal_skywritingmode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_skywritingmode(), target);
  }

  // double timeLagInUs = 5;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_timelaginus = this->_internal_timelaginus();
  ::uint64_t raw_timelaginus;
  memcpy(&raw_timelaginus, &tmp_timelaginus, sizeof(tmp_timelaginus));
  if (raw_timelaginus != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        5, this->_internal_timelaginus(), target);
  }

  // .ManufacturingScenarioRepository.ScanlabScannerParams.SkyWritingParametringMode skyWritingParametringMode = 6;
  if (this->_internal_skywritingparametringmode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        6, this->_internal_skywritingparametringmode(), target);
  }

  // .ManufacturingScenarioRepository.ScanlabScannerParams.DelayMode delayMode = 7;
  if (this->_internal_delaymode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        7, this->_internal_delaymode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ManufacturingScenarioRepository.ScanlabScannerParams)
  return target;
}

::size_t ScanlabScannerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ManufacturingScenarioRepository.ScanlabScannerParams)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // .ManufacturingScenarioRepository.BasicScannerParams basicScannerParams = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.basicscannerparams_);
    }

    // .ManufacturingScenarioRepository.CommonSkyWritingParams skyWritingParams = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.skywritingparams_);
    }

    // .ManufacturingScenarioRepository.CoordinateTransformParams coordTransformParams = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.coordtransformparams_);
    }

  }
  // double timeLagInUs = 5;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_timelaginus = this->_internal_timelaginus();
  ::uint64_t raw_timelaginus;
  memcpy(&raw_timelaginus, &tmp_timelaginus, sizeof(tmp_timelaginus));
  if (raw_timelaginus != 0) {
    total_size += 9;
  }

  // .ManufacturingScenarioRepository.ScanlabScannerParams.SkyWritingMode skyWritingMode = 4;
  if (this->_internal_skywritingmode() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_skywritingmode());
  }

  // .ManufacturingScenarioRepository.ScanlabScannerParams.SkyWritingParametringMode skyWritingParametringMode = 6;
  if (this->_internal_skywritingparametringmode() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_skywritingparametringmode());
  }

  // .ManufacturingScenarioRepository.ScanlabScannerParams.DelayMode delayMode = 7;
  if (this->_internal_delaymode() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_delaymode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData ScanlabScannerParams::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    ScanlabScannerParams::MergeImpl
};
const ::google::protobuf::Message::ClassData*ScanlabScannerParams::GetClassData() const { return &_class_data_; }


void ScanlabScannerParams::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<ScanlabScannerParams*>(&to_msg);
  auto& from = static_cast<const ScanlabScannerParams&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ManufacturingScenarioRepository.ScanlabScannerParams)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_basicscannerparams()->::ManufacturingScenarioRepository::BasicScannerParams::MergeFrom(
          from._internal_basicscannerparams());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_skywritingparams()->::ManufacturingScenarioRepository::CommonSkyWritingParams::MergeFrom(
          from._internal_skywritingparams());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_coordtransformparams()->::ManufacturingScenarioRepository::CoordinateTransformParams::MergeFrom(
          from._internal_coordtransformparams());
    }
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_timelaginus = from._internal_timelaginus();
  ::uint64_t raw_timelaginus;
  memcpy(&raw_timelaginus, &tmp_timelaginus, sizeof(tmp_timelaginus));
  if (raw_timelaginus != 0) {
    _this->_internal_set_timelaginus(from._internal_timelaginus());
  }
  if (from._internal_skywritingmode() != 0) {
    _this->_internal_set_skywritingmode(from._internal_skywritingmode());
  }
  if (from._internal_skywritingparametringmode() != 0) {
    _this->_internal_set_skywritingparametringmode(from._internal_skywritingparametringmode());
  }
  if (from._internal_delaymode() != 0) {
    _this->_internal_set_delaymode(from._internal_delaymode());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ScanlabScannerParams::CopyFrom(const ScanlabScannerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ManufacturingScenarioRepository.ScanlabScannerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool ScanlabScannerParams::IsInitialized() const {
  return true;
}

void ScanlabScannerParams::InternalSwap(ScanlabScannerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ScanlabScannerParams, _impl_.delaymode_)
      + sizeof(ScanlabScannerParams::_impl_.delaymode_)
      - PROTOBUF_FIELD_OFFSET(ScanlabScannerParams, _impl_.basicscannerparams_)>(
          reinterpret_cast<char*>(&_impl_.basicscannerparams_),
          reinterpret_cast<char*>(&other->_impl_.basicscannerparams_));
}

::google::protobuf::Metadata ScanlabScannerParams::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ModuleDefinition_2eproto_getter, &descriptor_table_ModuleDefinition_2eproto_once,
      file_level_metadata_ModuleDefinition_2eproto[9]);
}
// ===================================================================

class ScanField::_Internal {
 public:
};

ScanField::ScanField(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ManufacturingScenarioRepository.ScanField)
}
ScanField::ScanField(const ScanField& from)
    : ::google::protobuf::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ManufacturingScenarioRepository.ScanField)
}
inline void ScanField::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.xmin_){0},
      decltype(_impl_.xmax_){0},
      decltype(_impl_.ymin_){0},
      decltype(_impl_.ymax_){0},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
ScanField::~ScanField() {
  // @@protoc_insertion_point(destructor:ManufacturingScenarioRepository.ScanField)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void ScanField::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}
void ScanField::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void ScanField::Clear() {
// @@protoc_insertion_point(message_clear_start:ManufacturingScenarioRepository.ScanField)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.xmin_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.ymax_) -
      reinterpret_cast<char*>(&_impl_.xmin_)) + sizeof(_impl_.ymax_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* ScanField::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2> ScanField::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_ScanField_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // double YMax = 4;
    {::_pbi::TcParser::FastF64S1,
     {33, 63, 0, PROTOBUF_FIELD_OFFSET(ScanField, _impl_.ymax_)}},
    // double XMin = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(ScanField, _impl_.xmin_)}},
    // double XMax = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(ScanField, _impl_.xmax_)}},
    // double YMin = 3;
    {::_pbi::TcParser::FastF64S1,
     {25, 63, 0, PROTOBUF_FIELD_OFFSET(ScanField, _impl_.ymin_)}},
  }}, {{
    65535, 65535
  }}, {{
    // double XMin = 1;
    {PROTOBUF_FIELD_OFFSET(ScanField, _impl_.xmin_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double XMax = 2;
    {PROTOBUF_FIELD_OFFSET(ScanField, _impl_.xmax_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double YMin = 3;
    {PROTOBUF_FIELD_OFFSET(ScanField, _impl_.ymin_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double YMax = 4;
    {PROTOBUF_FIELD_OFFSET(ScanField, _impl_.ymax_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* ScanField::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ManufacturingScenarioRepository.ScanField)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double XMin = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_xmin = this->_internal_xmin();
  ::uint64_t raw_xmin;
  memcpy(&raw_xmin, &tmp_xmin, sizeof(tmp_xmin));
  if (raw_xmin != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_xmin(), target);
  }

  // double XMax = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_xmax = this->_internal_xmax();
  ::uint64_t raw_xmax;
  memcpy(&raw_xmax, &tmp_xmax, sizeof(tmp_xmax));
  if (raw_xmax != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_xmax(), target);
  }

  // double YMin = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_ymin = this->_internal_ymin();
  ::uint64_t raw_ymin;
  memcpy(&raw_ymin, &tmp_ymin, sizeof(tmp_ymin));
  if (raw_ymin != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_ymin(), target);
  }

  // double YMax = 4;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_ymax = this->_internal_ymax();
  ::uint64_t raw_ymax;
  memcpy(&raw_ymax, &tmp_ymax, sizeof(tmp_ymax));
  if (raw_ymax != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        4, this->_internal_ymax(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ManufacturingScenarioRepository.ScanField)
  return target;
}

::size_t ScanField::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ManufacturingScenarioRepository.ScanField)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double XMin = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_xmin = this->_internal_xmin();
  ::uint64_t raw_xmin;
  memcpy(&raw_xmin, &tmp_xmin, sizeof(tmp_xmin));
  if (raw_xmin != 0) {
    total_size += 9;
  }

  // double XMax = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_xmax = this->_internal_xmax();
  ::uint64_t raw_xmax;
  memcpy(&raw_xmax, &tmp_xmax, sizeof(tmp_xmax));
  if (raw_xmax != 0) {
    total_size += 9;
  }

  // double YMin = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_ymin = this->_internal_ymin();
  ::uint64_t raw_ymin;
  memcpy(&raw_ymin, &tmp_ymin, sizeof(tmp_ymin));
  if (raw_ymin != 0) {
    total_size += 9;
  }

  // double YMax = 4;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_ymax = this->_internal_ymax();
  ::uint64_t raw_ymax;
  memcpy(&raw_ymax, &tmp_ymax, sizeof(tmp_ymax));
  if (raw_ymax != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData ScanField::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    ScanField::MergeImpl
};
const ::google::protobuf::Message::ClassData*ScanField::GetClassData() const { return &_class_data_; }


void ScanField::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<ScanField*>(&to_msg);
  auto& from = static_cast<const ScanField&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ManufacturingScenarioRepository.ScanField)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_xmin = from._internal_xmin();
  ::uint64_t raw_xmin;
  memcpy(&raw_xmin, &tmp_xmin, sizeof(tmp_xmin));
  if (raw_xmin != 0) {
    _this->_internal_set_xmin(from._internal_xmin());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_xmax = from._internal_xmax();
  ::uint64_t raw_xmax;
  memcpy(&raw_xmax, &tmp_xmax, sizeof(tmp_xmax));
  if (raw_xmax != 0) {
    _this->_internal_set_xmax(from._internal_xmax());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_ymin = from._internal_ymin();
  ::uint64_t raw_ymin;
  memcpy(&raw_ymin, &tmp_ymin, sizeof(tmp_ymin));
  if (raw_ymin != 0) {
    _this->_internal_set_ymin(from._internal_ymin());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_ymax = from._internal_ymax();
  ::uint64_t raw_ymax;
  memcpy(&raw_ymax, &tmp_ymax, sizeof(tmp_ymax));
  if (raw_ymax != 0) {
    _this->_internal_set_ymax(from._internal_ymax());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ScanField::CopyFrom(const ScanField& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ManufacturingScenarioRepository.ScanField)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool ScanField::IsInitialized() const {
  return true;
}

void ScanField::InternalSwap(ScanField* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ScanField, _impl_.ymax_)
      + sizeof(ScanField::_impl_.ymax_)
      - PROTOBUF_FIELD_OFFSET(ScanField, _impl_.xmin_)>(
          reinterpret_cast<char*>(&_impl_.xmin_),
          reinterpret_cast<char*>(&other->_impl_.xmin_));
}

::google::protobuf::Metadata ScanField::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ModuleDefinition_2eproto_getter, &descriptor_table_ModuleDefinition_2eproto_once,
      file_level_metadata_ModuleDefinition_2eproto[10]);
}
// ===================================================================

class LaserParams::_Internal {
 public:
};

LaserParams::LaserParams(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ManufacturingScenarioRepository.LaserParams)
}
LaserParams::LaserParams(const LaserParams& from)
    : ::google::protobuf::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ManufacturingScenarioRepository.LaserParams)
}
inline void LaserParams::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.laserpowerinw_){0},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
LaserParams::~LaserParams() {
  // @@protoc_insertion_point(destructor:ManufacturingScenarioRepository.LaserParams)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void LaserParams::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}
void LaserParams::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void LaserParams::Clear() {
// @@protoc_insertion_point(message_clear_start:ManufacturingScenarioRepository.LaserParams)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.laserpowerinw_ = 0;
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* LaserParams::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2> LaserParams::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967293,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_LaserParams_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // double LaserPowerInW = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(LaserParams, _impl_.laserpowerinw_)}},
  }}, {{
    65535, 65535
  }}, {{
    // double LaserPowerInW = 2;
    {PROTOBUF_FIELD_OFFSET(LaserParams, _impl_.laserpowerinw_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* LaserParams::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ManufacturingScenarioRepository.LaserParams)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double LaserPowerInW = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_laserpowerinw = this->_internal_laserpowerinw();
  ::uint64_t raw_laserpowerinw;
  memcpy(&raw_laserpowerinw, &tmp_laserpowerinw, sizeof(tmp_laserpowerinw));
  if (raw_laserpowerinw != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_laserpowerinw(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ManufacturingScenarioRepository.LaserParams)
  return target;
}

::size_t LaserParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ManufacturingScenarioRepository.LaserParams)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double LaserPowerInW = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_laserpowerinw = this->_internal_laserpowerinw();
  ::uint64_t raw_laserpowerinw;
  memcpy(&raw_laserpowerinw, &tmp_laserpowerinw, sizeof(tmp_laserpowerinw));
  if (raw_laserpowerinw != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData LaserParams::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    LaserParams::MergeImpl
};
const ::google::protobuf::Message::ClassData*LaserParams::GetClassData() const { return &_class_data_; }


void LaserParams::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<LaserParams*>(&to_msg);
  auto& from = static_cast<const LaserParams&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ManufacturingScenarioRepository.LaserParams)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_laserpowerinw = from._internal_laserpowerinw();
  ::uint64_t raw_laserpowerinw;
  memcpy(&raw_laserpowerinw, &tmp_laserpowerinw, sizeof(tmp_laserpowerinw));
  if (raw_laserpowerinw != 0) {
    _this->_internal_set_laserpowerinw(from._internal_laserpowerinw());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void LaserParams::CopyFrom(const LaserParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ManufacturingScenarioRepository.LaserParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool LaserParams::IsInitialized() const {
  return true;
}

void LaserParams::InternalSwap(LaserParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
        swap(_impl_.laserpowerinw_, other->_impl_.laserpowerinw_);
}

::google::protobuf::Metadata LaserParams::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ModuleDefinition_2eproto_getter, &descriptor_table_ModuleDefinition_2eproto_once,
      file_level_metadata_ModuleDefinition_2eproto[11]);
}
// ===================================================================

class StandardCoaterParams::_Internal {
 public:
};

StandardCoaterParams::StandardCoaterParams(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ManufacturingScenarioRepository.StandardCoaterParams)
}
StandardCoaterParams::StandardCoaterParams(const StandardCoaterParams& from)
    : ::google::protobuf::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ManufacturingScenarioRepository.StandardCoaterParams)
}
inline void StandardCoaterParams::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.coatingspeedforwardinmmpersec_){0},
      decltype(_impl_.coatingspeedbackwardinmmpersec_){0},
      decltype(_impl_.distanceinmm_){0},
      decltype(_impl_.forwarddelayinsec_){0},
      decltype(_impl_.backwarddelayinsec_){0},
      decltype(_impl_.acceleration_){0},
      decltype(_impl_.isbidirectional_){false},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
StandardCoaterParams::~StandardCoaterParams() {
  // @@protoc_insertion_point(destructor:ManufacturingScenarioRepository.StandardCoaterParams)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void StandardCoaterParams::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}
void StandardCoaterParams::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void StandardCoaterParams::Clear() {
// @@protoc_insertion_point(message_clear_start:ManufacturingScenarioRepository.StandardCoaterParams)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.coatingspeedforwardinmmpersec_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.isbidirectional_) -
      reinterpret_cast<char*>(&_impl_.coatingspeedforwardinmmpersec_)) + sizeof(_impl_.isbidirectional_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* StandardCoaterParams::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 0, 0, 2> StandardCoaterParams::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    7, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_StandardCoaterParams_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // double coatingSpeedForwardInMmPerSec = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(StandardCoaterParams, _impl_.coatingspeedforwardinmmpersec_)}},
    // double coatingSpeedBackwardInMmPerSec = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(StandardCoaterParams, _impl_.coatingspeedbackwardinmmpersec_)}},
    // double distanceInMm = 3;
    {::_pbi::TcParser::FastF64S1,
     {25, 63, 0, PROTOBUF_FIELD_OFFSET(StandardCoaterParams, _impl_.distanceinmm_)}},
    // double forwardDelayInSec = 4;
    {::_pbi::TcParser::FastF64S1,
     {33, 63, 0, PROTOBUF_FIELD_OFFSET(StandardCoaterParams, _impl_.forwarddelayinsec_)}},
    // double backwardDelayInSec = 5;
    {::_pbi::TcParser::FastF64S1,
     {41, 63, 0, PROTOBUF_FIELD_OFFSET(StandardCoaterParams, _impl_.backwarddelayinsec_)}},
    // double acceleration = 6;
    {::_pbi::TcParser::FastF64S1,
     {49, 63, 0, PROTOBUF_FIELD_OFFSET(StandardCoaterParams, _impl_.acceleration_)}},
    // bool isBidirectional = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(StandardCoaterParams, _impl_.isbidirectional_), 63>(),
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(StandardCoaterParams, _impl_.isbidirectional_)}},
  }}, {{
    65535, 65535
  }}, {{
    // double coatingSpeedForwardInMmPerSec = 1;
    {PROTOBUF_FIELD_OFFSET(StandardCoaterParams, _impl_.coatingspeedforwardinmmpersec_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double coatingSpeedBackwardInMmPerSec = 2;
    {PROTOBUF_FIELD_OFFSET(StandardCoaterParams, _impl_.coatingspeedbackwardinmmpersec_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double distanceInMm = 3;
    {PROTOBUF_FIELD_OFFSET(StandardCoaterParams, _impl_.distanceinmm_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double forwardDelayInSec = 4;
    {PROTOBUF_FIELD_OFFSET(StandardCoaterParams, _impl_.forwarddelayinsec_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double backwardDelayInSec = 5;
    {PROTOBUF_FIELD_OFFSET(StandardCoaterParams, _impl_.backwarddelayinsec_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double acceleration = 6;
    {PROTOBUF_FIELD_OFFSET(StandardCoaterParams, _impl_.acceleration_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // bool isBidirectional = 7;
    {PROTOBUF_FIELD_OFFSET(StandardCoaterParams, _impl_.isbidirectional_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* StandardCoaterParams::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ManufacturingScenarioRepository.StandardCoaterParams)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double coatingSpeedForwardInMmPerSec = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_coatingspeedforwardinmmpersec = this->_internal_coatingspeedforwardinmmpersec();
  ::uint64_t raw_coatingspeedforwardinmmpersec;
  memcpy(&raw_coatingspeedforwardinmmpersec, &tmp_coatingspeedforwardinmmpersec, sizeof(tmp_coatingspeedforwardinmmpersec));
  if (raw_coatingspeedforwardinmmpersec != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_coatingspeedforwardinmmpersec(), target);
  }

  // double coatingSpeedBackwardInMmPerSec = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_coatingspeedbackwardinmmpersec = this->_internal_coatingspeedbackwardinmmpersec();
  ::uint64_t raw_coatingspeedbackwardinmmpersec;
  memcpy(&raw_coatingspeedbackwardinmmpersec, &tmp_coatingspeedbackwardinmmpersec, sizeof(tmp_coatingspeedbackwardinmmpersec));
  if (raw_coatingspeedbackwardinmmpersec != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_coatingspeedbackwardinmmpersec(), target);
  }

  // double distanceInMm = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_distanceinmm = this->_internal_distanceinmm();
  ::uint64_t raw_distanceinmm;
  memcpy(&raw_distanceinmm, &tmp_distanceinmm, sizeof(tmp_distanceinmm));
  if (raw_distanceinmm != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_distanceinmm(), target);
  }

  // double forwardDelayInSec = 4;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_forwarddelayinsec = this->_internal_forwarddelayinsec();
  ::uint64_t raw_forwarddelayinsec;
  memcpy(&raw_forwarddelayinsec, &tmp_forwarddelayinsec, sizeof(tmp_forwarddelayinsec));
  if (raw_forwarddelayinsec != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        4, this->_internal_forwarddelayinsec(), target);
  }

  // double backwardDelayInSec = 5;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_backwarddelayinsec = this->_internal_backwarddelayinsec();
  ::uint64_t raw_backwarddelayinsec;
  memcpy(&raw_backwarddelayinsec, &tmp_backwarddelayinsec, sizeof(tmp_backwarddelayinsec));
  if (raw_backwarddelayinsec != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        5, this->_internal_backwarddelayinsec(), target);
  }

  // double acceleration = 6;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_acceleration = this->_internal_acceleration();
  ::uint64_t raw_acceleration;
  memcpy(&raw_acceleration, &tmp_acceleration, sizeof(tmp_acceleration));
  if (raw_acceleration != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        6, this->_internal_acceleration(), target);
  }

  // bool isBidirectional = 7;
  if (this->_internal_isbidirectional() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        7, this->_internal_isbidirectional(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ManufacturingScenarioRepository.StandardCoaterParams)
  return target;
}

::size_t StandardCoaterParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ManufacturingScenarioRepository.StandardCoaterParams)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double coatingSpeedForwardInMmPerSec = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_coatingspeedforwardinmmpersec = this->_internal_coatingspeedforwardinmmpersec();
  ::uint64_t raw_coatingspeedforwardinmmpersec;
  memcpy(&raw_coatingspeedforwardinmmpersec, &tmp_coatingspeedforwardinmmpersec, sizeof(tmp_coatingspeedforwardinmmpersec));
  if (raw_coatingspeedforwardinmmpersec != 0) {
    total_size += 9;
  }

  // double coatingSpeedBackwardInMmPerSec = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_coatingspeedbackwardinmmpersec = this->_internal_coatingspeedbackwardinmmpersec();
  ::uint64_t raw_coatingspeedbackwardinmmpersec;
  memcpy(&raw_coatingspeedbackwardinmmpersec, &tmp_coatingspeedbackwardinmmpersec, sizeof(tmp_coatingspeedbackwardinmmpersec));
  if (raw_coatingspeedbackwardinmmpersec != 0) {
    total_size += 9;
  }

  // double distanceInMm = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_distanceinmm = this->_internal_distanceinmm();
  ::uint64_t raw_distanceinmm;
  memcpy(&raw_distanceinmm, &tmp_distanceinmm, sizeof(tmp_distanceinmm));
  if (raw_distanceinmm != 0) {
    total_size += 9;
  }

  // double forwardDelayInSec = 4;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_forwarddelayinsec = this->_internal_forwarddelayinsec();
  ::uint64_t raw_forwarddelayinsec;
  memcpy(&raw_forwarddelayinsec, &tmp_forwarddelayinsec, sizeof(tmp_forwarddelayinsec));
  if (raw_forwarddelayinsec != 0) {
    total_size += 9;
  }

  // double backwardDelayInSec = 5;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_backwarddelayinsec = this->_internal_backwarddelayinsec();
  ::uint64_t raw_backwarddelayinsec;
  memcpy(&raw_backwarddelayinsec, &tmp_backwarddelayinsec, sizeof(tmp_backwarddelayinsec));
  if (raw_backwarddelayinsec != 0) {
    total_size += 9;
  }

  // double acceleration = 6;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_acceleration = this->_internal_acceleration();
  ::uint64_t raw_acceleration;
  memcpy(&raw_acceleration, &tmp_acceleration, sizeof(tmp_acceleration));
  if (raw_acceleration != 0) {
    total_size += 9;
  }

  // bool isBidirectional = 7;
  if (this->_internal_isbidirectional() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData StandardCoaterParams::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    StandardCoaterParams::MergeImpl
};
const ::google::protobuf::Message::ClassData*StandardCoaterParams::GetClassData() const { return &_class_data_; }


void StandardCoaterParams::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<StandardCoaterParams*>(&to_msg);
  auto& from = static_cast<const StandardCoaterParams&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ManufacturingScenarioRepository.StandardCoaterParams)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_coatingspeedforwardinmmpersec = from._internal_coatingspeedforwardinmmpersec();
  ::uint64_t raw_coatingspeedforwardinmmpersec;
  memcpy(&raw_coatingspeedforwardinmmpersec, &tmp_coatingspeedforwardinmmpersec, sizeof(tmp_coatingspeedforwardinmmpersec));
  if (raw_coatingspeedforwardinmmpersec != 0) {
    _this->_internal_set_coatingspeedforwardinmmpersec(from._internal_coatingspeedforwardinmmpersec());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_coatingspeedbackwardinmmpersec = from._internal_coatingspeedbackwardinmmpersec();
  ::uint64_t raw_coatingspeedbackwardinmmpersec;
  memcpy(&raw_coatingspeedbackwardinmmpersec, &tmp_coatingspeedbackwardinmmpersec, sizeof(tmp_coatingspeedbackwardinmmpersec));
  if (raw_coatingspeedbackwardinmmpersec != 0) {
    _this->_internal_set_coatingspeedbackwardinmmpersec(from._internal_coatingspeedbackwardinmmpersec());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_distanceinmm = from._internal_distanceinmm();
  ::uint64_t raw_distanceinmm;
  memcpy(&raw_distanceinmm, &tmp_distanceinmm, sizeof(tmp_distanceinmm));
  if (raw_distanceinmm != 0) {
    _this->_internal_set_distanceinmm(from._internal_distanceinmm());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_forwarddelayinsec = from._internal_forwarddelayinsec();
  ::uint64_t raw_forwarddelayinsec;
  memcpy(&raw_forwarddelayinsec, &tmp_forwarddelayinsec, sizeof(tmp_forwarddelayinsec));
  if (raw_forwarddelayinsec != 0) {
    _this->_internal_set_forwarddelayinsec(from._internal_forwarddelayinsec());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_backwarddelayinsec = from._internal_backwarddelayinsec();
  ::uint64_t raw_backwarddelayinsec;
  memcpy(&raw_backwarddelayinsec, &tmp_backwarddelayinsec, sizeof(tmp_backwarddelayinsec));
  if (raw_backwarddelayinsec != 0) {
    _this->_internal_set_backwarddelayinsec(from._internal_backwarddelayinsec());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_acceleration = from._internal_acceleration();
  ::uint64_t raw_acceleration;
  memcpy(&raw_acceleration, &tmp_acceleration, sizeof(tmp_acceleration));
  if (raw_acceleration != 0) {
    _this->_internal_set_acceleration(from._internal_acceleration());
  }
  if (from._internal_isbidirectional() != 0) {
    _this->_internal_set_isbidirectional(from._internal_isbidirectional());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void StandardCoaterParams::CopyFrom(const StandardCoaterParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ManufacturingScenarioRepository.StandardCoaterParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool StandardCoaterParams::IsInitialized() const {
  return true;
}

void StandardCoaterParams::InternalSwap(StandardCoaterParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StandardCoaterParams, _impl_.isbidirectional_)
      + sizeof(StandardCoaterParams::_impl_.isbidirectional_)
      - PROTOBUF_FIELD_OFFSET(StandardCoaterParams, _impl_.coatingspeedforwardinmmpersec_)>(
          reinterpret_cast<char*>(&_impl_.coatingspeedforwardinmmpersec_),
          reinterpret_cast<char*>(&other->_impl_.coatingspeedforwardinmmpersec_));
}

::google::protobuf::Metadata StandardCoaterParams::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ModuleDefinition_2eproto_getter, &descriptor_table_ModuleDefinition_2eproto_once,
      file_level_metadata_ModuleDefinition_2eproto[12]);
}
// ===================================================================

class BuildChamberParams::_Internal {
 public:
};

BuildChamberParams::BuildChamberParams(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ManufacturingScenarioRepository.BuildChamberParams)
}
BuildChamberParams::BuildChamberParams(const BuildChamberParams& from)
    : ::google::protobuf::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ManufacturingScenarioRepository.BuildChamberParams)
}
inline void BuildChamberParams::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.platformliftrateinmmpersec_){0},
      decltype(_impl_.inertatmospheretimeins_){0},
      decltype(_impl_.releaseatmospheretimeins_){0},
      decltype(_impl_.maximumo2ppm_){0},
      decltype(_impl_.platformliftaccelerationinmmpersec2_){0},
      decltype(_impl_.platformliftdelayins_){0},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
BuildChamberParams::~BuildChamberParams() {
  // @@protoc_insertion_point(destructor:ManufacturingScenarioRepository.BuildChamberParams)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void BuildChamberParams::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}
void BuildChamberParams::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void BuildChamberParams::Clear() {
// @@protoc_insertion_point(message_clear_start:ManufacturingScenarioRepository.BuildChamberParams)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.platformliftrateinmmpersec_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.platformliftdelayins_) -
      reinterpret_cast<char*>(&_impl_.platformliftrateinmmpersec_)) + sizeof(_impl_.platformliftdelayins_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* BuildChamberParams::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 0, 0, 2> BuildChamberParams::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967232,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_BuildChamberParams_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // double platformLiftRateInMmPerSec = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(BuildChamberParams, _impl_.platformliftrateinmmpersec_)}},
    // double inertAtmosphereTimeInS = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(BuildChamberParams, _impl_.inertatmospheretimeins_)}},
    // double releaseAtmosphereTimeInS = 3;
    {::_pbi::TcParser::FastF64S1,
     {25, 63, 0, PROTOBUF_FIELD_OFFSET(BuildChamberParams, _impl_.releaseatmospheretimeins_)}},
    // double maximumO2PPM = 4;
    {::_pbi::TcParser::FastF64S1,
     {33, 63, 0, PROTOBUF_FIELD_OFFSET(BuildChamberParams, _impl_.maximumo2ppm_)}},
    // double platformLiftAccelerationInMmPerSec2 = 5;
    {::_pbi::TcParser::FastF64S1,
     {41, 63, 0, PROTOBUF_FIELD_OFFSET(BuildChamberParams, _impl_.platformliftaccelerationinmmpersec2_)}},
    // double platformLiftDelayInS = 6;
    {::_pbi::TcParser::FastF64S1,
     {49, 63, 0, PROTOBUF_FIELD_OFFSET(BuildChamberParams, _impl_.platformliftdelayins_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // double platformLiftRateInMmPerSec = 1;
    {PROTOBUF_FIELD_OFFSET(BuildChamberParams, _impl_.platformliftrateinmmpersec_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double inertAtmosphereTimeInS = 2;
    {PROTOBUF_FIELD_OFFSET(BuildChamberParams, _impl_.inertatmospheretimeins_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double releaseAtmosphereTimeInS = 3;
    {PROTOBUF_FIELD_OFFSET(BuildChamberParams, _impl_.releaseatmospheretimeins_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double maximumO2PPM = 4;
    {PROTOBUF_FIELD_OFFSET(BuildChamberParams, _impl_.maximumo2ppm_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double platformLiftAccelerationInMmPerSec2 = 5;
    {PROTOBUF_FIELD_OFFSET(BuildChamberParams, _impl_.platformliftaccelerationinmmpersec2_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double platformLiftDelayInS = 6;
    {PROTOBUF_FIELD_OFFSET(BuildChamberParams, _impl_.platformliftdelayins_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* BuildChamberParams::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ManufacturingScenarioRepository.BuildChamberParams)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double platformLiftRateInMmPerSec = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_platformliftrateinmmpersec = this->_internal_platformliftrateinmmpersec();
  ::uint64_t raw_platformliftrateinmmpersec;
  memcpy(&raw_platformliftrateinmmpersec, &tmp_platformliftrateinmmpersec, sizeof(tmp_platformliftrateinmmpersec));
  if (raw_platformliftrateinmmpersec != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_platformliftrateinmmpersec(), target);
  }

  // double inertAtmosphereTimeInS = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_inertatmospheretimeins = this->_internal_inertatmospheretimeins();
  ::uint64_t raw_inertatmospheretimeins;
  memcpy(&raw_inertatmospheretimeins, &tmp_inertatmospheretimeins, sizeof(tmp_inertatmospheretimeins));
  if (raw_inertatmospheretimeins != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_inertatmospheretimeins(), target);
  }

  // double releaseAtmosphereTimeInS = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_releaseatmospheretimeins = this->_internal_releaseatmospheretimeins();
  ::uint64_t raw_releaseatmospheretimeins;
  memcpy(&raw_releaseatmospheretimeins, &tmp_releaseatmospheretimeins, sizeof(tmp_releaseatmospheretimeins));
  if (raw_releaseatmospheretimeins != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_releaseatmospheretimeins(), target);
  }

  // double maximumO2PPM = 4;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_maximumo2ppm = this->_internal_maximumo2ppm();
  ::uint64_t raw_maximumo2ppm;
  memcpy(&raw_maximumo2ppm, &tmp_maximumo2ppm, sizeof(tmp_maximumo2ppm));
  if (raw_maximumo2ppm != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        4, this->_internal_maximumo2ppm(), target);
  }

  // double platformLiftAccelerationInMmPerSec2 = 5;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_platformliftaccelerationinmmpersec2 = this->_internal_platformliftaccelerationinmmpersec2();
  ::uint64_t raw_platformliftaccelerationinmmpersec2;
  memcpy(&raw_platformliftaccelerationinmmpersec2, &tmp_platformliftaccelerationinmmpersec2, sizeof(tmp_platformliftaccelerationinmmpersec2));
  if (raw_platformliftaccelerationinmmpersec2 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        5, this->_internal_platformliftaccelerationinmmpersec2(), target);
  }

  // double platformLiftDelayInS = 6;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_platformliftdelayins = this->_internal_platformliftdelayins();
  ::uint64_t raw_platformliftdelayins;
  memcpy(&raw_platformliftdelayins, &tmp_platformliftdelayins, sizeof(tmp_platformliftdelayins));
  if (raw_platformliftdelayins != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        6, this->_internal_platformliftdelayins(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ManufacturingScenarioRepository.BuildChamberParams)
  return target;
}

::size_t BuildChamberParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ManufacturingScenarioRepository.BuildChamberParams)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double platformLiftRateInMmPerSec = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_platformliftrateinmmpersec = this->_internal_platformliftrateinmmpersec();
  ::uint64_t raw_platformliftrateinmmpersec;
  memcpy(&raw_platformliftrateinmmpersec, &tmp_platformliftrateinmmpersec, sizeof(tmp_platformliftrateinmmpersec));
  if (raw_platformliftrateinmmpersec != 0) {
    total_size += 9;
  }

  // double inertAtmosphereTimeInS = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_inertatmospheretimeins = this->_internal_inertatmospheretimeins();
  ::uint64_t raw_inertatmospheretimeins;
  memcpy(&raw_inertatmospheretimeins, &tmp_inertatmospheretimeins, sizeof(tmp_inertatmospheretimeins));
  if (raw_inertatmospheretimeins != 0) {
    total_size += 9;
  }

  // double releaseAtmosphereTimeInS = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_releaseatmospheretimeins = this->_internal_releaseatmospheretimeins();
  ::uint64_t raw_releaseatmospheretimeins;
  memcpy(&raw_releaseatmospheretimeins, &tmp_releaseatmospheretimeins, sizeof(tmp_releaseatmospheretimeins));
  if (raw_releaseatmospheretimeins != 0) {
    total_size += 9;
  }

  // double maximumO2PPM = 4;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_maximumo2ppm = this->_internal_maximumo2ppm();
  ::uint64_t raw_maximumo2ppm;
  memcpy(&raw_maximumo2ppm, &tmp_maximumo2ppm, sizeof(tmp_maximumo2ppm));
  if (raw_maximumo2ppm != 0) {
    total_size += 9;
  }

  // double platformLiftAccelerationInMmPerSec2 = 5;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_platformliftaccelerationinmmpersec2 = this->_internal_platformliftaccelerationinmmpersec2();
  ::uint64_t raw_platformliftaccelerationinmmpersec2;
  memcpy(&raw_platformliftaccelerationinmmpersec2, &tmp_platformliftaccelerationinmmpersec2, sizeof(tmp_platformliftaccelerationinmmpersec2));
  if (raw_platformliftaccelerationinmmpersec2 != 0) {
    total_size += 9;
  }

  // double platformLiftDelayInS = 6;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_platformliftdelayins = this->_internal_platformliftdelayins();
  ::uint64_t raw_platformliftdelayins;
  memcpy(&raw_platformliftdelayins, &tmp_platformliftdelayins, sizeof(tmp_platformliftdelayins));
  if (raw_platformliftdelayins != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData BuildChamberParams::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    BuildChamberParams::MergeImpl
};
const ::google::protobuf::Message::ClassData*BuildChamberParams::GetClassData() const { return &_class_data_; }


void BuildChamberParams::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<BuildChamberParams*>(&to_msg);
  auto& from = static_cast<const BuildChamberParams&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ManufacturingScenarioRepository.BuildChamberParams)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_platformliftrateinmmpersec = from._internal_platformliftrateinmmpersec();
  ::uint64_t raw_platformliftrateinmmpersec;
  memcpy(&raw_platformliftrateinmmpersec, &tmp_platformliftrateinmmpersec, sizeof(tmp_platformliftrateinmmpersec));
  if (raw_platformliftrateinmmpersec != 0) {
    _this->_internal_set_platformliftrateinmmpersec(from._internal_platformliftrateinmmpersec());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_inertatmospheretimeins = from._internal_inertatmospheretimeins();
  ::uint64_t raw_inertatmospheretimeins;
  memcpy(&raw_inertatmospheretimeins, &tmp_inertatmospheretimeins, sizeof(tmp_inertatmospheretimeins));
  if (raw_inertatmospheretimeins != 0) {
    _this->_internal_set_inertatmospheretimeins(from._internal_inertatmospheretimeins());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_releaseatmospheretimeins = from._internal_releaseatmospheretimeins();
  ::uint64_t raw_releaseatmospheretimeins;
  memcpy(&raw_releaseatmospheretimeins, &tmp_releaseatmospheretimeins, sizeof(tmp_releaseatmospheretimeins));
  if (raw_releaseatmospheretimeins != 0) {
    _this->_internal_set_releaseatmospheretimeins(from._internal_releaseatmospheretimeins());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_maximumo2ppm = from._internal_maximumo2ppm();
  ::uint64_t raw_maximumo2ppm;
  memcpy(&raw_maximumo2ppm, &tmp_maximumo2ppm, sizeof(tmp_maximumo2ppm));
  if (raw_maximumo2ppm != 0) {
    _this->_internal_set_maximumo2ppm(from._internal_maximumo2ppm());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_platformliftaccelerationinmmpersec2 = from._internal_platformliftaccelerationinmmpersec2();
  ::uint64_t raw_platformliftaccelerationinmmpersec2;
  memcpy(&raw_platformliftaccelerationinmmpersec2, &tmp_platformliftaccelerationinmmpersec2, sizeof(tmp_platformliftaccelerationinmmpersec2));
  if (raw_platformliftaccelerationinmmpersec2 != 0) {
    _this->_internal_set_platformliftaccelerationinmmpersec2(from._internal_platformliftaccelerationinmmpersec2());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_platformliftdelayins = from._internal_platformliftdelayins();
  ::uint64_t raw_platformliftdelayins;
  memcpy(&raw_platformliftdelayins, &tmp_platformliftdelayins, sizeof(tmp_platformliftdelayins));
  if (raw_platformliftdelayins != 0) {
    _this->_internal_set_platformliftdelayins(from._internal_platformliftdelayins());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void BuildChamberParams::CopyFrom(const BuildChamberParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ManufacturingScenarioRepository.BuildChamberParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool BuildChamberParams::IsInitialized() const {
  return true;
}

void BuildChamberParams::InternalSwap(BuildChamberParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BuildChamberParams, _impl_.platformliftdelayins_)
      + sizeof(BuildChamberParams::_impl_.platformliftdelayins_)
      - PROTOBUF_FIELD_OFFSET(BuildChamberParams, _impl_.platformliftrateinmmpersec_)>(
          reinterpret_cast<char*>(&_impl_.platformliftrateinmmpersec_),
          reinterpret_cast<char*>(&other->_impl_.platformliftrateinmmpersec_));
}

::google::protobuf::Metadata BuildChamberParams::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ModuleDefinition_2eproto_getter, &descriptor_table_ModuleDefinition_2eproto_once,
      file_level_metadata_ModuleDefinition_2eproto[13]);
}
// ===================================================================

class CuboidBuildVolumeParams::_Internal {
 public:
};

CuboidBuildVolumeParams::CuboidBuildVolumeParams(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ManufacturingScenarioRepository.CuboidBuildVolumeParams)
}
CuboidBuildVolumeParams::CuboidBuildVolumeParams(const CuboidBuildVolumeParams& from)
    : ::google::protobuf::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ManufacturingScenarioRepository.CuboidBuildVolumeParams)
}
inline void CuboidBuildVolumeParams::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.xmin_){0},
      decltype(_impl_.xmax_){0},
      decltype(_impl_.ymin_){0},
      decltype(_impl_.ymax_){0},
      decltype(_impl_.zmin_){0},
      decltype(_impl_.zmax_){0},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
CuboidBuildVolumeParams::~CuboidBuildVolumeParams() {
  // @@protoc_insertion_point(destructor:ManufacturingScenarioRepository.CuboidBuildVolumeParams)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CuboidBuildVolumeParams::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}
void CuboidBuildVolumeParams::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void CuboidBuildVolumeParams::Clear() {
// @@protoc_insertion_point(message_clear_start:ManufacturingScenarioRepository.CuboidBuildVolumeParams)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.xmin_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.zmax_) -
      reinterpret_cast<char*>(&_impl_.xmin_)) + sizeof(_impl_.zmax_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CuboidBuildVolumeParams::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 0, 0, 2> CuboidBuildVolumeParams::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967232,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_CuboidBuildVolumeParams_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // double XMin = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(CuboidBuildVolumeParams, _impl_.xmin_)}},
    // double XMax = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(CuboidBuildVolumeParams, _impl_.xmax_)}},
    // double YMin = 3;
    {::_pbi::TcParser::FastF64S1,
     {25, 63, 0, PROTOBUF_FIELD_OFFSET(CuboidBuildVolumeParams, _impl_.ymin_)}},
    // double YMax = 4;
    {::_pbi::TcParser::FastF64S1,
     {33, 63, 0, PROTOBUF_FIELD_OFFSET(CuboidBuildVolumeParams, _impl_.ymax_)}},
    // double ZMin = 5;
    {::_pbi::TcParser::FastF64S1,
     {41, 63, 0, PROTOBUF_FIELD_OFFSET(CuboidBuildVolumeParams, _impl_.zmin_)}},
    // double ZMax = 6;
    {::_pbi::TcParser::FastF64S1,
     {49, 63, 0, PROTOBUF_FIELD_OFFSET(CuboidBuildVolumeParams, _impl_.zmax_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // double XMin = 1;
    {PROTOBUF_FIELD_OFFSET(CuboidBuildVolumeParams, _impl_.xmin_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double XMax = 2;
    {PROTOBUF_FIELD_OFFSET(CuboidBuildVolumeParams, _impl_.xmax_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double YMin = 3;
    {PROTOBUF_FIELD_OFFSET(CuboidBuildVolumeParams, _impl_.ymin_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double YMax = 4;
    {PROTOBUF_FIELD_OFFSET(CuboidBuildVolumeParams, _impl_.ymax_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double ZMin = 5;
    {PROTOBUF_FIELD_OFFSET(CuboidBuildVolumeParams, _impl_.zmin_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double ZMax = 6;
    {PROTOBUF_FIELD_OFFSET(CuboidBuildVolumeParams, _impl_.zmax_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* CuboidBuildVolumeParams::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ManufacturingScenarioRepository.CuboidBuildVolumeParams)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double XMin = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_xmin = this->_internal_xmin();
  ::uint64_t raw_xmin;
  memcpy(&raw_xmin, &tmp_xmin, sizeof(tmp_xmin));
  if (raw_xmin != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_xmin(), target);
  }

  // double XMax = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_xmax = this->_internal_xmax();
  ::uint64_t raw_xmax;
  memcpy(&raw_xmax, &tmp_xmax, sizeof(tmp_xmax));
  if (raw_xmax != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_xmax(), target);
  }

  // double YMin = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_ymin = this->_internal_ymin();
  ::uint64_t raw_ymin;
  memcpy(&raw_ymin, &tmp_ymin, sizeof(tmp_ymin));
  if (raw_ymin != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_ymin(), target);
  }

  // double YMax = 4;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_ymax = this->_internal_ymax();
  ::uint64_t raw_ymax;
  memcpy(&raw_ymax, &tmp_ymax, sizeof(tmp_ymax));
  if (raw_ymax != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        4, this->_internal_ymax(), target);
  }

  // double ZMin = 5;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_zmin = this->_internal_zmin();
  ::uint64_t raw_zmin;
  memcpy(&raw_zmin, &tmp_zmin, sizeof(tmp_zmin));
  if (raw_zmin != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        5, this->_internal_zmin(), target);
  }

  // double ZMax = 6;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_zmax = this->_internal_zmax();
  ::uint64_t raw_zmax;
  memcpy(&raw_zmax, &tmp_zmax, sizeof(tmp_zmax));
  if (raw_zmax != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        6, this->_internal_zmax(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ManufacturingScenarioRepository.CuboidBuildVolumeParams)
  return target;
}

::size_t CuboidBuildVolumeParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ManufacturingScenarioRepository.CuboidBuildVolumeParams)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double XMin = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_xmin = this->_internal_xmin();
  ::uint64_t raw_xmin;
  memcpy(&raw_xmin, &tmp_xmin, sizeof(tmp_xmin));
  if (raw_xmin != 0) {
    total_size += 9;
  }

  // double XMax = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_xmax = this->_internal_xmax();
  ::uint64_t raw_xmax;
  memcpy(&raw_xmax, &tmp_xmax, sizeof(tmp_xmax));
  if (raw_xmax != 0) {
    total_size += 9;
  }

  // double YMin = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_ymin = this->_internal_ymin();
  ::uint64_t raw_ymin;
  memcpy(&raw_ymin, &tmp_ymin, sizeof(tmp_ymin));
  if (raw_ymin != 0) {
    total_size += 9;
  }

  // double YMax = 4;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_ymax = this->_internal_ymax();
  ::uint64_t raw_ymax;
  memcpy(&raw_ymax, &tmp_ymax, sizeof(tmp_ymax));
  if (raw_ymax != 0) {
    total_size += 9;
  }

  // double ZMin = 5;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_zmin = this->_internal_zmin();
  ::uint64_t raw_zmin;
  memcpy(&raw_zmin, &tmp_zmin, sizeof(tmp_zmin));
  if (raw_zmin != 0) {
    total_size += 9;
  }

  // double ZMax = 6;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_zmax = this->_internal_zmax();
  ::uint64_t raw_zmax;
  memcpy(&raw_zmax, &tmp_zmax, sizeof(tmp_zmax));
  if (raw_zmax != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CuboidBuildVolumeParams::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    CuboidBuildVolumeParams::MergeImpl
};
const ::google::protobuf::Message::ClassData*CuboidBuildVolumeParams::GetClassData() const { return &_class_data_; }


void CuboidBuildVolumeParams::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CuboidBuildVolumeParams*>(&to_msg);
  auto& from = static_cast<const CuboidBuildVolumeParams&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ManufacturingScenarioRepository.CuboidBuildVolumeParams)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_xmin = from._internal_xmin();
  ::uint64_t raw_xmin;
  memcpy(&raw_xmin, &tmp_xmin, sizeof(tmp_xmin));
  if (raw_xmin != 0) {
    _this->_internal_set_xmin(from._internal_xmin());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_xmax = from._internal_xmax();
  ::uint64_t raw_xmax;
  memcpy(&raw_xmax, &tmp_xmax, sizeof(tmp_xmax));
  if (raw_xmax != 0) {
    _this->_internal_set_xmax(from._internal_xmax());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_ymin = from._internal_ymin();
  ::uint64_t raw_ymin;
  memcpy(&raw_ymin, &tmp_ymin, sizeof(tmp_ymin));
  if (raw_ymin != 0) {
    _this->_internal_set_ymin(from._internal_ymin());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_ymax = from._internal_ymax();
  ::uint64_t raw_ymax;
  memcpy(&raw_ymax, &tmp_ymax, sizeof(tmp_ymax));
  if (raw_ymax != 0) {
    _this->_internal_set_ymax(from._internal_ymax());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_zmin = from._internal_zmin();
  ::uint64_t raw_zmin;
  memcpy(&raw_zmin, &tmp_zmin, sizeof(tmp_zmin));
  if (raw_zmin != 0) {
    _this->_internal_set_zmin(from._internal_zmin());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_zmax = from._internal_zmax();
  ::uint64_t raw_zmax;
  memcpy(&raw_zmax, &tmp_zmax, sizeof(tmp_zmax));
  if (raw_zmax != 0) {
    _this->_internal_set_zmax(from._internal_zmax());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CuboidBuildVolumeParams::CopyFrom(const CuboidBuildVolumeParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ManufacturingScenarioRepository.CuboidBuildVolumeParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CuboidBuildVolumeParams::IsInitialized() const {
  return true;
}

void CuboidBuildVolumeParams::InternalSwap(CuboidBuildVolumeParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CuboidBuildVolumeParams, _impl_.zmax_)
      + sizeof(CuboidBuildVolumeParams::_impl_.zmax_)
      - PROTOBUF_FIELD_OFFSET(CuboidBuildVolumeParams, _impl_.xmin_)>(
          reinterpret_cast<char*>(&_impl_.xmin_),
          reinterpret_cast<char*>(&other->_impl_.xmin_));
}

::google::protobuf::Metadata CuboidBuildVolumeParams::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ModuleDefinition_2eproto_getter, &descriptor_table_ModuleDefinition_2eproto_once,
      file_level_metadata_ModuleDefinition_2eproto[14]);
}
// ===================================================================

class ZylinderBuildVolumeParams::_Internal {
 public:
};

ZylinderBuildVolumeParams::ZylinderBuildVolumeParams(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ManufacturingScenarioRepository.ZylinderBuildVolumeParams)
}
ZylinderBuildVolumeParams::ZylinderBuildVolumeParams(const ZylinderBuildVolumeParams& from)
    : ::google::protobuf::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ManufacturingScenarioRepository.ZylinderBuildVolumeParams)
}
inline void ZylinderBuildVolumeParams::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.diameter_){0},
      decltype(_impl_.height_){0},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
ZylinderBuildVolumeParams::~ZylinderBuildVolumeParams() {
  // @@protoc_insertion_point(destructor:ManufacturingScenarioRepository.ZylinderBuildVolumeParams)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void ZylinderBuildVolumeParams::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}
void ZylinderBuildVolumeParams::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void ZylinderBuildVolumeParams::Clear() {
// @@protoc_insertion_point(message_clear_start:ManufacturingScenarioRepository.ZylinderBuildVolumeParams)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.diameter_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.height_) -
      reinterpret_cast<char*>(&_impl_.diameter_)) + sizeof(_impl_.height_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* ZylinderBuildVolumeParams::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> ZylinderBuildVolumeParams::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967289,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_ZylinderBuildVolumeParams_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // double diameter = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(ZylinderBuildVolumeParams, _impl_.diameter_)}},
    // double height = 3;
    {::_pbi::TcParser::FastF64S1,
     {25, 63, 0, PROTOBUF_FIELD_OFFSET(ZylinderBuildVolumeParams, _impl_.height_)}},
  }}, {{
    65535, 65535
  }}, {{
    // double diameter = 2;
    {PROTOBUF_FIELD_OFFSET(ZylinderBuildVolumeParams, _impl_.diameter_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double height = 3;
    {PROTOBUF_FIELD_OFFSET(ZylinderBuildVolumeParams, _impl_.height_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* ZylinderBuildVolumeParams::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ManufacturingScenarioRepository.ZylinderBuildVolumeParams)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double diameter = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_diameter = this->_internal_diameter();
  ::uint64_t raw_diameter;
  memcpy(&raw_diameter, &tmp_diameter, sizeof(tmp_diameter));
  if (raw_diameter != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_diameter(), target);
  }

  // double height = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_height = this->_internal_height();
  ::uint64_t raw_height;
  memcpy(&raw_height, &tmp_height, sizeof(tmp_height));
  if (raw_height != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_height(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ManufacturingScenarioRepository.ZylinderBuildVolumeParams)
  return target;
}

::size_t ZylinderBuildVolumeParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ManufacturingScenarioRepository.ZylinderBuildVolumeParams)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double diameter = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_diameter = this->_internal_diameter();
  ::uint64_t raw_diameter;
  memcpy(&raw_diameter, &tmp_diameter, sizeof(tmp_diameter));
  if (raw_diameter != 0) {
    total_size += 9;
  }

  // double height = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_height = this->_internal_height();
  ::uint64_t raw_height;
  memcpy(&raw_height, &tmp_height, sizeof(tmp_height));
  if (raw_height != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData ZylinderBuildVolumeParams::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    ZylinderBuildVolumeParams::MergeImpl
};
const ::google::protobuf::Message::ClassData*ZylinderBuildVolumeParams::GetClassData() const { return &_class_data_; }


void ZylinderBuildVolumeParams::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<ZylinderBuildVolumeParams*>(&to_msg);
  auto& from = static_cast<const ZylinderBuildVolumeParams&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ManufacturingScenarioRepository.ZylinderBuildVolumeParams)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_diameter = from._internal_diameter();
  ::uint64_t raw_diameter;
  memcpy(&raw_diameter, &tmp_diameter, sizeof(tmp_diameter));
  if (raw_diameter != 0) {
    _this->_internal_set_diameter(from._internal_diameter());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_height = from._internal_height();
  ::uint64_t raw_height;
  memcpy(&raw_height, &tmp_height, sizeof(tmp_height));
  if (raw_height != 0) {
    _this->_internal_set_height(from._internal_height());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ZylinderBuildVolumeParams::CopyFrom(const ZylinderBuildVolumeParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ManufacturingScenarioRepository.ZylinderBuildVolumeParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool ZylinderBuildVolumeParams::IsInitialized() const {
  return true;
}

void ZylinderBuildVolumeParams::InternalSwap(ZylinderBuildVolumeParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ZylinderBuildVolumeParams, _impl_.height_)
      + sizeof(ZylinderBuildVolumeParams::_impl_.height_)
      - PROTOBUF_FIELD_OFFSET(ZylinderBuildVolumeParams, _impl_.diameter_)>(
          reinterpret_cast<char*>(&_impl_.diameter_),
          reinterpret_cast<char*>(&other->_impl_.diameter_));
}

::google::protobuf::Metadata ZylinderBuildVolumeParams::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ModuleDefinition_2eproto_getter, &descriptor_table_ModuleDefinition_2eproto_once,
      file_level_metadata_ModuleDefinition_2eproto[15]);
}
// ===================================================================

class PreheaterParams::_Internal {
 public:
};

PreheaterParams::PreheaterParams(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ManufacturingScenarioRepository.PreheaterParams)
}
PreheaterParams::PreheaterParams(const PreheaterParams& from)
    : ::google::protobuf::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ManufacturingScenarioRepository.PreheaterParams)
}
inline void PreheaterParams::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.preheatingtemperature_){0},
      decltype(_impl_.maximumpreheatingtemperature_){0},
      decltype(_impl_.heatingrateinsecperk_){0},
      decltype(_impl_.roomtemperature_){0},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
PreheaterParams::~PreheaterParams() {
  // @@protoc_insertion_point(destructor:ManufacturingScenarioRepository.PreheaterParams)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void PreheaterParams::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}
void PreheaterParams::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void PreheaterParams::Clear() {
// @@protoc_insertion_point(message_clear_start:ManufacturingScenarioRepository.PreheaterParams)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.preheatingtemperature_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.roomtemperature_) -
      reinterpret_cast<char*>(&_impl_.preheatingtemperature_)) + sizeof(_impl_.roomtemperature_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* PreheaterParams::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2> PreheaterParams::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    5, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967265,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_PreheaterParams_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // double heatingRateInSecPerK = 4;
    {::_pbi::TcParser::FastF64S1,
     {33, 63, 0, PROTOBUF_FIELD_OFFSET(PreheaterParams, _impl_.heatingrateinsecperk_)}},
    // double roomTemperature = 5;
    {::_pbi::TcParser::FastF64S1,
     {41, 63, 0, PROTOBUF_FIELD_OFFSET(PreheaterParams, _impl_.roomtemperature_)}},
    // double preheatingTemperature = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(PreheaterParams, _impl_.preheatingtemperature_)}},
    // double maximumPreheatingTemperature = 3;
    {::_pbi::TcParser::FastF64S1,
     {25, 63, 0, PROTOBUF_FIELD_OFFSET(PreheaterParams, _impl_.maximumpreheatingtemperature_)}},
  }}, {{
    65535, 65535
  }}, {{
    // double preheatingTemperature = 2;
    {PROTOBUF_FIELD_OFFSET(PreheaterParams, _impl_.preheatingtemperature_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double maximumPreheatingTemperature = 3;
    {PROTOBUF_FIELD_OFFSET(PreheaterParams, _impl_.maximumpreheatingtemperature_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double heatingRateInSecPerK = 4;
    {PROTOBUF_FIELD_OFFSET(PreheaterParams, _impl_.heatingrateinsecperk_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double roomTemperature = 5;
    {PROTOBUF_FIELD_OFFSET(PreheaterParams, _impl_.roomtemperature_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* PreheaterParams::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ManufacturingScenarioRepository.PreheaterParams)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double preheatingTemperature = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_preheatingtemperature = this->_internal_preheatingtemperature();
  ::uint64_t raw_preheatingtemperature;
  memcpy(&raw_preheatingtemperature, &tmp_preheatingtemperature, sizeof(tmp_preheatingtemperature));
  if (raw_preheatingtemperature != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_preheatingtemperature(), target);
  }

  // double maximumPreheatingTemperature = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_maximumpreheatingtemperature = this->_internal_maximumpreheatingtemperature();
  ::uint64_t raw_maximumpreheatingtemperature;
  memcpy(&raw_maximumpreheatingtemperature, &tmp_maximumpreheatingtemperature, sizeof(tmp_maximumpreheatingtemperature));
  if (raw_maximumpreheatingtemperature != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_maximumpreheatingtemperature(), target);
  }

  // double heatingRateInSecPerK = 4;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_heatingrateinsecperk = this->_internal_heatingrateinsecperk();
  ::uint64_t raw_heatingrateinsecperk;
  memcpy(&raw_heatingrateinsecperk, &tmp_heatingrateinsecperk, sizeof(tmp_heatingrateinsecperk));
  if (raw_heatingrateinsecperk != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        4, this->_internal_heatingrateinsecperk(), target);
  }

  // double roomTemperature = 5;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_roomtemperature = this->_internal_roomtemperature();
  ::uint64_t raw_roomtemperature;
  memcpy(&raw_roomtemperature, &tmp_roomtemperature, sizeof(tmp_roomtemperature));
  if (raw_roomtemperature != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        5, this->_internal_roomtemperature(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ManufacturingScenarioRepository.PreheaterParams)
  return target;
}

::size_t PreheaterParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ManufacturingScenarioRepository.PreheaterParams)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double preheatingTemperature = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_preheatingtemperature = this->_internal_preheatingtemperature();
  ::uint64_t raw_preheatingtemperature;
  memcpy(&raw_preheatingtemperature, &tmp_preheatingtemperature, sizeof(tmp_preheatingtemperature));
  if (raw_preheatingtemperature != 0) {
    total_size += 9;
  }

  // double maximumPreheatingTemperature = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_maximumpreheatingtemperature = this->_internal_maximumpreheatingtemperature();
  ::uint64_t raw_maximumpreheatingtemperature;
  memcpy(&raw_maximumpreheatingtemperature, &tmp_maximumpreheatingtemperature, sizeof(tmp_maximumpreheatingtemperature));
  if (raw_maximumpreheatingtemperature != 0) {
    total_size += 9;
  }

  // double heatingRateInSecPerK = 4;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_heatingrateinsecperk = this->_internal_heatingrateinsecperk();
  ::uint64_t raw_heatingrateinsecperk;
  memcpy(&raw_heatingrateinsecperk, &tmp_heatingrateinsecperk, sizeof(tmp_heatingrateinsecperk));
  if (raw_heatingrateinsecperk != 0) {
    total_size += 9;
  }

  // double roomTemperature = 5;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_roomtemperature = this->_internal_roomtemperature();
  ::uint64_t raw_roomtemperature;
  memcpy(&raw_roomtemperature, &tmp_roomtemperature, sizeof(tmp_roomtemperature));
  if (raw_roomtemperature != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData PreheaterParams::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    PreheaterParams::MergeImpl
};
const ::google::protobuf::Message::ClassData*PreheaterParams::GetClassData() const { return &_class_data_; }


void PreheaterParams::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<PreheaterParams*>(&to_msg);
  auto& from = static_cast<const PreheaterParams&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ManufacturingScenarioRepository.PreheaterParams)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_preheatingtemperature = from._internal_preheatingtemperature();
  ::uint64_t raw_preheatingtemperature;
  memcpy(&raw_preheatingtemperature, &tmp_preheatingtemperature, sizeof(tmp_preheatingtemperature));
  if (raw_preheatingtemperature != 0) {
    _this->_internal_set_preheatingtemperature(from._internal_preheatingtemperature());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_maximumpreheatingtemperature = from._internal_maximumpreheatingtemperature();
  ::uint64_t raw_maximumpreheatingtemperature;
  memcpy(&raw_maximumpreheatingtemperature, &tmp_maximumpreheatingtemperature, sizeof(tmp_maximumpreheatingtemperature));
  if (raw_maximumpreheatingtemperature != 0) {
    _this->_internal_set_maximumpreheatingtemperature(from._internal_maximumpreheatingtemperature());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_heatingrateinsecperk = from._internal_heatingrateinsecperk();
  ::uint64_t raw_heatingrateinsecperk;
  memcpy(&raw_heatingrateinsecperk, &tmp_heatingrateinsecperk, sizeof(tmp_heatingrateinsecperk));
  if (raw_heatingrateinsecperk != 0) {
    _this->_internal_set_heatingrateinsecperk(from._internal_heatingrateinsecperk());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_roomtemperature = from._internal_roomtemperature();
  ::uint64_t raw_roomtemperature;
  memcpy(&raw_roomtemperature, &tmp_roomtemperature, sizeof(tmp_roomtemperature));
  if (raw_roomtemperature != 0) {
    _this->_internal_set_roomtemperature(from._internal_roomtemperature());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void PreheaterParams::CopyFrom(const PreheaterParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ManufacturingScenarioRepository.PreheaterParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool PreheaterParams::IsInitialized() const {
  return true;
}

void PreheaterParams::InternalSwap(PreheaterParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PreheaterParams, _impl_.roomtemperature_)
      + sizeof(PreheaterParams::_impl_.roomtemperature_)
      - PROTOBUF_FIELD_OFFSET(PreheaterParams, _impl_.preheatingtemperature_)>(
          reinterpret_cast<char*>(&_impl_.preheatingtemperature_),
          reinterpret_cast<char*>(&other->_impl_.preheatingtemperature_));
}

::google::protobuf::Metadata PreheaterParams::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ModuleDefinition_2eproto_getter, &descriptor_table_ModuleDefinition_2eproto_once,
      file_level_metadata_ModuleDefinition_2eproto[16]);
}
// ===================================================================

class TimePerStateInMS::_Internal {
 public:
};

TimePerStateInMS::TimePerStateInMS(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ManufacturingScenarioRepository.TimePerStateInMS)
}
TimePerStateInMS::TimePerStateInMS(const TimePerStateInMS& from)
    : ::google::protobuf::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ManufacturingScenarioRepository.TimePerStateInMS)
}
inline void TimePerStateInMS::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.timeoff_){0},
      decltype(_impl_.timeidle_){0},
      decltype(_impl_.timeactive_){0},
      decltype(_impl_.timemaintenance_){0},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
TimePerStateInMS::~TimePerStateInMS() {
  // @@protoc_insertion_point(destructor:ManufacturingScenarioRepository.TimePerStateInMS)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void TimePerStateInMS::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}
void TimePerStateInMS::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void TimePerStateInMS::Clear() {
// @@protoc_insertion_point(message_clear_start:ManufacturingScenarioRepository.TimePerStateInMS)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.timeoff_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.timemaintenance_) -
      reinterpret_cast<char*>(&_impl_.timeoff_)) + sizeof(_impl_.timemaintenance_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* TimePerStateInMS::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2> TimePerStateInMS::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_TimePerStateInMS_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // double timeMaintenance = 4;
    {::_pbi::TcParser::FastF64S1,
     {33, 63, 0, PROTOBUF_FIELD_OFFSET(TimePerStateInMS, _impl_.timemaintenance_)}},
    // double timeOff = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(TimePerStateInMS, _impl_.timeoff_)}},
    // double timeIdle = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(TimePerStateInMS, _impl_.timeidle_)}},
    // double timeActive = 3;
    {::_pbi::TcParser::FastF64S1,
     {25, 63, 0, PROTOBUF_FIELD_OFFSET(TimePerStateInMS, _impl_.timeactive_)}},
  }}, {{
    65535, 65535
  }}, {{
    // double timeOff = 1;
    {PROTOBUF_FIELD_OFFSET(TimePerStateInMS, _impl_.timeoff_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double timeIdle = 2;
    {PROTOBUF_FIELD_OFFSET(TimePerStateInMS, _impl_.timeidle_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double timeActive = 3;
    {PROTOBUF_FIELD_OFFSET(TimePerStateInMS, _impl_.timeactive_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double timeMaintenance = 4;
    {PROTOBUF_FIELD_OFFSET(TimePerStateInMS, _impl_.timemaintenance_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* TimePerStateInMS::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ManufacturingScenarioRepository.TimePerStateInMS)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double timeOff = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_timeoff = this->_internal_timeoff();
  ::uint64_t raw_timeoff;
  memcpy(&raw_timeoff, &tmp_timeoff, sizeof(tmp_timeoff));
  if (raw_timeoff != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_timeoff(), target);
  }

  // double timeIdle = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_timeidle = this->_internal_timeidle();
  ::uint64_t raw_timeidle;
  memcpy(&raw_timeidle, &tmp_timeidle, sizeof(tmp_timeidle));
  if (raw_timeidle != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_timeidle(), target);
  }

  // double timeActive = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_timeactive = this->_internal_timeactive();
  ::uint64_t raw_timeactive;
  memcpy(&raw_timeactive, &tmp_timeactive, sizeof(tmp_timeactive));
  if (raw_timeactive != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_timeactive(), target);
  }

  // double timeMaintenance = 4;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_timemaintenance = this->_internal_timemaintenance();
  ::uint64_t raw_timemaintenance;
  memcpy(&raw_timemaintenance, &tmp_timemaintenance, sizeof(tmp_timemaintenance));
  if (raw_timemaintenance != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        4, this->_internal_timemaintenance(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ManufacturingScenarioRepository.TimePerStateInMS)
  return target;
}

::size_t TimePerStateInMS::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ManufacturingScenarioRepository.TimePerStateInMS)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double timeOff = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_timeoff = this->_internal_timeoff();
  ::uint64_t raw_timeoff;
  memcpy(&raw_timeoff, &tmp_timeoff, sizeof(tmp_timeoff));
  if (raw_timeoff != 0) {
    total_size += 9;
  }

  // double timeIdle = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_timeidle = this->_internal_timeidle();
  ::uint64_t raw_timeidle;
  memcpy(&raw_timeidle, &tmp_timeidle, sizeof(tmp_timeidle));
  if (raw_timeidle != 0) {
    total_size += 9;
  }

  // double timeActive = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_timeactive = this->_internal_timeactive();
  ::uint64_t raw_timeactive;
  memcpy(&raw_timeactive, &tmp_timeactive, sizeof(tmp_timeactive));
  if (raw_timeactive != 0) {
    total_size += 9;
  }

  // double timeMaintenance = 4;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_timemaintenance = this->_internal_timemaintenance();
  ::uint64_t raw_timemaintenance;
  memcpy(&raw_timemaintenance, &tmp_timemaintenance, sizeof(tmp_timemaintenance));
  if (raw_timemaintenance != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData TimePerStateInMS::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    TimePerStateInMS::MergeImpl
};
const ::google::protobuf::Message::ClassData*TimePerStateInMS::GetClassData() const { return &_class_data_; }


void TimePerStateInMS::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<TimePerStateInMS*>(&to_msg);
  auto& from = static_cast<const TimePerStateInMS&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ManufacturingScenarioRepository.TimePerStateInMS)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_timeoff = from._internal_timeoff();
  ::uint64_t raw_timeoff;
  memcpy(&raw_timeoff, &tmp_timeoff, sizeof(tmp_timeoff));
  if (raw_timeoff != 0) {
    _this->_internal_set_timeoff(from._internal_timeoff());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_timeidle = from._internal_timeidle();
  ::uint64_t raw_timeidle;
  memcpy(&raw_timeidle, &tmp_timeidle, sizeof(tmp_timeidle));
  if (raw_timeidle != 0) {
    _this->_internal_set_timeidle(from._internal_timeidle());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_timeactive = from._internal_timeactive();
  ::uint64_t raw_timeactive;
  memcpy(&raw_timeactive, &tmp_timeactive, sizeof(tmp_timeactive));
  if (raw_timeactive != 0) {
    _this->_internal_set_timeactive(from._internal_timeactive());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_timemaintenance = from._internal_timemaintenance();
  ::uint64_t raw_timemaintenance;
  memcpy(&raw_timemaintenance, &tmp_timemaintenance, sizeof(tmp_timemaintenance));
  if (raw_timemaintenance != 0) {
    _this->_internal_set_timemaintenance(from._internal_timemaintenance());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void TimePerStateInMS::CopyFrom(const TimePerStateInMS& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ManufacturingScenarioRepository.TimePerStateInMS)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool TimePerStateInMS::IsInitialized() const {
  return true;
}

void TimePerStateInMS::InternalSwap(TimePerStateInMS* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TimePerStateInMS, _impl_.timemaintenance_)
      + sizeof(TimePerStateInMS::_impl_.timemaintenance_)
      - PROTOBUF_FIELD_OFFSET(TimePerStateInMS, _impl_.timeoff_)>(
          reinterpret_cast<char*>(&_impl_.timeoff_),
          reinterpret_cast<char*>(&other->_impl_.timeoff_));
}

::google::protobuf::Metadata TimePerStateInMS::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ModuleDefinition_2eproto_getter, &descriptor_table_ModuleDefinition_2eproto_once,
      file_level_metadata_ModuleDefinition_2eproto[17]);
}
// ===================================================================

class EnergyUsePerStateInkWh::_Internal {
 public:
};

EnergyUsePerStateInkWh::EnergyUsePerStateInkWh(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ManufacturingScenarioRepository.EnergyUsePerStateInkWh)
}
EnergyUsePerStateInkWh::EnergyUsePerStateInkWh(const EnergyUsePerStateInkWh& from)
    : ::google::protobuf::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ManufacturingScenarioRepository.EnergyUsePerStateInkWh)
}
inline void EnergyUsePerStateInkWh::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.energyoff_){0},
      decltype(_impl_.energyidle_){0},
      decltype(_impl_.energyactive_){0},
      decltype(_impl_.energymaintenance_){0},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
EnergyUsePerStateInkWh::~EnergyUsePerStateInkWh() {
  // @@protoc_insertion_point(destructor:ManufacturingScenarioRepository.EnergyUsePerStateInkWh)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void EnergyUsePerStateInkWh::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}
void EnergyUsePerStateInkWh::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void EnergyUsePerStateInkWh::Clear() {
// @@protoc_insertion_point(message_clear_start:ManufacturingScenarioRepository.EnergyUsePerStateInkWh)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.energyoff_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.energymaintenance_) -
      reinterpret_cast<char*>(&_impl_.energyoff_)) + sizeof(_impl_.energymaintenance_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* EnergyUsePerStateInkWh::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2> EnergyUsePerStateInkWh::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_EnergyUsePerStateInkWh_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // double energyMaintenance = 4;
    {::_pbi::TcParser::FastF64S1,
     {33, 63, 0, PROTOBUF_FIELD_OFFSET(EnergyUsePerStateInkWh, _impl_.energymaintenance_)}},
    // double energyOff = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(EnergyUsePerStateInkWh, _impl_.energyoff_)}},
    // double energyIdle = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(EnergyUsePerStateInkWh, _impl_.energyidle_)}},
    // double energyActive = 3;
    {::_pbi::TcParser::FastF64S1,
     {25, 63, 0, PROTOBUF_FIELD_OFFSET(EnergyUsePerStateInkWh, _impl_.energyactive_)}},
  }}, {{
    65535, 65535
  }}, {{
    // double energyOff = 1;
    {PROTOBUF_FIELD_OFFSET(EnergyUsePerStateInkWh, _impl_.energyoff_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double energyIdle = 2;
    {PROTOBUF_FIELD_OFFSET(EnergyUsePerStateInkWh, _impl_.energyidle_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double energyActive = 3;
    {PROTOBUF_FIELD_OFFSET(EnergyUsePerStateInkWh, _impl_.energyactive_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double energyMaintenance = 4;
    {PROTOBUF_FIELD_OFFSET(EnergyUsePerStateInkWh, _impl_.energymaintenance_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* EnergyUsePerStateInkWh::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ManufacturingScenarioRepository.EnergyUsePerStateInkWh)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double energyOff = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_energyoff = this->_internal_energyoff();
  ::uint64_t raw_energyoff;
  memcpy(&raw_energyoff, &tmp_energyoff, sizeof(tmp_energyoff));
  if (raw_energyoff != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_energyoff(), target);
  }

  // double energyIdle = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_energyidle = this->_internal_energyidle();
  ::uint64_t raw_energyidle;
  memcpy(&raw_energyidle, &tmp_energyidle, sizeof(tmp_energyidle));
  if (raw_energyidle != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_energyidle(), target);
  }

  // double energyActive = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_energyactive = this->_internal_energyactive();
  ::uint64_t raw_energyactive;
  memcpy(&raw_energyactive, &tmp_energyactive, sizeof(tmp_energyactive));
  if (raw_energyactive != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_energyactive(), target);
  }

  // double energyMaintenance = 4;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_energymaintenance = this->_internal_energymaintenance();
  ::uint64_t raw_energymaintenance;
  memcpy(&raw_energymaintenance, &tmp_energymaintenance, sizeof(tmp_energymaintenance));
  if (raw_energymaintenance != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        4, this->_internal_energymaintenance(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ManufacturingScenarioRepository.EnergyUsePerStateInkWh)
  return target;
}

::size_t EnergyUsePerStateInkWh::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ManufacturingScenarioRepository.EnergyUsePerStateInkWh)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double energyOff = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_energyoff = this->_internal_energyoff();
  ::uint64_t raw_energyoff;
  memcpy(&raw_energyoff, &tmp_energyoff, sizeof(tmp_energyoff));
  if (raw_energyoff != 0) {
    total_size += 9;
  }

  // double energyIdle = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_energyidle = this->_internal_energyidle();
  ::uint64_t raw_energyidle;
  memcpy(&raw_energyidle, &tmp_energyidle, sizeof(tmp_energyidle));
  if (raw_energyidle != 0) {
    total_size += 9;
  }

  // double energyActive = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_energyactive = this->_internal_energyactive();
  ::uint64_t raw_energyactive;
  memcpy(&raw_energyactive, &tmp_energyactive, sizeof(tmp_energyactive));
  if (raw_energyactive != 0) {
    total_size += 9;
  }

  // double energyMaintenance = 4;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_energymaintenance = this->_internal_energymaintenance();
  ::uint64_t raw_energymaintenance;
  memcpy(&raw_energymaintenance, &tmp_energymaintenance, sizeof(tmp_energymaintenance));
  if (raw_energymaintenance != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData EnergyUsePerStateInkWh::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    EnergyUsePerStateInkWh::MergeImpl
};
const ::google::protobuf::Message::ClassData*EnergyUsePerStateInkWh::GetClassData() const { return &_class_data_; }


void EnergyUsePerStateInkWh::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<EnergyUsePerStateInkWh*>(&to_msg);
  auto& from = static_cast<const EnergyUsePerStateInkWh&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ManufacturingScenarioRepository.EnergyUsePerStateInkWh)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_energyoff = from._internal_energyoff();
  ::uint64_t raw_energyoff;
  memcpy(&raw_energyoff, &tmp_energyoff, sizeof(tmp_energyoff));
  if (raw_energyoff != 0) {
    _this->_internal_set_energyoff(from._internal_energyoff());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_energyidle = from._internal_energyidle();
  ::uint64_t raw_energyidle;
  memcpy(&raw_energyidle, &tmp_energyidle, sizeof(tmp_energyidle));
  if (raw_energyidle != 0) {
    _this->_internal_set_energyidle(from._internal_energyidle());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_energyactive = from._internal_energyactive();
  ::uint64_t raw_energyactive;
  memcpy(&raw_energyactive, &tmp_energyactive, sizeof(tmp_energyactive));
  if (raw_energyactive != 0) {
    _this->_internal_set_energyactive(from._internal_energyactive());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_energymaintenance = from._internal_energymaintenance();
  ::uint64_t raw_energymaintenance;
  memcpy(&raw_energymaintenance, &tmp_energymaintenance, sizeof(tmp_energymaintenance));
  if (raw_energymaintenance != 0) {
    _this->_internal_set_energymaintenance(from._internal_energymaintenance());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void EnergyUsePerStateInkWh::CopyFrom(const EnergyUsePerStateInkWh& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ManufacturingScenarioRepository.EnergyUsePerStateInkWh)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool EnergyUsePerStateInkWh::IsInitialized() const {
  return true;
}

void EnergyUsePerStateInkWh::InternalSwap(EnergyUsePerStateInkWh* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EnergyUsePerStateInkWh, _impl_.energymaintenance_)
      + sizeof(EnergyUsePerStateInkWh::_impl_.energymaintenance_)
      - PROTOBUF_FIELD_OFFSET(EnergyUsePerStateInkWh, _impl_.energyoff_)>(
          reinterpret_cast<char*>(&_impl_.energyoff_),
          reinterpret_cast<char*>(&other->_impl_.energyoff_));
}

::google::protobuf::Metadata EnergyUsePerStateInkWh::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ModuleDefinition_2eproto_getter, &descriptor_table_ModuleDefinition_2eproto_once,
      file_level_metadata_ModuleDefinition_2eproto[18]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace ManufacturingScenarioRepository
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
