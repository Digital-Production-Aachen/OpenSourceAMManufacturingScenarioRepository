// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: open_vector_format.proto

#include "open_vector_format.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
#include "google/protobuf/generated_message_tctable_impl.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace open_vector_format {
      template <typename>
PROTOBUF_CONSTEXPR Job_MarkingParamsMapEntry_DoNotUse::Job_MarkingParamsMapEntry_DoNotUse(::_pbi::ConstantInitialized) {}
struct Job_MarkingParamsMapEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Job_MarkingParamsMapEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Job_MarkingParamsMapEntry_DoNotUseDefaultTypeInternal() {}
  union {
    Job_MarkingParamsMapEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Job_MarkingParamsMapEntry_DoNotUseDefaultTypeInternal _Job_MarkingParamsMapEntry_DoNotUse_default_instance_;
      template <typename>
PROTOBUF_CONSTEXPR Job_PartsMapEntry_DoNotUse::Job_PartsMapEntry_DoNotUse(::_pbi::ConstantInitialized) {}
struct Job_PartsMapEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Job_PartsMapEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Job_PartsMapEntry_DoNotUseDefaultTypeInternal() {}
  union {
    Job_PartsMapEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Job_PartsMapEntry_DoNotUseDefaultTypeInternal _Job_PartsMapEntry_DoNotUse_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR Job_JobMetaData::Job_JobMetaData(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.job_name_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.author_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.description_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.bounds_)*/ nullptr,
      /*decltype(_impl_.job_creation_time_)*/ ::int64_t{0},
      /*decltype(_impl_.version_)*/ ::uint64_t{0u},
    } {}
struct Job_JobMetaDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Job_JobMetaDataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Job_JobMetaDataDefaultTypeInternal() {}
  union {
    Job_JobMetaData _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Job_JobMetaDataDefaultTypeInternal _Job_JobMetaData_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR Job::Job(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.work_planes_)*/ {},
      /* decltype(_impl_.marking_params_map_) */ {},
      /* decltype(_impl_.parts_map_) */ {},
      /*decltype(_impl_.job_meta_data_)*/ nullptr,
      /*decltype(_impl_.job_parameters_)*/ nullptr,
      /*decltype(_impl_.num_work_planes_)*/ 0,
    } {}
struct JobDefaultTypeInternal {
  PROTOBUF_CONSTEXPR JobDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~JobDefaultTypeInternal() {}
  union {
    Job _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 JobDefaultTypeInternal _Job_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR JobParameters::JobParameters(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.shielding_gas_directions_)*/ {},
      /*decltype(_impl_.material_feed_directions_)*/ {},
      /*decltype(_impl_.preheating_temperatur_in_dg_c_)*/ 0,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct JobParametersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR JobParametersDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~JobParametersDefaultTypeInternal() {}
  union {
    JobParameters _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 JobParametersDefaultTypeInternal _JobParameters_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR MarkingParams::MarkingParams(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.name_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.powergradient_)*/ nullptr,
      /*decltype(_impl_.laser_power_in_w_)*/ 0,
      /*decltype(_impl_.laser_speed_in_mm_per_s_)*/ 0,
      /*decltype(_impl_.laser_focus_shift_in_mm_)*/ 0,
      /*decltype(_impl_.point_exposure_time_in_us_)*/ 0,
      /*decltype(_impl_.jump_speed_in_mm_s_)*/ 0,
      /*decltype(_impl_.point_exposure_repetitions_)*/ 0,
      /*decltype(_impl_.repetition_rate_in_hz_)*/ ::uint64_t{0u},
      /*decltype(_impl_.laser_pulses_per_burst_)*/ ::uint64_t{0u},
      /*decltype(_impl_.pulsedurationinfemtoseconds_)*/ ::uint64_t{0u},
      /*decltype(_impl_.marking_mode_)*/ 0,
      /*decltype(_impl_.jump_delay_in_us_)*/ 0,
      /*decltype(_impl_.laser_off_delay_in_us_)*/ 0,
      /*decltype(_impl_.laser_on_delay_in_us_)*/ 0,
      /*decltype(_impl_.mark_delay_in_us_)*/ 0,
      /*decltype(_impl_.polygon_delay_in_us_)*/ 0,
      /*decltype(_impl_.time_lag_in_us_)*/ 0,
      /*decltype(_impl_.laser_on_shift_in_us_)*/ 0,
      /*decltype(_impl_.limit_)*/ 0,
      /*decltype(_impl_.n_prev_in_us_)*/ 0,
      /*decltype(_impl_.n_post_in_us_)*/ 0,
      /*decltype(_impl_.wob_frequency_in_hz_)*/ 0,
      /*decltype(_impl_.wob_amp_long_in_mm_)*/ 0,
      /*decltype(_impl_.wob_amp_trans_in_mm_)*/ 0,
      /*decltype(_impl_.wobble_mode_)*/ 0,
    } {}
struct MarkingParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MarkingParamsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MarkingParamsDefaultTypeInternal() {}
  union {
    MarkingParams _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MarkingParamsDefaultTypeInternal _MarkingParams_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR PowerGradientParams::PowerGradientParams(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.minpowerinw_)*/ 0,
      /*decltype(_impl_.gradientinwpers_)*/ 0,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct PowerGradientParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PowerGradientParamsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PowerGradientParamsDefaultTypeInternal() {}
  union {
    PowerGradientParams _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PowerGradientParamsDefaultTypeInternal _PowerGradientParams_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR Part_GeometryInfo::Part_GeometryInfo(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.volume_in_mm3_)*/ 0,
      /*decltype(_impl_.support_volume_in_mm3_)*/ 0,
      /*decltype(_impl_.build_height_in_mm_)*/ 0,
      /*decltype(_impl_.surface_area_in_mm2_)*/ 0,
      /*decltype(_impl_.projected_surface_in_mm2_)*/ 0,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct Part_GeometryInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Part_GeometryInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Part_GeometryInfoDefaultTypeInternal() {}
  union {
    Part_GeometryInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Part_GeometryInfoDefaultTypeInternal _Part_GeometryInfo_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR Part_Material::Part_Material(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.name_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.id_)*/ ::uint64_t{0u},
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct Part_MaterialDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Part_MaterialDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Part_MaterialDefaultTypeInternal() {}
  union {
    Part_Material _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Part_MaterialDefaultTypeInternal _Part_Material_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR Part_ProcessStrategy_ProprietaryParam::Part_ProcessStrategy_ProprietaryParam(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.param_name_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.param_description_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.param_value_)*/ 0,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct Part_ProcessStrategy_ProprietaryParamDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Part_ProcessStrategy_ProprietaryParamDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Part_ProcessStrategy_ProprietaryParamDefaultTypeInternal() {}
  union {
    Part_ProcessStrategy_ProprietaryParam _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Part_ProcessStrategy_ProprietaryParamDefaultTypeInternal _Part_ProcessStrategy_ProprietaryParam_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR Part_ProcessStrategy::Part_ProcessStrategy(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.additional_parameters_)*/ {},
      /*decltype(_impl_.name_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.rot_angle_in_deg_)*/ 0,
      /*decltype(_impl_.increment_angle_in_deg_)*/ 0,
      /*decltype(_impl_.shift_in_mm_)*/ 0,
      /*decltype(_impl_.extend_into_in_mm_)*/ 0,
      /*decltype(_impl_.layer_thickness_in_mm_)*/ 0,
      /*decltype(_impl_.hatch_distance_in_mm_)*/ 0,
      /*decltype(_impl_.hatch_contour_distance_in_mm_)*/ 0,
      /*decltype(_impl_.overhang_angle_in_deg_)*/ 0,
      /*decltype(_impl_.contour_offset_in_mm_)*/ 0,
      /*decltype(_impl_.number_of_contours_)*/ 0,
      /*decltype(_impl_.contour_distance_in_mm_)*/ 0,
      /*decltype(_impl_.hatching_pattern_)*/ 0,
      /*decltype(_impl_.pattern_hatch_length_in_mm_)*/ 0,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct Part_ProcessStrategyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Part_ProcessStrategyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Part_ProcessStrategyDefaultTypeInternal() {}
  union {
    Part_ProcessStrategy _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Part_ProcessStrategyDefaultTypeInternal _Part_ProcessStrategy_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR Part::Part(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.exposure_order_)*/ {},
      /*decltype(_impl_.name_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.parent_part_name_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.geometry_info_)*/ nullptr,
      /*decltype(_impl_.material_)*/ nullptr,
      /*decltype(_impl_.process_strategy_)*/ nullptr,
      /*decltype(_impl_.up_skin_process_strategy_)*/ nullptr,
      /*decltype(_impl_.down_skin_process_strategy_)*/ nullptr,
    } {}
struct PartDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PartDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PartDefaultTypeInternal() {}
  union {
    Part _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PartDefaultTypeInternal _Part_default_instance_;
      template <typename>
PROTOBUF_CONSTEXPR WorkPlane_WorkPlaneMetaData_PatchesMapEntry_DoNotUse::WorkPlane_WorkPlaneMetaData_PatchesMapEntry_DoNotUse(::_pbi::ConstantInitialized) {}
struct WorkPlane_WorkPlaneMetaData_PatchesMapEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WorkPlane_WorkPlaneMetaData_PatchesMapEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~WorkPlane_WorkPlaneMetaData_PatchesMapEntry_DoNotUseDefaultTypeInternal() {}
  union {
    WorkPlane_WorkPlaneMetaData_PatchesMapEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WorkPlane_WorkPlaneMetaData_PatchesMapEntry_DoNotUseDefaultTypeInternal _WorkPlane_WorkPlaneMetaData_PatchesMapEntry_DoNotUse_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR WorkPlane_WorkPlaneMetaData_closedContour::WorkPlane_WorkPlaneMetaData_closedContour(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.contour_section_vector_block_indices_)*/ {},
      /* _impl_._contour_section_vector_block_indices_cached_byte_size_ = */ {0},
      /*decltype(_impl_.area_in_mm_2_)*/ 0,
      /*decltype(_impl_.length_in_mm_)*/ 0,
      /*decltype(_impl_.parent_index_)*/ 0,
      /*decltype(_impl_.winding_number_)*/ 0,
      /*decltype(_impl_.type_)*/ 0,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct WorkPlane_WorkPlaneMetaData_closedContourDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WorkPlane_WorkPlaneMetaData_closedContourDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~WorkPlane_WorkPlaneMetaData_closedContourDefaultTypeInternal() {}
  union {
    WorkPlane_WorkPlaneMetaData_closedContour _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WorkPlane_WorkPlaneMetaData_closedContourDefaultTypeInternal _WorkPlane_WorkPlaneMetaData_closedContour_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR WorkPlane_WorkPlaneMetaData::WorkPlane_WorkPlaneMetaData(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /* decltype(_impl_.patches_map_) */ {},
      /*decltype(_impl_.contours_)*/ {},
      /*decltype(_impl_.bounds_)*/ nullptr,
      /*decltype(_impl_.total_scan_distance_in_mm_)*/ 0,
      /*decltype(_impl_.total_jump_distance_in_mm_)*/ 0,
      /*decltype(_impl_.maxpower_)*/ 0,
      /*decltype(_impl_.minpower_)*/ 0,
    } {}
struct WorkPlane_WorkPlaneMetaDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WorkPlane_WorkPlaneMetaDataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~WorkPlane_WorkPlaneMetaDataDefaultTypeInternal() {}
  union {
    WorkPlane_WorkPlaneMetaData _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WorkPlane_WorkPlaneMetaDataDefaultTypeInternal _WorkPlane_WorkPlaneMetaData_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR WorkPlane_Patch::WorkPlane_Patch(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.outer_contour_)*/ nullptr,
      /*decltype(_impl_.u_)*/ 0,
      /*decltype(_impl_.v_)*/ 0,
      /*decltype(_impl_.layer_id_)*/ 0,
    } {}
struct WorkPlane_PatchDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WorkPlane_PatchDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~WorkPlane_PatchDefaultTypeInternal() {}
  union {
    WorkPlane_Patch _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WorkPlane_PatchDefaultTypeInternal _WorkPlane_Patch_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR WorkPlane::WorkPlane(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.vector_blocks_)*/ {},
      /*decltype(_impl_.additional_axis_positions_)*/ {},
      /*decltype(_impl_.machine_type_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.meta_data_)*/ nullptr,
      /*decltype(_impl_.x_pos_in_mm_)*/ 0,
      /*decltype(_impl_.y_pos_in_mm_)*/ 0,
      /*decltype(_impl_.z_pos_in_mm_)*/ 0,
      /*decltype(_impl_.x_rot_in_deg_)*/ 0,
      /*decltype(_impl_.y_rot_in_deg_)*/ 0,
      /*decltype(_impl_.z_rot_in_deg_)*/ 0,
      /*decltype(_impl_.num_blocks_)*/ 0,
      /*decltype(_impl_.repeats_)*/ 0u,
      /*decltype(_impl_.work_plane_number_)*/ 0,
    } {}
struct WorkPlaneDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WorkPlaneDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~WorkPlaneDefaultTypeInternal() {}
  union {
    WorkPlane _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WorkPlaneDefaultTypeInternal _WorkPlane_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR VectorBlock_VectorBlockMetaData::VectorBlock_VectorBlockMetaData(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.bounds_)*/ nullptr,
      /*decltype(_impl_.total_scan_distance_in_mm_)*/ 0,
      /*decltype(_impl_.total_jump_distance_in_mm_)*/ 0,
      /*decltype(_impl_.part_key_)*/ 0,
      /*decltype(_impl_.patch_key_)*/ 0,
      /*decltype(_impl_.contour_index_)*/ 0,
      /*decltype(_impl_.display_color_)*/ 0,
    } {}
struct VectorBlock_VectorBlockMetaDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VectorBlock_VectorBlockMetaDataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VectorBlock_VectorBlockMetaDataDefaultTypeInternal() {}
  union {
    VectorBlock_VectorBlockMetaData _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VectorBlock_VectorBlockMetaDataDefaultTypeInternal _VectorBlock_VectorBlockMetaData_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR VectorBlock_LPBFMetadata::VectorBlock_LPBFMetadata(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.part_area_)*/ 0,
      /*decltype(_impl_.skin_type_)*/ 0,
      /*decltype(_impl_.skin_core_strategy_area_)*/ 0,
      /*decltype(_impl_.structure_type_)*/ 0,
      /*decltype(_impl_.reexposure_)*/ false,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct VectorBlock_LPBFMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VectorBlock_LPBFMetadataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VectorBlock_LPBFMetadataDefaultTypeInternal() {}
  union {
    VectorBlock_LPBFMetadata _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VectorBlock_LPBFMetadataDefaultTypeInternal _VectorBlock_LPBFMetadata_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR VectorBlock_MicroStructuringMetadata::VectorBlock_MicroStructuringMetadata(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.part_area_)*/ 0,
      /*decltype(_impl_.structure_type_)*/ 0,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct VectorBlock_MicroStructuringMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VectorBlock_MicroStructuringMetadataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VectorBlock_MicroStructuringMetadataDefaultTypeInternal() {}
  union {
    VectorBlock_MicroStructuringMetadata _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VectorBlock_MicroStructuringMetadataDefaultTypeInternal _VectorBlock_MicroStructuringMetadata_default_instance_;
      template <typename>
PROTOBUF_CONSTEXPR VectorBlock_PolishingMetadata::VectorBlock_PolishingMetadata(::_pbi::ConstantInitialized) {}
struct VectorBlock_PolishingMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VectorBlock_PolishingMetadataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VectorBlock_PolishingMetadataDefaultTypeInternal() {}
  union {
    VectorBlock_PolishingMetadata _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VectorBlock_PolishingMetadataDefaultTypeInternal _VectorBlock_PolishingMetadata_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR VectorBlock_LineSequence::VectorBlock_LineSequence(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.points_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct VectorBlock_LineSequenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VectorBlock_LineSequenceDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VectorBlock_LineSequenceDefaultTypeInternal() {}
  union {
    VectorBlock_LineSequence _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VectorBlock_LineSequenceDefaultTypeInternal _VectorBlock_LineSequence_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR VectorBlock_LineSequence3D::VectorBlock_LineSequence3D(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.points_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct VectorBlock_LineSequence3DDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VectorBlock_LineSequence3DDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VectorBlock_LineSequence3DDefaultTypeInternal() {}
  union {
    VectorBlock_LineSequence3D _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VectorBlock_LineSequence3DDefaultTypeInternal _VectorBlock_LineSequence3D_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR VectorBlock_Hatches::VectorBlock_Hatches(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.points_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct VectorBlock_HatchesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VectorBlock_HatchesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VectorBlock_HatchesDefaultTypeInternal() {}
  union {
    VectorBlock_Hatches _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VectorBlock_HatchesDefaultTypeInternal _VectorBlock_Hatches_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR VectorBlock_Hatches3D::VectorBlock_Hatches3D(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.points_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct VectorBlock_Hatches3DDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VectorBlock_Hatches3DDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VectorBlock_Hatches3DDefaultTypeInternal() {}
  union {
    VectorBlock_Hatches3D _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VectorBlock_Hatches3DDefaultTypeInternal _VectorBlock_Hatches3D_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR VectorBlock_PointSequence::VectorBlock_PointSequence(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.points_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct VectorBlock_PointSequenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VectorBlock_PointSequenceDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VectorBlock_PointSequenceDefaultTypeInternal() {}
  union {
    VectorBlock_PointSequence _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VectorBlock_PointSequenceDefaultTypeInternal _VectorBlock_PointSequence_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR VectorBlock_PointSequence3D::VectorBlock_PointSequence3D(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.points_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct VectorBlock_PointSequence3DDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VectorBlock_PointSequence3DDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VectorBlock_PointSequence3DDefaultTypeInternal() {}
  union {
    VectorBlock_PointSequence3D _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VectorBlock_PointSequence3DDefaultTypeInternal _VectorBlock_PointSequence3D_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR VectorBlock_Arcs::VectorBlock_Arcs(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.centers_)*/ {},
      /*decltype(_impl_.angle_)*/ 0,
      /*decltype(_impl_.start_dx_)*/ 0,
      /*decltype(_impl_.start_dy_)*/ 0,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct VectorBlock_ArcsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VectorBlock_ArcsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VectorBlock_ArcsDefaultTypeInternal() {}
  union {
    VectorBlock_Arcs _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VectorBlock_ArcsDefaultTypeInternal _VectorBlock_Arcs_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR VectorBlock_Arcs3D::VectorBlock_Arcs3D(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.centers_)*/ {},
      /*decltype(_impl_.angle_)*/ 0,
      /*decltype(_impl_.start_dx_)*/ 0,
      /*decltype(_impl_.start_dy_)*/ 0,
      /*decltype(_impl_.start_dz_)*/ 0,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct VectorBlock_Arcs3DDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VectorBlock_Arcs3DDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VectorBlock_Arcs3DDefaultTypeInternal() {}
  union {
    VectorBlock_Arcs3D _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VectorBlock_Arcs3DDefaultTypeInternal _VectorBlock_Arcs3D_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR VectorBlock_Ellipses::VectorBlock_Ellipses(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.ellipses_arcs_)*/ nullptr,
      /*decltype(_impl_.a_)*/ 0,
      /*decltype(_impl_.b_)*/ 0,
      /*decltype(_impl_.phi0_)*/ 0,
    } {}
struct VectorBlock_EllipsesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VectorBlock_EllipsesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VectorBlock_EllipsesDefaultTypeInternal() {}
  union {
    VectorBlock_Ellipses _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VectorBlock_EllipsesDefaultTypeInternal _VectorBlock_Ellipses_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR VectorBlock_ExposurePause::VectorBlock_ExposurePause(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.pause_in_us_)*/ ::uint64_t{0u},
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct VectorBlock_ExposurePauseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VectorBlock_ExposurePauseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VectorBlock_ExposurePauseDefaultTypeInternal() {}
  union {
    VectorBlock_ExposurePause _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VectorBlock_ExposurePauseDefaultTypeInternal _VectorBlock_ExposurePause_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR VectorBlock_LineSequenceParaAdapt::VectorBlock_LineSequenceParaAdapt(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.points_with_paras_)*/ {},
      /*decltype(_impl_.parameter_)*/ 0,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct VectorBlock_LineSequenceParaAdaptDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VectorBlock_LineSequenceParaAdaptDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VectorBlock_LineSequenceParaAdaptDefaultTypeInternal() {}
  union {
    VectorBlock_LineSequenceParaAdapt _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VectorBlock_LineSequenceParaAdaptDefaultTypeInternal _VectorBlock_LineSequenceParaAdapt_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR VectorBlock_HatchesParaAdapt::VectorBlock_HatchesParaAdapt(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.hatchaslinesequence_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct VectorBlock_HatchesParaAdaptDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VectorBlock_HatchesParaAdaptDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VectorBlock_HatchesParaAdaptDefaultTypeInternal() {}
  union {
    VectorBlock_HatchesParaAdapt _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VectorBlock_HatchesParaAdaptDefaultTypeInternal _VectorBlock_HatchesParaAdapt_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR VectorBlock::VectorBlock(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.meta_data_)*/ nullptr,
      /*decltype(_impl_.marking_params_key_)*/ 0,
      /*decltype(_impl_.laser_index_)*/ 0,
      /*decltype(_impl_.repeats_)*/ ::uint64_t{0u},
      /*decltype(_impl_.vector_data_)*/ {},
      /*decltype(_impl_.process_meta_data_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
    } {}
struct VectorBlockDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VectorBlockDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VectorBlockDefaultTypeInternal() {}
  union {
    VectorBlock _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VectorBlockDefaultTypeInternal _VectorBlock_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR AxisAlignedBox2D::AxisAlignedBox2D(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.x_min_)*/ 0,
      /*decltype(_impl_.y_min_)*/ 0,
      /*decltype(_impl_.x_max_)*/ 0,
      /*decltype(_impl_.y_max_)*/ 0,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct AxisAlignedBox2DDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AxisAlignedBox2DDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AxisAlignedBox2DDefaultTypeInternal() {}
  union {
    AxisAlignedBox2D _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AxisAlignedBox2DDefaultTypeInternal _AxisAlignedBox2D_default_instance_;
}  // namespace open_vector_format
static ::_pb::Metadata file_level_metadata_open_5fvector_5fformat_2eproto[35];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_open_5fvector_5fformat_2eproto[9];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_open_5fvector_5fformat_2eproto = nullptr;
const ::uint32_t TableStruct_open_5fvector_5fformat_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Job_MarkingParamsMapEntry_DoNotUse, _has_bits_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Job_MarkingParamsMapEntry_DoNotUse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Job_MarkingParamsMapEntry_DoNotUse, key_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Job_MarkingParamsMapEntry_DoNotUse, value_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Job_PartsMapEntry_DoNotUse, _has_bits_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Job_PartsMapEntry_DoNotUse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Job_PartsMapEntry_DoNotUse, key_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Job_PartsMapEntry_DoNotUse, value_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Job_JobMetaData, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Job_JobMetaData, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Job_JobMetaData, _impl_.job_creation_time_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Job_JobMetaData, _impl_.version_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Job_JobMetaData, _impl_.job_name_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Job_JobMetaData, _impl_.author_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Job_JobMetaData, _impl_.description_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Job_JobMetaData, _impl_.bounds_),
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    0,
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Job, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Job, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Job, _impl_.work_planes_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Job, _impl_.job_meta_data_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Job, _impl_.marking_params_map_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Job, _impl_.parts_map_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Job, _impl_.job_parameters_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Job, _impl_.num_work_planes_),
    ~0u,
    0,
    ~0u,
    ~0u,
    1,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::open_vector_format::JobParameters, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::open_vector_format::JobParameters, _impl_.preheating_temperatur_in_dg_c_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::JobParameters, _impl_.shielding_gas_directions_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::JobParameters, _impl_.material_feed_directions_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::MarkingParams, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::MarkingParams, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::open_vector_format::MarkingParams, _impl_.laser_power_in_w_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::MarkingParams, _impl_.laser_speed_in_mm_per_s_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::MarkingParams, _impl_.laser_focus_shift_in_mm_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::MarkingParams, _impl_.point_exposure_time_in_us_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::MarkingParams, _impl_.jump_speed_in_mm_s_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::MarkingParams, _impl_.point_exposure_repetitions_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::MarkingParams, _impl_.repetition_rate_in_hz_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::MarkingParams, _impl_.laser_pulses_per_burst_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::MarkingParams, _impl_.pulsedurationinfemtoseconds_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::MarkingParams, _impl_.marking_mode_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::MarkingParams, _impl_.jump_delay_in_us_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::MarkingParams, _impl_.laser_off_delay_in_us_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::MarkingParams, _impl_.laser_on_delay_in_us_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::MarkingParams, _impl_.mark_delay_in_us_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::MarkingParams, _impl_.polygon_delay_in_us_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::MarkingParams, _impl_.time_lag_in_us_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::MarkingParams, _impl_.laser_on_shift_in_us_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::MarkingParams, _impl_.limit_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::MarkingParams, _impl_.n_prev_in_us_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::MarkingParams, _impl_.n_post_in_us_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::MarkingParams, _impl_.wob_frequency_in_hz_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::MarkingParams, _impl_.wob_amp_long_in_mm_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::MarkingParams, _impl_.wob_amp_trans_in_mm_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::MarkingParams, _impl_.wobble_mode_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::MarkingParams, _impl_.powergradient_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::MarkingParams, _impl_.name_),
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    0,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::open_vector_format::PowerGradientParams, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::open_vector_format::PowerGradientParams, _impl_.minpowerinw_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::PowerGradientParams, _impl_.gradientinwpers_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part_GeometryInfo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part_GeometryInfo, _impl_.volume_in_mm3_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part_GeometryInfo, _impl_.support_volume_in_mm3_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part_GeometryInfo, _impl_.build_height_in_mm_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part_GeometryInfo, _impl_.surface_area_in_mm2_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part_GeometryInfo, _impl_.projected_surface_in_mm2_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part_Material, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part_Material, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part_Material, _impl_.name_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part_ProcessStrategy_ProprietaryParam, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part_ProcessStrategy_ProprietaryParam, _impl_.param_name_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part_ProcessStrategy_ProprietaryParam, _impl_.param_value_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part_ProcessStrategy_ProprietaryParam, _impl_.param_description_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part_ProcessStrategy, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part_ProcessStrategy, _impl_.rot_angle_in_deg_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part_ProcessStrategy, _impl_.increment_angle_in_deg_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part_ProcessStrategy, _impl_.shift_in_mm_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part_ProcessStrategy, _impl_.extend_into_in_mm_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part_ProcessStrategy, _impl_.pattern_hatch_length_in_mm_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part_ProcessStrategy, _impl_.hatching_pattern_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part_ProcessStrategy, _impl_.layer_thickness_in_mm_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part_ProcessStrategy, _impl_.hatch_distance_in_mm_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part_ProcessStrategy, _impl_.hatch_contour_distance_in_mm_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part_ProcessStrategy, _impl_.overhang_angle_in_deg_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part_ProcessStrategy, _impl_.contour_offset_in_mm_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part_ProcessStrategy, _impl_.number_of_contours_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part_ProcessStrategy, _impl_.contour_distance_in_mm_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part_ProcessStrategy, _impl_.name_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part_ProcessStrategy, _impl_.additional_parameters_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part, _impl_.name_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part, _impl_.geometry_info_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part, _impl_.material_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part, _impl_.process_strategy_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part, _impl_.up_skin_process_strategy_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part, _impl_.down_skin_process_strategy_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part, _impl_.exposure_order_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::Part, _impl_.parent_part_name_),
    ~0u,
    0,
    1,
    2,
    3,
    4,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane_WorkPlaneMetaData_PatchesMapEntry_DoNotUse, _has_bits_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane_WorkPlaneMetaData_PatchesMapEntry_DoNotUse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane_WorkPlaneMetaData_PatchesMapEntry_DoNotUse, key_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane_WorkPlaneMetaData_PatchesMapEntry_DoNotUse, value_),
    0,
    1,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane_WorkPlaneMetaData_closedContour, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane_WorkPlaneMetaData_closedContour, _impl_.contour_section_vector_block_indices_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane_WorkPlaneMetaData_closedContour, _impl_.area_in_mm_2_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane_WorkPlaneMetaData_closedContour, _impl_.length_in_mm_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane_WorkPlaneMetaData_closedContour, _impl_.parent_index_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane_WorkPlaneMetaData_closedContour, _impl_.winding_number_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane_WorkPlaneMetaData_closedContour, _impl_.type_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane_WorkPlaneMetaData, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane_WorkPlaneMetaData, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane_WorkPlaneMetaData, _impl_.total_scan_distance_in_mm_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane_WorkPlaneMetaData, _impl_.total_jump_distance_in_mm_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane_WorkPlaneMetaData, _impl_.patches_map_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane_WorkPlaneMetaData, _impl_.maxpower_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane_WorkPlaneMetaData, _impl_.minpower_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane_WorkPlaneMetaData, _impl_.contours_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane_WorkPlaneMetaData, _impl_.bounds_),
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    0,
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane_Patch, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane_Patch, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane_Patch, _impl_.outer_contour_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane_Patch, _impl_.u_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane_Patch, _impl_.v_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane_Patch, _impl_.layer_id_),
    0,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane, _impl_.vector_blocks_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane, _impl_.x_pos_in_mm_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane, _impl_.y_pos_in_mm_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane, _impl_.z_pos_in_mm_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane, _impl_.x_rot_in_deg_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane, _impl_.y_rot_in_deg_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane, _impl_.z_rot_in_deg_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane, _impl_.num_blocks_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane, _impl_.repeats_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane, _impl_.work_plane_number_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane, _impl_.machine_type_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane, _impl_.additional_axis_positions_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::WorkPlane, _impl_.meta_data_),
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    0,
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_VectorBlockMetaData, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_VectorBlockMetaData, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_VectorBlockMetaData, _impl_.total_scan_distance_in_mm_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_VectorBlockMetaData, _impl_.total_jump_distance_in_mm_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_VectorBlockMetaData, _impl_.part_key_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_VectorBlockMetaData, _impl_.patch_key_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_VectorBlockMetaData, _impl_.contour_index_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_VectorBlockMetaData, _impl_.bounds_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_VectorBlockMetaData, _impl_.display_color_),
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    0,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_LPBFMetadata, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_LPBFMetadata, _impl_.part_area_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_LPBFMetadata, _impl_.skin_type_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_LPBFMetadata, _impl_.skin_core_strategy_area_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_LPBFMetadata, _impl_.structure_type_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_LPBFMetadata, _impl_.reexposure_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_MicroStructuringMetadata, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_MicroStructuringMetadata, _impl_.part_area_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_MicroStructuringMetadata, _impl_.structure_type_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_PolishingMetadata, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_LineSequence, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_LineSequence, _impl_.points_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_LineSequence3D, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_LineSequence3D, _impl_.points_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_Hatches, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_Hatches, _impl_.points_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_Hatches3D, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_Hatches3D, _impl_.points_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_PointSequence, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_PointSequence, _impl_.points_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_PointSequence3D, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_PointSequence3D, _impl_.points_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_Arcs, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_Arcs, _impl_.angle_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_Arcs, _impl_.start_dx_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_Arcs, _impl_.start_dy_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_Arcs, _impl_.centers_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_Arcs3D, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_Arcs3D, _impl_.angle_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_Arcs3D, _impl_.start_dx_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_Arcs3D, _impl_.start_dy_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_Arcs3D, _impl_.start_dz_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_Arcs3D, _impl_.centers_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_Ellipses, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_Ellipses, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_Ellipses, _impl_.a_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_Ellipses, _impl_.b_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_Ellipses, _impl_.phi0_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_Ellipses, _impl_.ellipses_arcs_),
    ~0u,
    ~0u,
    ~0u,
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_ExposurePause, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_ExposurePause, _impl_.pause_in_us_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_LineSequenceParaAdapt, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_LineSequenceParaAdapt, _impl_.points_with_paras_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_LineSequenceParaAdapt, _impl_.parameter_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_HatchesParaAdapt, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock_HatchesParaAdapt, _impl_.hatchaslinesequence_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock, _impl_.marking_params_key_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock, _impl_.laser_index_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock, _impl_.repeats_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock, _impl_.meta_data_),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock, _impl_.vector_data_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock, _impl_.process_meta_data_),
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::open_vector_format::AxisAlignedBox2D, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::open_vector_format::AxisAlignedBox2D, _impl_.x_min_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::AxisAlignedBox2D, _impl_.y_min_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::AxisAlignedBox2D, _impl_.x_max_),
    PROTOBUF_FIELD_OFFSET(::open_vector_format::AxisAlignedBox2D, _impl_.y_max_),
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        {0, 10, -1, sizeof(::open_vector_format::Job_MarkingParamsMapEntry_DoNotUse)},
        {12, 22, -1, sizeof(::open_vector_format::Job_PartsMapEntry_DoNotUse)},
        {24, 38, -1, sizeof(::open_vector_format::Job_JobMetaData)},
        {44, 58, -1, sizeof(::open_vector_format::Job)},
        {64, -1, -1, sizeof(::open_vector_format::JobParameters)},
        {75, 109, -1, sizeof(::open_vector_format::MarkingParams)},
        {135, -1, -1, sizeof(::open_vector_format::PowerGradientParams)},
        {145, -1, -1, sizeof(::open_vector_format::Part_GeometryInfo)},
        {158, -1, -1, sizeof(::open_vector_format::Part_Material)},
        {168, -1, -1, sizeof(::open_vector_format::Part_ProcessStrategy_ProprietaryParam)},
        {179, -1, -1, sizeof(::open_vector_format::Part_ProcessStrategy)},
        {202, 218, -1, sizeof(::open_vector_format::Part)},
        {226, 236, -1, sizeof(::open_vector_format::WorkPlane_WorkPlaneMetaData_PatchesMapEntry_DoNotUse)},
        {238, -1, -1, sizeof(::open_vector_format::WorkPlane_WorkPlaneMetaData_closedContour)},
        {252, 267, -1, sizeof(::open_vector_format::WorkPlane_WorkPlaneMetaData)},
        {274, 286, -1, sizeof(::open_vector_format::WorkPlane_Patch)},
        {290, 311, -1, sizeof(::open_vector_format::WorkPlane)},
        {324, 339, -1, sizeof(::open_vector_format::VectorBlock_VectorBlockMetaData)},
        {346, -1, -1, sizeof(::open_vector_format::VectorBlock_LPBFMetadata)},
        {359, -1, -1, sizeof(::open_vector_format::VectorBlock_MicroStructuringMetadata)},
        {369, -1, -1, sizeof(::open_vector_format::VectorBlock_PolishingMetadata)},
        {377, -1, -1, sizeof(::open_vector_format::VectorBlock_LineSequence)},
        {386, -1, -1, sizeof(::open_vector_format::VectorBlock_LineSequence3D)},
        {395, -1, -1, sizeof(::open_vector_format::VectorBlock_Hatches)},
        {404, -1, -1, sizeof(::open_vector_format::VectorBlock_Hatches3D)},
        {413, -1, -1, sizeof(::open_vector_format::VectorBlock_PointSequence)},
        {422, -1, -1, sizeof(::open_vector_format::VectorBlock_PointSequence3D)},
        {431, -1, -1, sizeof(::open_vector_format::VectorBlock_Arcs)},
        {443, -1, -1, sizeof(::open_vector_format::VectorBlock_Arcs3D)},
        {456, 468, -1, sizeof(::open_vector_format::VectorBlock_Ellipses)},
        {472, -1, -1, sizeof(::open_vector_format::VectorBlock_ExposurePause)},
        {481, -1, -1, sizeof(::open_vector_format::VectorBlock_LineSequenceParaAdapt)},
        {491, -1, -1, sizeof(::open_vector_format::VectorBlock_HatchesParaAdapt)},
        {500, 529, -1, sizeof(::open_vector_format::VectorBlock)},
        {548, -1, -1, sizeof(::open_vector_format::AxisAlignedBox2D)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::open_vector_format::_Job_MarkingParamsMapEntry_DoNotUse_default_instance_._instance,
    &::open_vector_format::_Job_PartsMapEntry_DoNotUse_default_instance_._instance,
    &::open_vector_format::_Job_JobMetaData_default_instance_._instance,
    &::open_vector_format::_Job_default_instance_._instance,
    &::open_vector_format::_JobParameters_default_instance_._instance,
    &::open_vector_format::_MarkingParams_default_instance_._instance,
    &::open_vector_format::_PowerGradientParams_default_instance_._instance,
    &::open_vector_format::_Part_GeometryInfo_default_instance_._instance,
    &::open_vector_format::_Part_Material_default_instance_._instance,
    &::open_vector_format::_Part_ProcessStrategy_ProprietaryParam_default_instance_._instance,
    &::open_vector_format::_Part_ProcessStrategy_default_instance_._instance,
    &::open_vector_format::_Part_default_instance_._instance,
    &::open_vector_format::_WorkPlane_WorkPlaneMetaData_PatchesMapEntry_DoNotUse_default_instance_._instance,
    &::open_vector_format::_WorkPlane_WorkPlaneMetaData_closedContour_default_instance_._instance,
    &::open_vector_format::_WorkPlane_WorkPlaneMetaData_default_instance_._instance,
    &::open_vector_format::_WorkPlane_Patch_default_instance_._instance,
    &::open_vector_format::_WorkPlane_default_instance_._instance,
    &::open_vector_format::_VectorBlock_VectorBlockMetaData_default_instance_._instance,
    &::open_vector_format::_VectorBlock_LPBFMetadata_default_instance_._instance,
    &::open_vector_format::_VectorBlock_MicroStructuringMetadata_default_instance_._instance,
    &::open_vector_format::_VectorBlock_PolishingMetadata_default_instance_._instance,
    &::open_vector_format::_VectorBlock_LineSequence_default_instance_._instance,
    &::open_vector_format::_VectorBlock_LineSequence3D_default_instance_._instance,
    &::open_vector_format::_VectorBlock_Hatches_default_instance_._instance,
    &::open_vector_format::_VectorBlock_Hatches3D_default_instance_._instance,
    &::open_vector_format::_VectorBlock_PointSequence_default_instance_._instance,
    &::open_vector_format::_VectorBlock_PointSequence3D_default_instance_._instance,
    &::open_vector_format::_VectorBlock_Arcs_default_instance_._instance,
    &::open_vector_format::_VectorBlock_Arcs3D_default_instance_._instance,
    &::open_vector_format::_VectorBlock_Ellipses_default_instance_._instance,
    &::open_vector_format::_VectorBlock_ExposurePause_default_instance_._instance,
    &::open_vector_format::_VectorBlock_LineSequenceParaAdapt_default_instance_._instance,
    &::open_vector_format::_VectorBlock_HatchesParaAdapt_default_instance_._instance,
    &::open_vector_format::_VectorBlock_default_instance_._instance,
    &::open_vector_format::_AxisAlignedBox2D_default_instance_._instance,
};
const char descriptor_table_protodef_open_5fvector_5fformat_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\030open_vector_format.proto\022\022open_vector_"
    "format\"\236\005\n\003Job\0222\n\013work_planes\030\001 \003(\0132\035.op"
    "en_vector_format.WorkPlane\022:\n\rjob_meta_d"
    "ata\030\002 \001(\0132#.open_vector_format.Job.JobMe"
    "taData\022I\n\022marking_params_map\030\003 \003(\0132-.ope"
    "n_vector_format.Job.MarkingParamsMapEntr"
    "y\0228\n\tparts_map\030\004 \003(\0132%.open_vector_forma"
    "t.Job.PartsMapEntry\0229\n\016job_parameters\030\005 "
    "\001(\0132!.open_vector_format.JobParameters\022\027"
    "\n\017num_work_planes\030\006 \001(\005\032Z\n\025MarkingParams"
    "MapEntry\022\013\n\003key\030\001 \001(\005\0220\n\005value\030\002 \001(\0132!.o"
    "pen_vector_format.MarkingParams:\0028\001\032I\n\rP"
    "artsMapEntry\022\013\n\003key\030\001 \001(\005\022\'\n\005value\030\002 \001(\013"
    "2\030.open_vector_format.Part:\0028\001\032\246\001\n\013JobMe"
    "taData\022\031\n\021job_creation_time\030\001 \001(\003\022\017\n\007ver"
    "sion\030\002 \001(\004\022\020\n\010job_name\030\003 \001(\t\022\016\n\006author\030\004"
    " \001(\t\022\023\n\013description\030\005 \001(\t\0224\n\006bounds\030\006 \001("
    "\0132$.open_vector_format.AxisAlignedBox2D\""
    "z\n\rJobParameters\022%\n\035preheating_temperatu"
    "r_in_dg_c\030\001 \001(\001\022 \n\030shielding_gas_directi"
    "ons\030\002 \003(\001\022 \n\030material_feed_directions\030\003 "
    "\003(\001\"\205\010\n\rMarkingParams\022\030\n\020laser_power_in_"
    "w\030\001 \001(\002\022\037\n\027laser_speed_in_mm_per_s\030\002 \001(\002"
    "\022\037\n\027laser_focus_shift_in_mm\030\003 \001(\002\022!\n\031poi"
    "nt_exposure_time_in_us\030\004 \001(\002\022\032\n\022jump_spe"
    "ed_in_mm_s\030\005 \001(\002\022\"\n\032point_exposure_repet"
    "itions\030\006 \001(\002\022\035\n\025repetition_rate_in_hz\030\007 "
    "\001(\004\022\036\n\026laser_pulses_per_burst\030\010 \001(\004\022#\n\033p"
    "ulseDurationInFemtoseconds\030\t \001(\004\022C\n\014mark"
    "ing_mode\030\n \001(\0162-.open_vector_format.Mark"
    "ingParams.MarkingMode\022\030\n\020jump_delay_in_u"
    "s\030\013 \001(\002\022\035\n\025laser_off_delay_in_us\030\014 \001(\002\022\034"
    "\n\024laser_on_delay_in_us\030\r \001(\002\022\030\n\020mark_del"
    "ay_in_us\030\016 \001(\002\022\033\n\023polygon_delay_in_us\030\017 "
    "\001(\002\022\026\n\016time_lag_in_us\030\020 \001(\002\022\034\n\024laser_on_"
    "shift_in_us\030\021 \001(\002\022\r\n\005limit\030\022 \001(\002\022\024\n\014n_pr"
    "ev_in_us\030\023 \001(\002\022\024\n\014n_post_in_us\030\024 \001(\002\022\033\n\023"
    "wob_frequency_in_hz\030\025 \001(\002\022\032\n\022wob_amp_lon"
    "g_in_mm\030\026 \001(\002\022\033\n\023wob_amp_trans_in_mm\030\027 \001"
    "(\002\022A\n\013wobble_mode\030\030 \001(\0162,.open_vector_fo"
    "rmat.MarkingParams.WobbleMode\022>\n\rpowerGr"
    "adient\030\031 \001(\0132\'.open_vector_format.PowerG"
    "radientParams\022\014\n\004name\030\032 \001(\t\":\n\013MarkingMo"
    "de\022\n\n\006NO_SKY\020\000\022\t\n\005SKY_1\020\001\022\t\n\005SKY_2\020\002\022\t\n\005"
    "SKY_3\020\003\"b\n\nWobbleMode\022\r\n\tNO_WOBBLE\020\000\022\022\n\016"
    "ELLIPSE_WOBBLE\020\001\022\031\n\025STANDING_EIGHT_WOBBL"
    "E\020\002\022\026\n\022LYING_EIGHT_WOBBLE\020\003J\006\010\200\001\020\245\001\"C\n\023P"
    "owerGradientParams\022\023\n\013minPowerInW\030\001 \001(\002\022"
    "\027\n\017gradientInWPerS\030\002 \001(\002\"\205\013\n\004Part\022\014\n\004nam"
    "e\030\001 \001(\t\022<\n\rgeometry_info\030\002 \001(\0132%.open_ve"
    "ctor_format.Part.GeometryInfo\0223\n\010materia"
    "l\030\003 \001(\0132!.open_vector_format.Part.Materi"
    "al\022B\n\020process_strategy\030\004 \001(\0132(.open_vect"
    "or_format.Part.ProcessStrategy\022J\n\030up_ski"
    "n_process_strategy\030\005 \001(\0132(.open_vector_f"
    "ormat.Part.ProcessStrategy\022L\n\032down_skin_"
    "process_strategy\030\006 \001(\0132(.open_vector_for"
    "mat.Part.ProcessStrategy\022D\n\016exposure_ord"
    "er\030\007 \003(\0132,.open_vector_format.VectorBloc"
    "k.LPBFMetadata\022\030\n\020parent_part_name\030\010 \001(\t"
    "\032\237\001\n\014GeometryInfo\022\025\n\rvolume_in_mm3\030\001 \001(\001"
    "\022\035\n\025support_volume_in_mm3\030\002 \001(\001\022\032\n\022build"
    "_height_in_mm\030\003 \001(\001\022\033\n\023surface_area_in_m"
    "m2\030\004 \001(\001\022 \n\030projected_surface_in_mm2\030\005 \001"
    "(\001\032$\n\010Material\022\n\n\002id\030\001 \001(\004\022\014\n\004name\030\002 \001(\t"
    "\032\365\005\n\017ProcessStrategy\022\030\n\020rot_angle_in_deg"
    "\030\001 \001(\002\022\036\n\026increment_angle_in_deg\030\002 \001(\002\022\023"
    "\n\013shift_in_mm\030\003 \001(\002\022\031\n\021extend_into_in_mm"
    "\030\004 \001(\002\022\"\n\032pattern_hatch_length_in_mm\030\r \001"
    "(\002\022R\n\020hatching_pattern\030\014 \001(\01628.open_vect"
    "or_format.Part.ProcessStrategy.HatchingP"
    "attern\022\035\n\025layer_thickness_in_mm\030\005 \001(\002\022\034\n"
    "\024hatch_distance_in_mm\030\006 \001(\002\022$\n\034hatch_con"
    "tour_distance_in_mm\030\007 \001(\002\022\035\n\025overhang_an"
    "gle_in_deg\030\010 \001(\002\022\034\n\024contour_offset_in_mm"
    "\030\t \001(\002\022\032\n\022number_of_contours\030\n \001(\005\022\036\n\026co"
    "ntour_distance_in_mm\030\013 \001(\002\022\014\n\004name\030Z \001(\t"
    "\022X\n\025additional_parameters\030d \003(\01329.open_v"
    "ector_format.Part.ProcessStrategy.Propri"
    "etaryParam\032V\n\020ProprietaryParam\022\022\n\nparam_"
    "name\030\001 \001(\t\022\023\n\013param_value\030\002 \001(\001\022\031\n\021param"
    "_description\030\003 \001(\t\"d\n\017HatchingPattern\022\022\n"
    "\016UNIDIRECTIONAL\020\000\022\021\n\rBIDIRECTIONAL\020\001\022\020\n\014"
    "CHECKERBOARD\020\002\022\013\n\007STRIPES\020\003\022\013\n\007HEXAGON\020\004"
    "\"\362\t\n\tWorkPlane\0226\n\rvector_blocks\030\001 \003(\0132\037."
    "open_vector_format.VectorBlock\022\023\n\013x_pos_"
    "in_mm\030\002 \001(\002\022\023\n\013y_pos_in_mm\030\003 \001(\002\022\023\n\013z_po"
    "s_in_mm\030\004 \001(\002\022\024\n\014x_rot_in_deg\030\005 \001(\002\022\024\n\014y"
    "_rot_in_deg\030\006 \001(\002\022\024\n\014z_rot_in_deg\030\007 \001(\002\022"
    "\022\n\nnum_blocks\030\010 \001(\005\022\017\n\007repeats\030\t \001(\r\022\031\n\021"
    "work_plane_number\030\n \001(\005\022\024\n\014machine_type\030"
    "\013 \001(\t\022!\n\031additional_axis_positions\030\014 \003(\002"
    "\022B\n\tmeta_data\030\r \001(\0132/.open_vector_format"
    ".WorkPlane.WorkPlaneMetaData\032\370\005\n\021WorkPla"
    "neMetaData\022!\n\031total_scan_distance_in_mm\030"
    "\001 \001(\001\022!\n\031total_jump_distance_in_mm\030\002 \001(\001"
    "\022T\n\013patches_map\030\003 \003(\0132\?.open_vector_form"
    "at.WorkPlane.WorkPlaneMetaData.PatchesMa"
    "pEntry\022\020\n\010maxPower\030\004 \001(\002\022\020\n\010minPower\030\005 \001"
    "(\002\022O\n\010contours\030\006 \003(\0132=.open_vector_forma"
    "t.WorkPlane.WorkPlaneMetaData.closedCont"
    "our\0224\n\006Bounds\030\007 \001(\0132$.open_vector_format"
    ".AxisAlignedBox2D\032V\n\017PatchesMapEntry\022\013\n\003"
    "key\030\001 \001(\005\0222\n\005value\030\002 \001(\0132#.open_vector_f"
    "ormat.WorkPlane.Patch:\0028\001\032\303\002\n\rclosedCont"
    "our\022,\n$contour_section_vector_block_indi"
    "ces\030\001 \003(\005\022\024\n\014area_in_mm_2\030\002 \001(\002\022\024\n\014lengt"
    "h_in_mm\030\003 \001(\002\022\024\n\014parent_index\030\005 \001(\005\022\026\n\016w"
    "inding_number\030\006 \001(\005\022W\n\004type\030\007 \001(\0162I.open"
    "_vector_format.WorkPlane.WorkPlaneMetaDa"
    "ta.closedContour.ContourType\"Q\n\013ContourT"
    "ype\022\026\n\022PART_OUTER_CONTOUR\020\000\022\026\n\022PART_INNE"
    "R_CONTOUR\020\001\022\022\n\016OFFSET_CONTOUR\020\002\032t\n\005Patch"
    "\022C\n\router_contour\030\001 \001(\0132,.open_vector_fo"
    "rmat.VectorBlock.LineSequence\022\t\n\001u\030\002 \001(\002"
    "\022\t\n\001v\030\003 \001(\002\022\020\n\010layer_id\030\004 \001(\005\"\357\030\n\013Vector"
    "Block\022E\n\rline_sequence\030\001 \001(\0132,.open_vect"
    "or_format.VectorBlock.LineSequenceH\000\022;\n\010"
    "_hatches\030\002 \001(\0132\'.open_vector_format.Vect"
    "orBlock.HatchesH\000\022G\n\016point_sequence\030\003 \001("
    "\0132-.open_vector_format.VectorBlock.Point"
    "SequenceH\000\0225\n\005_arcs\030\004 \001(\0132$.open_vector_"
    "format.VectorBlock.ArcsH\000\022<\n\010ellipses\030\005 "
    "\001(\0132(.open_vector_format.VectorBlock.Ell"
    "ipsesH\000\022J\n\020line_sequence_3d\030\006 \001(\0132..open"
    "_vector_format.VectorBlock.LineSequence3"
    "DH\000\022\?\n\nhatches_3d\030\007 \001(\0132).open_vector_fo"
    "rmat.VectorBlock.Hatches3DH\000\022L\n\021point_se"
    "quence_3d\030\010 \001(\0132/.open_vector_format.Vec"
    "torBlock.PointSequence3DH\000\0229\n\007arcs_3d\030\t "
    "\001(\0132&.open_vector_format.VectorBlock.Arc"
    "s3DH\000\022G\n\016exposure_pause\030\n \001(\0132-.open_vec"
    "tor_format.VectorBlock.ExposurePauseH\000\022Y"
    "\n\030line_sequence_para_adapt\030\013 \001(\01325.open_"
    "vector_format.VectorBlock.LineSequencePa"
    "raAdaptH\000\022K\n\017_hatchParaAdapt\030\014 \001(\01320.ope"
    "n_vector_format.VectorBlock.HatchesParaA"
    "daptH\000\022\032\n\022marking_params_key\0302 \001(\005\022\023\n\013la"
    "ser_index\0305 \001(\005\022\017\n\007repeats\0306 \001(\004\022F\n\tmeta"
    "_data\030d \001(\01323.open_vector_format.VectorB"
    "lock.VectorBlockMetaData\022E\n\rlpbf_metadat"
    "a\030e \001(\0132,.open_vector_format.VectorBlock"
    ".LPBFMetadataH\001\022^\n\032micro_structuring_met"
    "adata\030f \001(\01328.open_vector_format.VectorB"
    "lock.MicroStructuringMetadataH\001\022O\n\022polis"
    "hing_metadata\030g \001(\01321.open_vector_format"
    ".VectorBlock.PolishingMetadataH\001\032\344\001\n\023Vec"
    "torBlockMetaData\022!\n\031total_scan_distance_"
    "in_mm\030\001 \001(\001\022!\n\031total_jump_distance_in_mm"
    "\030\002 \001(\001\022\020\n\010part_key\030\003 \001(\005\022\021\n\tpatch_key\030\004 "
    "\001(\005\022\025\n\rcontour_index\030\005 \001(\005\0224\n\006bounds\030\006 \001"
    "(\0132$.open_vector_format.AxisAlignedBox2D"
    "\022\025\n\rdisplay_color\030\007 \001(\005\032\317\003\n\014LPBFMetadata"
    "\022;\n\tpart_area\030\001 \001(\0162(.open_vector_format"
    ".VectorBlock.PartArea\022H\n\tskin_type\030\002 \001(\016"
    "25.open_vector_format.VectorBlock.LPBFMe"
    "tadata.SkinType\022b\n\027skin_core_strategy_ar"
    "ea\030\003 \001(\0162A.open_vector_format.VectorBloc"
    "k.LPBFMetadata.SkinCoreStrategyArea\022E\n\016s"
    "tructure_type\030\004 \001(\0162-.open_vector_format"
    ".VectorBlock.StructureType\022\022\n\nreexposure"
    "\030\005 \001(\010\"3\n\010SkinType\022\013\n\007IN_SKIN\020\000\022\r\n\tDOWN_"
    "SKIN\020\001\022\013\n\007UP_SKIN\020\002\"D\n\024SkinCoreStrategyA"
    "rea\022\016\n\nOUTER_HULL\020\000\022\010\n\004CORE\020\001\022\022\n\016INBETWE"
    "EN_HULL\020\002\032\236\001\n\030MicroStructuringMetadata\022;"
    "\n\tpart_area\030\001 \001(\0162(.open_vector_format.V"
    "ectorBlock.PartArea\022E\n\016structure_type\030\002 "
    "\001(\0162-.open_vector_format.VectorBlock.Str"
    "uctureType\032\023\n\021PolishingMetadata\032\036\n\014LineS"
    "equence\022\016\n\006points\030\001 \003(\002\032 \n\016LineSequence3"
    "D\022\016\n\006points\030\001 \003(\002\032\031\n\007Hatches\022\016\n\006points\030\001"
    " \003(\002\032\033\n\tHatches3D\022\016\n\006points\030\001 \003(\002\032\037\n\rPoi"
    "ntSequence\022\016\n\006points\030\001 \003(\002\032!\n\017PointSeque"
    "nce3D\022\016\n\006points\030\001 \003(\002\032J\n\004Arcs\022\r\n\005angle\030\001"
    " \001(\001\022\020\n\010start_dx\030\002 \001(\002\022\020\n\010start_dy\030\003 \001(\002"
    "\022\017\n\007centers\030\004 \003(\002\032^\n\006Arcs3D\022\r\n\005angle\030\001 \001"
    "(\001\022\020\n\010start_dx\030\002 \001(\002\022\020\n\010start_dy\030\003 \001(\002\022\020"
    "\n\010start_dz\030\004 \001(\002\022\017\n\007centers\030\005 \003(\002\032k\n\010Ell"
    "ipses\022\t\n\001a\030\001 \001(\002\022\t\n\001b\030\002 \001(\002\022\014\n\004phi0\030\003 \001("
    "\001\022;\n\rellipses_arcs\030\004 \001(\0132$.open_vector_f"
    "ormat.VectorBlock.Arcs\032$\n\rExposurePause\022"
    "\023\n\013pause_in_us\030\001 \001(\004\032\230\002\n\025LineSequencePar"
    "aAdapt\022\031\n\021points_with_paras\030\001 \003(\002\022Y\n\tpar"
    "ameter\030\002 \001(\0162F.open_vector_format.Vector"
    "Block.LineSequenceParaAdapt.AdaptedParam"
    "eter\"\210\001\n\020AdaptedParameter\022\024\n\020LASER_POWER"
    "_IN_W\020\000\022\033\n\027LASER_FOCUS_SHIFT_IN_MM\020\001\022\034\n\030"
    "LASER_PULSE_LENGTH_IN_US\020\002\022#\n\037LASER_PULS"
    "E_REPITION_RATE_IN_HZ\020\003\032f\n\020HatchesParaAd"
    "apt\022R\n\023hatchAsLinesequence\030\001 \003(\01325.open_"
    "vector_format.VectorBlock.LineSequencePa"
    "raAdapt\";\n\010PartArea\022\n\n\006VOLUME\020\000\022\013\n\007CONTO"
    "UR\020\001\022\026\n\022TRANSITION_CONTOUR\020\002\"E\n\rStructur"
    "eType\022\010\n\004PART\020\000\022\013\n\007SUPPORT\020\001\022\021\n\rWIRESTRU"
    "CTURE\020\002\022\n\n\006POINTS\020\003B\r\n\013vector_dataB\023\n\021pr"
    "ocess_meta_data\"N\n\020AxisAlignedBox2D\022\r\n\005x"
    "_min\030\001 \001(\002\022\r\n\005y_min\030\002 \001(\002\022\r\n\005x_max\030\003 \001(\002"
    "\022\r\n\005y_max\030\004 \001(\002B=Z;github.com/digital-pr"
    "oduction-aachen/openvectorformat/protob\006"
    "proto3"
};
static ::absl::once_flag descriptor_table_open_5fvector_5fformat_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_open_5fvector_5fformat_2eproto = {
    false,
    false,
    7966,
    descriptor_table_protodef_open_5fvector_5fformat_2eproto,
    "open_vector_format.proto",
    &descriptor_table_open_5fvector_5fformat_2eproto_once,
    nullptr,
    0,
    35,
    schemas,
    file_default_instances,
    TableStruct_open_5fvector_5fformat_2eproto::offsets,
    file_level_metadata_open_5fvector_5fformat_2eproto,
    file_level_enum_descriptors_open_5fvector_5fformat_2eproto,
    file_level_service_descriptors_open_5fvector_5fformat_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_open_5fvector_5fformat_2eproto_getter() {
  return &descriptor_table_open_5fvector_5fformat_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_open_5fvector_5fformat_2eproto(&descriptor_table_open_5fvector_5fformat_2eproto);
namespace open_vector_format {
const ::google::protobuf::EnumDescriptor* MarkingParams_MarkingMode_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_open_5fvector_5fformat_2eproto);
  return file_level_enum_descriptors_open_5fvector_5fformat_2eproto[0];
}
bool MarkingParams_MarkingMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr MarkingParams_MarkingMode MarkingParams::NO_SKY;
constexpr MarkingParams_MarkingMode MarkingParams::SKY_1;
constexpr MarkingParams_MarkingMode MarkingParams::SKY_2;
constexpr MarkingParams_MarkingMode MarkingParams::SKY_3;
constexpr MarkingParams_MarkingMode MarkingParams::MarkingMode_MIN;
constexpr MarkingParams_MarkingMode MarkingParams::MarkingMode_MAX;
constexpr int MarkingParams::MarkingMode_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::google::protobuf::EnumDescriptor* MarkingParams_WobbleMode_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_open_5fvector_5fformat_2eproto);
  return file_level_enum_descriptors_open_5fvector_5fformat_2eproto[1];
}
bool MarkingParams_WobbleMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr MarkingParams_WobbleMode MarkingParams::NO_WOBBLE;
constexpr MarkingParams_WobbleMode MarkingParams::ELLIPSE_WOBBLE;
constexpr MarkingParams_WobbleMode MarkingParams::STANDING_EIGHT_WOBBLE;
constexpr MarkingParams_WobbleMode MarkingParams::LYING_EIGHT_WOBBLE;
constexpr MarkingParams_WobbleMode MarkingParams::WobbleMode_MIN;
constexpr MarkingParams_WobbleMode MarkingParams::WobbleMode_MAX;
constexpr int MarkingParams::WobbleMode_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::google::protobuf::EnumDescriptor* Part_ProcessStrategy_HatchingPattern_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_open_5fvector_5fformat_2eproto);
  return file_level_enum_descriptors_open_5fvector_5fformat_2eproto[2];
}
bool Part_ProcessStrategy_HatchingPattern_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr Part_ProcessStrategy_HatchingPattern Part_ProcessStrategy::UNIDIRECTIONAL;
constexpr Part_ProcessStrategy_HatchingPattern Part_ProcessStrategy::BIDIRECTIONAL;
constexpr Part_ProcessStrategy_HatchingPattern Part_ProcessStrategy::CHECKERBOARD;
constexpr Part_ProcessStrategy_HatchingPattern Part_ProcessStrategy::STRIPES;
constexpr Part_ProcessStrategy_HatchingPattern Part_ProcessStrategy::HEXAGON;
constexpr Part_ProcessStrategy_HatchingPattern Part_ProcessStrategy::HatchingPattern_MIN;
constexpr Part_ProcessStrategy_HatchingPattern Part_ProcessStrategy::HatchingPattern_MAX;
constexpr int Part_ProcessStrategy::HatchingPattern_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::google::protobuf::EnumDescriptor* WorkPlane_WorkPlaneMetaData_closedContour_ContourType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_open_5fvector_5fformat_2eproto);
  return file_level_enum_descriptors_open_5fvector_5fformat_2eproto[3];
}
bool WorkPlane_WorkPlaneMetaData_closedContour_ContourType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr WorkPlane_WorkPlaneMetaData_closedContour_ContourType WorkPlane_WorkPlaneMetaData_closedContour::PART_OUTER_CONTOUR;
constexpr WorkPlane_WorkPlaneMetaData_closedContour_ContourType WorkPlane_WorkPlaneMetaData_closedContour::PART_INNER_CONTOUR;
constexpr WorkPlane_WorkPlaneMetaData_closedContour_ContourType WorkPlane_WorkPlaneMetaData_closedContour::OFFSET_CONTOUR;
constexpr WorkPlane_WorkPlaneMetaData_closedContour_ContourType WorkPlane_WorkPlaneMetaData_closedContour::ContourType_MIN;
constexpr WorkPlane_WorkPlaneMetaData_closedContour_ContourType WorkPlane_WorkPlaneMetaData_closedContour::ContourType_MAX;
constexpr int WorkPlane_WorkPlaneMetaData_closedContour::ContourType_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::google::protobuf::EnumDescriptor* VectorBlock_LPBFMetadata_SkinType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_open_5fvector_5fformat_2eproto);
  return file_level_enum_descriptors_open_5fvector_5fformat_2eproto[4];
}
bool VectorBlock_LPBFMetadata_SkinType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr VectorBlock_LPBFMetadata_SkinType VectorBlock_LPBFMetadata::IN_SKIN;
constexpr VectorBlock_LPBFMetadata_SkinType VectorBlock_LPBFMetadata::DOWN_SKIN;
constexpr VectorBlock_LPBFMetadata_SkinType VectorBlock_LPBFMetadata::UP_SKIN;
constexpr VectorBlock_LPBFMetadata_SkinType VectorBlock_LPBFMetadata::SkinType_MIN;
constexpr VectorBlock_LPBFMetadata_SkinType VectorBlock_LPBFMetadata::SkinType_MAX;
constexpr int VectorBlock_LPBFMetadata::SkinType_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::google::protobuf::EnumDescriptor* VectorBlock_LPBFMetadata_SkinCoreStrategyArea_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_open_5fvector_5fformat_2eproto);
  return file_level_enum_descriptors_open_5fvector_5fformat_2eproto[5];
}
bool VectorBlock_LPBFMetadata_SkinCoreStrategyArea_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr VectorBlock_LPBFMetadata_SkinCoreStrategyArea VectorBlock_LPBFMetadata::OUTER_HULL;
constexpr VectorBlock_LPBFMetadata_SkinCoreStrategyArea VectorBlock_LPBFMetadata::CORE;
constexpr VectorBlock_LPBFMetadata_SkinCoreStrategyArea VectorBlock_LPBFMetadata::INBETWEEN_HULL;
constexpr VectorBlock_LPBFMetadata_SkinCoreStrategyArea VectorBlock_LPBFMetadata::SkinCoreStrategyArea_MIN;
constexpr VectorBlock_LPBFMetadata_SkinCoreStrategyArea VectorBlock_LPBFMetadata::SkinCoreStrategyArea_MAX;
constexpr int VectorBlock_LPBFMetadata::SkinCoreStrategyArea_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::google::protobuf::EnumDescriptor* VectorBlock_LineSequenceParaAdapt_AdaptedParameter_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_open_5fvector_5fformat_2eproto);
  return file_level_enum_descriptors_open_5fvector_5fformat_2eproto[6];
}
bool VectorBlock_LineSequenceParaAdapt_AdaptedParameter_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr VectorBlock_LineSequenceParaAdapt_AdaptedParameter VectorBlock_LineSequenceParaAdapt::LASER_POWER_IN_W;
constexpr VectorBlock_LineSequenceParaAdapt_AdaptedParameter VectorBlock_LineSequenceParaAdapt::LASER_FOCUS_SHIFT_IN_MM;
constexpr VectorBlock_LineSequenceParaAdapt_AdaptedParameter VectorBlock_LineSequenceParaAdapt::LASER_PULSE_LENGTH_IN_US;
constexpr VectorBlock_LineSequenceParaAdapt_AdaptedParameter VectorBlock_LineSequenceParaAdapt::LASER_PULSE_REPITION_RATE_IN_HZ;
constexpr VectorBlock_LineSequenceParaAdapt_AdaptedParameter VectorBlock_LineSequenceParaAdapt::AdaptedParameter_MIN;
constexpr VectorBlock_LineSequenceParaAdapt_AdaptedParameter VectorBlock_LineSequenceParaAdapt::AdaptedParameter_MAX;
constexpr int VectorBlock_LineSequenceParaAdapt::AdaptedParameter_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::google::protobuf::EnumDescriptor* VectorBlock_PartArea_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_open_5fvector_5fformat_2eproto);
  return file_level_enum_descriptors_open_5fvector_5fformat_2eproto[7];
}
bool VectorBlock_PartArea_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr VectorBlock_PartArea VectorBlock::VOLUME;
constexpr VectorBlock_PartArea VectorBlock::CONTOUR;
constexpr VectorBlock_PartArea VectorBlock::TRANSITION_CONTOUR;
constexpr VectorBlock_PartArea VectorBlock::PartArea_MIN;
constexpr VectorBlock_PartArea VectorBlock::PartArea_MAX;
constexpr int VectorBlock::PartArea_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::google::protobuf::EnumDescriptor* VectorBlock_StructureType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_open_5fvector_5fformat_2eproto);
  return file_level_enum_descriptors_open_5fvector_5fformat_2eproto[8];
}
bool VectorBlock_StructureType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr VectorBlock_StructureType VectorBlock::PART;
constexpr VectorBlock_StructureType VectorBlock::SUPPORT;
constexpr VectorBlock_StructureType VectorBlock::WIRESTRUCTURE;
constexpr VectorBlock_StructureType VectorBlock::POINTS;
constexpr VectorBlock_StructureType VectorBlock::StructureType_MIN;
constexpr VectorBlock_StructureType VectorBlock::StructureType_MAX;
constexpr int VectorBlock::StructureType_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
// ===================================================================

Job_MarkingParamsMapEntry_DoNotUse::Job_MarkingParamsMapEntry_DoNotUse() {}
Job_MarkingParamsMapEntry_DoNotUse::Job_MarkingParamsMapEntry_DoNotUse(::google::protobuf::Arena* arena)
    : SuperType(arena) {}
void Job_MarkingParamsMapEntry_DoNotUse::MergeFrom(const Job_MarkingParamsMapEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::google::protobuf::Metadata Job_MarkingParamsMapEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_open_5fvector_5fformat_2eproto_getter, &descriptor_table_open_5fvector_5fformat_2eproto_once,
      file_level_metadata_open_5fvector_5fformat_2eproto[0]);
}
// ===================================================================

Job_PartsMapEntry_DoNotUse::Job_PartsMapEntry_DoNotUse() {}
Job_PartsMapEntry_DoNotUse::Job_PartsMapEntry_DoNotUse(::google::protobuf::Arena* arena)
    : SuperType(arena) {}
void Job_PartsMapEntry_DoNotUse::MergeFrom(const Job_PartsMapEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::google::protobuf::Metadata Job_PartsMapEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_open_5fvector_5fformat_2eproto_getter, &descriptor_table_open_5fvector_5fformat_2eproto_once,
      file_level_metadata_open_5fvector_5fformat_2eproto[1]);
}
// ===================================================================

class Job_JobMetaData::_Internal {
 public:
  using HasBits = decltype(std::declval<Job_JobMetaData>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Job_JobMetaData, _impl_._has_bits_);
  static const ::open_vector_format::AxisAlignedBox2D& bounds(const Job_JobMetaData* msg);
  static void set_has_bounds(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::open_vector_format::AxisAlignedBox2D& Job_JobMetaData::_Internal::bounds(const Job_JobMetaData* msg) {
  return *msg->_impl_.bounds_;
}
Job_JobMetaData::Job_JobMetaData(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:open_vector_format.Job.JobMetaData)
}
Job_JobMetaData::Job_JobMetaData(const Job_JobMetaData& from) : ::google::protobuf::Message() {
  Job_JobMetaData* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.job_name_){},
      decltype(_impl_.author_){},
      decltype(_impl_.description_){},
      decltype(_impl_.bounds_){nullptr},
      decltype(_impl_.job_creation_time_){},
      decltype(_impl_.version_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _impl_.job_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.job_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_job_name().empty()) {
    _this->_impl_.job_name_.Set(from._internal_job_name(), _this->GetArenaForAllocation());
  }
  _impl_.author_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.author_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_author().empty()) {
    _this->_impl_.author_.Set(from._internal_author(), _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.description_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.bounds_ = new ::open_vector_format::AxisAlignedBox2D(*from._impl_.bounds_);
  }
  ::memcpy(&_impl_.job_creation_time_, &from._impl_.job_creation_time_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.version_) -
    reinterpret_cast<char*>(&_impl_.job_creation_time_)) + sizeof(_impl_.version_));

  // @@protoc_insertion_point(copy_constructor:open_vector_format.Job.JobMetaData)
}
inline void Job_JobMetaData::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.job_name_){},
      decltype(_impl_.author_){},
      decltype(_impl_.description_){},
      decltype(_impl_.bounds_){nullptr},
      decltype(_impl_.job_creation_time_){::int64_t{0}},
      decltype(_impl_.version_){::uint64_t{0u}},
  };
  _impl_.job_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.job_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.author_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.author_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.description_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}
Job_JobMetaData::~Job_JobMetaData() {
  // @@protoc_insertion_point(destructor:open_vector_format.Job.JobMetaData)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Job_JobMetaData::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.job_name_.Destroy();
  _impl_.author_.Destroy();
  _impl_.description_.Destroy();
  if (this != internal_default_instance()) delete _impl_.bounds_;
}
void Job_JobMetaData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void Job_JobMetaData::Clear() {
// @@protoc_insertion_point(message_clear_start:open_vector_format.Job.JobMetaData)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.job_name_.ClearToEmpty();
  _impl_.author_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.bounds_ != nullptr);
    _impl_.bounds_->Clear();
  }
  ::memset(&_impl_.job_creation_time_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.version_) -
      reinterpret_cast<char*>(&_impl_.job_creation_time_)) + sizeof(_impl_.version_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Job_JobMetaData::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 1, 68, 2> Job_JobMetaData::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Job_JobMetaData, _impl_._has_bits_),
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967232,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_Job_JobMetaData_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // int64 job_creation_time = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(Job_JobMetaData, _impl_.job_creation_time_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(Job_JobMetaData, _impl_.job_creation_time_)}},
    // uint64 version = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(Job_JobMetaData, _impl_.version_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(Job_JobMetaData, _impl_.version_)}},
    // string job_name = 3;
    {::_pbi::TcParser::FastUS1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(Job_JobMetaData, _impl_.job_name_)}},
    // string author = 4;
    {::_pbi::TcParser::FastUS1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(Job_JobMetaData, _impl_.author_)}},
    // string description = 5;
    {::_pbi::TcParser::FastUS1,
     {42, 63, 0, PROTOBUF_FIELD_OFFSET(Job_JobMetaData, _impl_.description_)}},
    // .open_vector_format.AxisAlignedBox2D bounds = 6;
    {::_pbi::TcParser::FastMtS1,
     {50, 0, 0, PROTOBUF_FIELD_OFFSET(Job_JobMetaData, _impl_.bounds_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // int64 job_creation_time = 1;
    {PROTOBUF_FIELD_OFFSET(Job_JobMetaData, _impl_.job_creation_time_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt64)},
    // uint64 version = 2;
    {PROTOBUF_FIELD_OFFSET(Job_JobMetaData, _impl_.version_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt64)},
    // string job_name = 3;
    {PROTOBUF_FIELD_OFFSET(Job_JobMetaData, _impl_.job_name_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string author = 4;
    {PROTOBUF_FIELD_OFFSET(Job_JobMetaData, _impl_.author_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string description = 5;
    {PROTOBUF_FIELD_OFFSET(Job_JobMetaData, _impl_.description_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .open_vector_format.AxisAlignedBox2D bounds = 6;
    {PROTOBUF_FIELD_OFFSET(Job_JobMetaData, _impl_.bounds_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::open_vector_format::AxisAlignedBox2D>()},
  }}, {{
    "\42\0\0\10\6\13\0\0"
    "open_vector_format.Job.JobMetaData"
    "job_name"
    "author"
    "description"
  }},
};

::uint8_t* Job_JobMetaData::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:open_vector_format.Job.JobMetaData)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // int64 job_creation_time = 1;
  if (this->_internal_job_creation_time() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_job_creation_time(), target);
  }

  // uint64 version = 2;
  if (this->_internal_version() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_version(), target);
  }

  // string job_name = 3;
  if (!this->_internal_job_name().empty()) {
    const std::string& _s = this->_internal_job_name();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "open_vector_format.Job.JobMetaData.job_name");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string author = 4;
  if (!this->_internal_author().empty()) {
    const std::string& _s = this->_internal_author();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "open_vector_format.Job.JobMetaData.author");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // string description = 5;
  if (!this->_internal_description().empty()) {
    const std::string& _s = this->_internal_description();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "open_vector_format.Job.JobMetaData.description");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .open_vector_format.AxisAlignedBox2D bounds = 6;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::bounds(this),
        _Internal::bounds(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:open_vector_format.Job.JobMetaData)
  return target;
}

::size_t Job_JobMetaData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:open_vector_format.Job.JobMetaData)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string job_name = 3;
  if (!this->_internal_job_name().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_job_name());
  }

  // string author = 4;
  if (!this->_internal_author().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_author());
  }

  // string description = 5;
  if (!this->_internal_description().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_description());
  }

  // .open_vector_format.AxisAlignedBox2D bounds = 6;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *_impl_.bounds_);
  }

  // int64 job_creation_time = 1;
  if (this->_internal_job_creation_time() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_job_creation_time());
  }

  // uint64 version = 2;
  if (this->_internal_version() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_version());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Job_JobMetaData::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    Job_JobMetaData::MergeImpl
};
const ::google::protobuf::Message::ClassData*Job_JobMetaData::GetClassData() const { return &_class_data_; }


void Job_JobMetaData::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Job_JobMetaData*>(&to_msg);
  auto& from = static_cast<const Job_JobMetaData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:open_vector_format.Job.JobMetaData)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_job_name().empty()) {
    _this->_internal_set_job_name(from._internal_job_name());
  }
  if (!from._internal_author().empty()) {
    _this->_internal_set_author(from._internal_author());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_bounds()->::open_vector_format::AxisAlignedBox2D::MergeFrom(
        from._internal_bounds());
  }
  if (from._internal_job_creation_time() != 0) {
    _this->_internal_set_job_creation_time(from._internal_job_creation_time());
  }
  if (from._internal_version() != 0) {
    _this->_internal_set_version(from._internal_version());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Job_JobMetaData::CopyFrom(const Job_JobMetaData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:open_vector_format.Job.JobMetaData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Job_JobMetaData::IsInitialized() const {
  return true;
}

void Job_JobMetaData::InternalSwap(Job_JobMetaData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.job_name_, lhs_arena,
                                       &other->_impl_.job_name_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.author_, lhs_arena,
                                       &other->_impl_.author_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.description_, lhs_arena,
                                       &other->_impl_.description_, rhs_arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Job_JobMetaData, _impl_.version_)
      + sizeof(Job_JobMetaData::_impl_.version_)
      - PROTOBUF_FIELD_OFFSET(Job_JobMetaData, _impl_.bounds_)>(
          reinterpret_cast<char*>(&_impl_.bounds_),
          reinterpret_cast<char*>(&other->_impl_.bounds_));
}

::google::protobuf::Metadata Job_JobMetaData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_open_5fvector_5fformat_2eproto_getter, &descriptor_table_open_5fvector_5fformat_2eproto_once,
      file_level_metadata_open_5fvector_5fformat_2eproto[2]);
}
// ===================================================================

class Job::_Internal {
 public:
  using HasBits = decltype(std::declval<Job>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Job, _impl_._has_bits_);
  static const ::open_vector_format::Job_JobMetaData& job_meta_data(const Job* msg);
  static void set_has_job_meta_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::open_vector_format::JobParameters& job_parameters(const Job* msg);
  static void set_has_job_parameters(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::open_vector_format::Job_JobMetaData& Job::_Internal::job_meta_data(const Job* msg) {
  return *msg->_impl_.job_meta_data_;
}
const ::open_vector_format::JobParameters& Job::_Internal::job_parameters(const Job* msg) {
  return *msg->_impl_.job_parameters_;
}
Job::Job(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:open_vector_format.Job)
}
Job::Job(const Job& from) : ::google::protobuf::Message() {
  Job* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.work_planes_){from._impl_.work_planes_},
      /* decltype(_impl_.marking_params_map_) */ {},
      /* decltype(_impl_.parts_map_) */ {},
      decltype(_impl_.job_meta_data_){nullptr},
      decltype(_impl_.job_parameters_){nullptr},
      decltype(_impl_.num_work_planes_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _this->_impl_.marking_params_map_.MergeFrom(from._impl_.marking_params_map_);
  _this->_impl_.parts_map_.MergeFrom(from._impl_.parts_map_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.job_meta_data_ = new ::open_vector_format::Job_JobMetaData(*from._impl_.job_meta_data_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.job_parameters_ = new ::open_vector_format::JobParameters(*from._impl_.job_parameters_);
  }
  _this->_impl_.num_work_planes_ = from._impl_.num_work_planes_;

  // @@protoc_insertion_point(copy_constructor:open_vector_format.Job)
}
inline void Job::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.work_planes_){arena},
      /* decltype(_impl_.marking_params_map_) */ {::google::protobuf::internal::ArenaInitialized(), arena},
      /* decltype(_impl_.parts_map_) */ {::google::protobuf::internal::ArenaInitialized(), arena},
      decltype(_impl_.job_meta_data_){nullptr},
      decltype(_impl_.job_parameters_){nullptr},
      decltype(_impl_.num_work_planes_){0},
  };
}
Job::~Job() {
  // @@protoc_insertion_point(destructor:open_vector_format.Job)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Job::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.work_planes_.~RepeatedPtrField();
  _impl_.marking_params_map_.~MapField();
  _impl_.parts_map_.~MapField();
  if (this != internal_default_instance()) delete _impl_.job_meta_data_;
  if (this != internal_default_instance()) delete _impl_.job_parameters_;
}
void Job::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void Job::Clear() {
// @@protoc_insertion_point(message_clear_start:open_vector_format.Job)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_work_planes()->Clear();
  _impl_.marking_params_map_.Clear();
  _impl_.parts_map_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.job_meta_data_ != nullptr);
      _impl_.job_meta_data_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.job_parameters_ != nullptr);
      _impl_.job_parameters_->Clear();
    }
  }
  _impl_.num_work_planes_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Job::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 7, 0, 2> Job::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Job, _impl_._has_bits_),
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967232,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    7,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_Job_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .open_vector_format.WorkPlane work_planes = 1;
    {::_pbi::TcParser::FastMtR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(Job, _impl_.work_planes_)}},
    // .open_vector_format.Job.JobMetaData job_meta_data = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 1, PROTOBUF_FIELD_OFFSET(Job, _impl_.job_meta_data_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // .open_vector_format.JobParameters job_parameters = 5;
    {::_pbi::TcParser::FastMtS1,
     {42, 1, 6, PROTOBUF_FIELD_OFFSET(Job, _impl_.job_parameters_)}},
    // int32 num_work_planes = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Job, _impl_.num_work_planes_), 63>(),
     {48, 63, 0, PROTOBUF_FIELD_OFFSET(Job, _impl_.num_work_planes_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .open_vector_format.WorkPlane work_planes = 1;
    {PROTOBUF_FIELD_OFFSET(Job, _impl_.work_planes_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // .open_vector_format.Job.JobMetaData job_meta_data = 2;
    {PROTOBUF_FIELD_OFFSET(Job, _impl_.job_meta_data_), _Internal::kHasBitsOffset + 0, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // map<int32, .open_vector_format.MarkingParams> marking_params_map = 3;
    {PROTOBUF_FIELD_OFFSET(Job, _impl_.marking_params_map_), -1, 2,
    (0 | ::_fl::kFcRepeated | ::_fl::kMap)},
    // map<int32, .open_vector_format.Part> parts_map = 4;
    {PROTOBUF_FIELD_OFFSET(Job, _impl_.parts_map_), -1, 4,
    (0 | ::_fl::kFcRepeated | ::_fl::kMap)},
    // .open_vector_format.JobParameters job_parameters = 5;
    {PROTOBUF_FIELD_OFFSET(Job, _impl_.job_parameters_), _Internal::kHasBitsOffset + 1, 6,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // int32 num_work_planes = 6;
    {PROTOBUF_FIELD_OFFSET(Job, _impl_.num_work_planes_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
  }}, {{
    {::_pbi::TcParser::GetTable<::open_vector_format::WorkPlane>()},
    {::_pbi::TcParser::GetTable<::open_vector_format::Job_JobMetaData>()},
    {::_pbi::TcParser::GetMapAuxInfo<decltype(Job()._impl_.marking_params_map_)>(1, 0, 0)},
    {::_pbi::TcParser::CreateInArenaStorageCb<::open_vector_format::MarkingParams>},
    {::_pbi::TcParser::GetMapAuxInfo<decltype(Job()._impl_.parts_map_)>(1, 0, 0)},
    {::_pbi::TcParser::CreateInArenaStorageCb<::open_vector_format::Part>},
    {::_pbi::TcParser::GetTable<::open_vector_format::JobParameters>()},
  }}, {{
  }},
};

::uint8_t* Job::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:open_vector_format.Job)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .open_vector_format.WorkPlane work_planes = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_work_planes_size()); i < n; i++) {
    const auto& repfield = this->_internal_work_planes().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .open_vector_format.Job.JobMetaData job_meta_data = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::job_meta_data(this),
        _Internal::job_meta_data(this).GetCachedSize(), target, stream);
  }

  // map<int32, .open_vector_format.MarkingParams> marking_params_map = 3;
  if (!_internal_marking_params_map().empty()) {
    using MapType = ::google::protobuf::Map<::int32_t, ::open_vector_format::MarkingParams>;
    using WireHelper = Job_MarkingParamsMapEntry_DoNotUse::Funcs;
    const auto& field = _internal_marking_params_map();

    if (stream->IsSerializationDeterministic() && field.size() > 1) {
      for (const auto& entry : ::google::protobuf::internal::MapSorterFlat<MapType>(field)) {
        target = WireHelper::InternalSerialize(
            3, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : field) {
        target = WireHelper::InternalSerialize(
            3, entry.first, entry.second, target, stream);
      }
    }
  }

  // map<int32, .open_vector_format.Part> parts_map = 4;
  if (!_internal_parts_map().empty()) {
    using MapType = ::google::protobuf::Map<::int32_t, ::open_vector_format::Part>;
    using WireHelper = Job_PartsMapEntry_DoNotUse::Funcs;
    const auto& field = _internal_parts_map();

    if (stream->IsSerializationDeterministic() && field.size() > 1) {
      for (const auto& entry : ::google::protobuf::internal::MapSorterFlat<MapType>(field)) {
        target = WireHelper::InternalSerialize(
            4, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : field) {
        target = WireHelper::InternalSerialize(
            4, entry.first, entry.second, target, stream);
      }
    }
  }

  // .open_vector_format.JobParameters job_parameters = 5;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::job_parameters(this),
        _Internal::job_parameters(this).GetCachedSize(), target, stream);
  }

  // int32 num_work_planes = 6;
  if (this->_internal_num_work_planes() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<6>(
            stream, this->_internal_num_work_planes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:open_vector_format.Job)
  return target;
}

::size_t Job::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:open_vector_format.Job)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .open_vector_format.WorkPlane work_planes = 1;
  total_size += 1UL * this->_internal_work_planes_size();
  for (const auto& msg : this->_internal_work_planes()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // map<int32, .open_vector_format.MarkingParams> marking_params_map = 3;
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_marking_params_map_size());
  for (const auto& entry : _internal_marking_params_map()) {
    total_size += Job_MarkingParamsMapEntry_DoNotUse::Funcs::ByteSizeLong(entry.first, entry.second);
  }
  // map<int32, .open_vector_format.Part> parts_map = 4;
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_parts_map_size());
  for (const auto& entry : _internal_parts_map()) {
    total_size += Job_PartsMapEntry_DoNotUse::Funcs::ByteSizeLong(entry.first, entry.second);
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .open_vector_format.Job.JobMetaData job_meta_data = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.job_meta_data_);
    }

    // .open_vector_format.JobParameters job_parameters = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.job_parameters_);
    }

  }
  // int32 num_work_planes = 6;
  if (this->_internal_num_work_planes() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_num_work_planes());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Job::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    Job::MergeImpl
};
const ::google::protobuf::Message::ClassData*Job::GetClassData() const { return &_class_data_; }


void Job::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Job*>(&to_msg);
  auto& from = static_cast<const Job&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:open_vector_format.Job)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_work_planes()->MergeFrom(from._internal_work_planes());
  _this->_impl_.marking_params_map_.MergeFrom(from._impl_.marking_params_map_);
  _this->_impl_.parts_map_.MergeFrom(from._impl_.parts_map_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_job_meta_data()->::open_vector_format::Job_JobMetaData::MergeFrom(
          from._internal_job_meta_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_job_parameters()->::open_vector_format::JobParameters::MergeFrom(
          from._internal_job_parameters());
    }
  }
  if (from._internal_num_work_planes() != 0) {
    _this->_internal_set_num_work_planes(from._internal_num_work_planes());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Job::CopyFrom(const Job& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:open_vector_format.Job)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Job::IsInitialized() const {
  return true;
}

void Job::InternalSwap(Job* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.work_planes_.InternalSwap(&other->_impl_.work_planes_);
  _impl_.marking_params_map_.InternalSwap(&other->_impl_.marking_params_map_);
  _impl_.parts_map_.InternalSwap(&other->_impl_.parts_map_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Job, _impl_.num_work_planes_)
      + sizeof(Job::_impl_.num_work_planes_)
      - PROTOBUF_FIELD_OFFSET(Job, _impl_.job_meta_data_)>(
          reinterpret_cast<char*>(&_impl_.job_meta_data_),
          reinterpret_cast<char*>(&other->_impl_.job_meta_data_));
}

::google::protobuf::Metadata Job::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_open_5fvector_5fformat_2eproto_getter, &descriptor_table_open_5fvector_5fformat_2eproto_once,
      file_level_metadata_open_5fvector_5fformat_2eproto[3]);
}
// ===================================================================

class JobParameters::_Internal {
 public:
};

JobParameters::JobParameters(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:open_vector_format.JobParameters)
}
JobParameters::JobParameters(const JobParameters& from) : ::google::protobuf::Message() {
  JobParameters* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.shielding_gas_directions_){from._impl_.shielding_gas_directions_},
      decltype(_impl_.material_feed_directions_){from._impl_.material_feed_directions_},
      decltype(_impl_.preheating_temperatur_in_dg_c_){},
      /*decltype(_impl_._cached_size_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _this->_impl_.preheating_temperatur_in_dg_c_ = from._impl_.preheating_temperatur_in_dg_c_;

  // @@protoc_insertion_point(copy_constructor:open_vector_format.JobParameters)
}
inline void JobParameters::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.shielding_gas_directions_){arena},
      decltype(_impl_.material_feed_directions_){arena},
      decltype(_impl_.preheating_temperatur_in_dg_c_){0},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
JobParameters::~JobParameters() {
  // @@protoc_insertion_point(destructor:open_vector_format.JobParameters)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void JobParameters::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.shielding_gas_directions_.~RepeatedField();
  _impl_.material_feed_directions_.~RepeatedField();
}
void JobParameters::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void JobParameters::Clear() {
// @@protoc_insertion_point(message_clear_start:open_vector_format.JobParameters)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_shielding_gas_directions()->Clear();
  _internal_mutable_material_feed_directions()->Clear();
  _impl_.preheating_temperatur_in_dg_c_ = 0;
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* JobParameters::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2> JobParameters::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_JobParameters_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // double preheating_temperatur_in_dg_c = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(JobParameters, _impl_.preheating_temperatur_in_dg_c_)}},
    // repeated double shielding_gas_directions = 2;
    {::_pbi::TcParser::FastF64P1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(JobParameters, _impl_.shielding_gas_directions_)}},
    // repeated double material_feed_directions = 3;
    {::_pbi::TcParser::FastF64P1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(JobParameters, _impl_.material_feed_directions_)}},
  }}, {{
    65535, 65535
  }}, {{
    // double preheating_temperatur_in_dg_c = 1;
    {PROTOBUF_FIELD_OFFSET(JobParameters, _impl_.preheating_temperatur_in_dg_c_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // repeated double shielding_gas_directions = 2;
    {PROTOBUF_FIELD_OFFSET(JobParameters, _impl_.shielding_gas_directions_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedDouble)},
    // repeated double material_feed_directions = 3;
    {PROTOBUF_FIELD_OFFSET(JobParameters, _impl_.material_feed_directions_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedDouble)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* JobParameters::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:open_vector_format.JobParameters)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double preheating_temperatur_in_dg_c = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_preheating_temperatur_in_dg_c = this->_internal_preheating_temperatur_in_dg_c();
  ::uint64_t raw_preheating_temperatur_in_dg_c;
  memcpy(&raw_preheating_temperatur_in_dg_c, &tmp_preheating_temperatur_in_dg_c, sizeof(tmp_preheating_temperatur_in_dg_c));
  if (raw_preheating_temperatur_in_dg_c != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_preheating_temperatur_in_dg_c(), target);
  }

  // repeated double shielding_gas_directions = 2;
  if (this->_internal_shielding_gas_directions_size() > 0) {
    target = stream->WriteFixedPacked(2, _internal_shielding_gas_directions(), target);
  }

  // repeated double material_feed_directions = 3;
  if (this->_internal_material_feed_directions_size() > 0) {
    target = stream->WriteFixedPacked(3, _internal_material_feed_directions(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:open_vector_format.JobParameters)
  return target;
}

::size_t JobParameters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:open_vector_format.JobParameters)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double shielding_gas_directions = 2;
  {
    std::size_t data_size = std::size_t{8} *
        ::_pbi::FromIntSize(this->_internal_shielding_gas_directions_size())
    ;
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // repeated double material_feed_directions = 3;
  {
    std::size_t data_size = std::size_t{8} *
        ::_pbi::FromIntSize(this->_internal_material_feed_directions_size())
    ;
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // double preheating_temperatur_in_dg_c = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_preheating_temperatur_in_dg_c = this->_internal_preheating_temperatur_in_dg_c();
  ::uint64_t raw_preheating_temperatur_in_dg_c;
  memcpy(&raw_preheating_temperatur_in_dg_c, &tmp_preheating_temperatur_in_dg_c, sizeof(tmp_preheating_temperatur_in_dg_c));
  if (raw_preheating_temperatur_in_dg_c != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData JobParameters::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    JobParameters::MergeImpl
};
const ::google::protobuf::Message::ClassData*JobParameters::GetClassData() const { return &_class_data_; }


void JobParameters::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<JobParameters*>(&to_msg);
  auto& from = static_cast<const JobParameters&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:open_vector_format.JobParameters)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_shielding_gas_directions()->MergeFrom(from._internal_shielding_gas_directions());
  _this->_internal_mutable_material_feed_directions()->MergeFrom(from._internal_material_feed_directions());
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_preheating_temperatur_in_dg_c = from._internal_preheating_temperatur_in_dg_c();
  ::uint64_t raw_preheating_temperatur_in_dg_c;
  memcpy(&raw_preheating_temperatur_in_dg_c, &tmp_preheating_temperatur_in_dg_c, sizeof(tmp_preheating_temperatur_in_dg_c));
  if (raw_preheating_temperatur_in_dg_c != 0) {
    _this->_internal_set_preheating_temperatur_in_dg_c(from._internal_preheating_temperatur_in_dg_c());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void JobParameters::CopyFrom(const JobParameters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:open_vector_format.JobParameters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool JobParameters::IsInitialized() const {
  return true;
}

void JobParameters::InternalSwap(JobParameters* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.shielding_gas_directions_.InternalSwap(&other->_impl_.shielding_gas_directions_);
  _impl_.material_feed_directions_.InternalSwap(&other->_impl_.material_feed_directions_);
        swap(_impl_.preheating_temperatur_in_dg_c_, other->_impl_.preheating_temperatur_in_dg_c_);
}

::google::protobuf::Metadata JobParameters::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_open_5fvector_5fformat_2eproto_getter, &descriptor_table_open_5fvector_5fformat_2eproto_once,
      file_level_metadata_open_5fvector_5fformat_2eproto[4]);
}
// ===================================================================

class MarkingParams::_Internal {
 public:
  using HasBits = decltype(std::declval<MarkingParams>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_._has_bits_);
  static const ::open_vector_format::PowerGradientParams& powergradient(const MarkingParams* msg);
  static void set_has_powergradient(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::open_vector_format::PowerGradientParams& MarkingParams::_Internal::powergradient(const MarkingParams* msg) {
  return *msg->_impl_.powergradient_;
}
MarkingParams::MarkingParams(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:open_vector_format.MarkingParams)
}
MarkingParams::MarkingParams(const MarkingParams& from) : ::google::protobuf::Message() {
  MarkingParams* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.name_){},
      decltype(_impl_.powergradient_){nullptr},
      decltype(_impl_.laser_power_in_w_){},
      decltype(_impl_.laser_speed_in_mm_per_s_){},
      decltype(_impl_.laser_focus_shift_in_mm_){},
      decltype(_impl_.point_exposure_time_in_us_){},
      decltype(_impl_.jump_speed_in_mm_s_){},
      decltype(_impl_.point_exposure_repetitions_){},
      decltype(_impl_.repetition_rate_in_hz_){},
      decltype(_impl_.laser_pulses_per_burst_){},
      decltype(_impl_.pulsedurationinfemtoseconds_){},
      decltype(_impl_.marking_mode_){},
      decltype(_impl_.jump_delay_in_us_){},
      decltype(_impl_.laser_off_delay_in_us_){},
      decltype(_impl_.laser_on_delay_in_us_){},
      decltype(_impl_.mark_delay_in_us_){},
      decltype(_impl_.polygon_delay_in_us_){},
      decltype(_impl_.time_lag_in_us_){},
      decltype(_impl_.laser_on_shift_in_us_){},
      decltype(_impl_.limit_){},
      decltype(_impl_.n_prev_in_us_){},
      decltype(_impl_.n_post_in_us_){},
      decltype(_impl_.wob_frequency_in_hz_){},
      decltype(_impl_.wob_amp_long_in_mm_){},
      decltype(_impl_.wob_amp_trans_in_mm_){},
      decltype(_impl_.wobble_mode_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.powergradient_ = new ::open_vector_format::PowerGradientParams(*from._impl_.powergradient_);
  }
  ::memcpy(&_impl_.laser_power_in_w_, &from._impl_.laser_power_in_w_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.wobble_mode_) -
    reinterpret_cast<char*>(&_impl_.laser_power_in_w_)) + sizeof(_impl_.wobble_mode_));

  // @@protoc_insertion_point(copy_constructor:open_vector_format.MarkingParams)
}
inline void MarkingParams::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.name_){},
      decltype(_impl_.powergradient_){nullptr},
      decltype(_impl_.laser_power_in_w_){0},
      decltype(_impl_.laser_speed_in_mm_per_s_){0},
      decltype(_impl_.laser_focus_shift_in_mm_){0},
      decltype(_impl_.point_exposure_time_in_us_){0},
      decltype(_impl_.jump_speed_in_mm_s_){0},
      decltype(_impl_.point_exposure_repetitions_){0},
      decltype(_impl_.repetition_rate_in_hz_){::uint64_t{0u}},
      decltype(_impl_.laser_pulses_per_burst_){::uint64_t{0u}},
      decltype(_impl_.pulsedurationinfemtoseconds_){::uint64_t{0u}},
      decltype(_impl_.marking_mode_){0},
      decltype(_impl_.jump_delay_in_us_){0},
      decltype(_impl_.laser_off_delay_in_us_){0},
      decltype(_impl_.laser_on_delay_in_us_){0},
      decltype(_impl_.mark_delay_in_us_){0},
      decltype(_impl_.polygon_delay_in_us_){0},
      decltype(_impl_.time_lag_in_us_){0},
      decltype(_impl_.laser_on_shift_in_us_){0},
      decltype(_impl_.limit_){0},
      decltype(_impl_.n_prev_in_us_){0},
      decltype(_impl_.n_post_in_us_){0},
      decltype(_impl_.wob_frequency_in_hz_){0},
      decltype(_impl_.wob_amp_long_in_mm_){0},
      decltype(_impl_.wob_amp_trans_in_mm_){0},
      decltype(_impl_.wobble_mode_){0},
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}
MarkingParams::~MarkingParams() {
  // @@protoc_insertion_point(destructor:open_vector_format.MarkingParams)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void MarkingParams::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.powergradient_;
}
void MarkingParams::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void MarkingParams::Clear() {
// @@protoc_insertion_point(message_clear_start:open_vector_format.MarkingParams)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.powergradient_ != nullptr);
    _impl_.powergradient_->Clear();
  }
  ::memset(&_impl_.laser_power_in_w_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.wobble_mode_) -
      reinterpret_cast<char*>(&_impl_.laser_power_in_w_)) + sizeof(_impl_.wobble_mode_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* MarkingParams::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 26, 1, 69, 2> MarkingParams::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_._has_bits_),
    0, // no _extensions_
    26, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4227858432,  // skipmap
    offsetof(decltype(_table_), field_entries),
    26,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_MarkingParams_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // float laser_power_in_w = 1;
    {::_pbi::TcParser::FastF32S1,
     {13, 63, 0, PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.laser_power_in_w_)}},
    // float laser_speed_in_mm_per_s = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.laser_speed_in_mm_per_s_)}},
    // float laser_focus_shift_in_mm = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 63, 0, PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.laser_focus_shift_in_mm_)}},
    // float point_exposure_time_in_us = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 63, 0, PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.point_exposure_time_in_us_)}},
    // float jump_speed_in_mm_s = 5;
    {::_pbi::TcParser::FastF32S1,
     {45, 63, 0, PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.jump_speed_in_mm_s_)}},
    // float point_exposure_repetitions = 6;
    {::_pbi::TcParser::FastF32S1,
     {53, 63, 0, PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.point_exposure_repetitions_)}},
    // uint64 repetition_rate_in_hz = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(MarkingParams, _impl_.repetition_rate_in_hz_), 63>(),
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.repetition_rate_in_hz_)}},
    // uint64 laser_pulses_per_burst = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(MarkingParams, _impl_.laser_pulses_per_burst_), 63>(),
     {64, 63, 0, PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.laser_pulses_per_burst_)}},
    // uint64 pulseDurationInFemtoseconds = 9;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(MarkingParams, _impl_.pulsedurationinfemtoseconds_), 63>(),
     {72, 63, 0, PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.pulsedurationinfemtoseconds_)}},
    // .open_vector_format.MarkingParams.MarkingMode marking_mode = 10;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(MarkingParams, _impl_.marking_mode_), 63>(),
     {80, 63, 0, PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.marking_mode_)}},
    // float jump_delay_in_us = 11;
    {::_pbi::TcParser::FastF32S1,
     {93, 63, 0, PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.jump_delay_in_us_)}},
    // float laser_off_delay_in_us = 12;
    {::_pbi::TcParser::FastF32S1,
     {101, 63, 0, PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.laser_off_delay_in_us_)}},
    // float laser_on_delay_in_us = 13;
    {::_pbi::TcParser::FastF32S1,
     {109, 63, 0, PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.laser_on_delay_in_us_)}},
    // float mark_delay_in_us = 14;
    {::_pbi::TcParser::FastF32S1,
     {117, 63, 0, PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.mark_delay_in_us_)}},
    // float polygon_delay_in_us = 15;
    {::_pbi::TcParser::FastF32S1,
     {125, 63, 0, PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.polygon_delay_in_us_)}},
    // float time_lag_in_us = 16;
    {::_pbi::TcParser::FastF32S2,
     {389, 63, 0, PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.time_lag_in_us_)}},
    // float laser_on_shift_in_us = 17;
    {::_pbi::TcParser::FastF32S2,
     {397, 63, 0, PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.laser_on_shift_in_us_)}},
    // float limit = 18;
    {::_pbi::TcParser::FastF32S2,
     {405, 63, 0, PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.limit_)}},
    // float n_prev_in_us = 19;
    {::_pbi::TcParser::FastF32S2,
     {413, 63, 0, PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.n_prev_in_us_)}},
    // float n_post_in_us = 20;
    {::_pbi::TcParser::FastF32S2,
     {421, 63, 0, PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.n_post_in_us_)}},
    // float wob_frequency_in_hz = 21;
    {::_pbi::TcParser::FastF32S2,
     {429, 63, 0, PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.wob_frequency_in_hz_)}},
    // float wob_amp_long_in_mm = 22;
    {::_pbi::TcParser::FastF32S2,
     {437, 63, 0, PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.wob_amp_long_in_mm_)}},
    // float wob_amp_trans_in_mm = 23;
    {::_pbi::TcParser::FastF32S2,
     {445, 63, 0, PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.wob_amp_trans_in_mm_)}},
    // .open_vector_format.MarkingParams.WobbleMode wobble_mode = 24;
    {::_pbi::TcParser::FastV32S2,
     {448, 63, 0, PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.wobble_mode_)}},
    // .open_vector_format.PowerGradientParams powerGradient = 25;
    {::_pbi::TcParser::FastMtS2,
     {458, 0, 0, PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.powergradient_)}},
    // string name = 26;
    {::_pbi::TcParser::FastUS2,
     {466, 63, 0, PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.name_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // float laser_power_in_w = 1;
    {PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.laser_power_in_w_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float laser_speed_in_mm_per_s = 2;
    {PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.laser_speed_in_mm_per_s_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float laser_focus_shift_in_mm = 3;
    {PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.laser_focus_shift_in_mm_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float point_exposure_time_in_us = 4;
    {PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.point_exposure_time_in_us_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float jump_speed_in_mm_s = 5;
    {PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.jump_speed_in_mm_s_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float point_exposure_repetitions = 6;
    {PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.point_exposure_repetitions_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // uint64 repetition_rate_in_hz = 7;
    {PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.repetition_rate_in_hz_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt64)},
    // uint64 laser_pulses_per_burst = 8;
    {PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.laser_pulses_per_burst_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt64)},
    // uint64 pulseDurationInFemtoseconds = 9;
    {PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.pulsedurationinfemtoseconds_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt64)},
    // .open_vector_format.MarkingParams.MarkingMode marking_mode = 10;
    {PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.marking_mode_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // float jump_delay_in_us = 11;
    {PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.jump_delay_in_us_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float laser_off_delay_in_us = 12;
    {PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.laser_off_delay_in_us_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float laser_on_delay_in_us = 13;
    {PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.laser_on_delay_in_us_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float mark_delay_in_us = 14;
    {PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.mark_delay_in_us_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float polygon_delay_in_us = 15;
    {PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.polygon_delay_in_us_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float time_lag_in_us = 16;
    {PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.time_lag_in_us_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float laser_on_shift_in_us = 17;
    {PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.laser_on_shift_in_us_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float limit = 18;
    {PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.limit_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float n_prev_in_us = 19;
    {PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.n_prev_in_us_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float n_post_in_us = 20;
    {PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.n_post_in_us_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float wob_frequency_in_hz = 21;
    {PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.wob_frequency_in_hz_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float wob_amp_long_in_mm = 22;
    {PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.wob_amp_long_in_mm_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float wob_amp_trans_in_mm = 23;
    {PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.wob_amp_trans_in_mm_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // .open_vector_format.MarkingParams.WobbleMode wobble_mode = 24;
    {PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.wobble_mode_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .open_vector_format.PowerGradientParams powerGradient = 25;
    {PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.powergradient_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // string name = 26;
    {PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.name_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }}, {{
    {::_pbi::TcParser::GetTable<::open_vector_format::PowerGradientParams>()},
  }}, {{
    "\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\0\0"
    "open_vector_format.MarkingParams"
    "name"
  }},
};

::uint8_t* MarkingParams::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:open_vector_format.MarkingParams)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // float laser_power_in_w = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_laser_power_in_w = this->_internal_laser_power_in_w();
  ::uint32_t raw_laser_power_in_w;
  memcpy(&raw_laser_power_in_w, &tmp_laser_power_in_w, sizeof(tmp_laser_power_in_w));
  if (raw_laser_power_in_w != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_laser_power_in_w(), target);
  }

  // float laser_speed_in_mm_per_s = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_laser_speed_in_mm_per_s = this->_internal_laser_speed_in_mm_per_s();
  ::uint32_t raw_laser_speed_in_mm_per_s;
  memcpy(&raw_laser_speed_in_mm_per_s, &tmp_laser_speed_in_mm_per_s, sizeof(tmp_laser_speed_in_mm_per_s));
  if (raw_laser_speed_in_mm_per_s != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_laser_speed_in_mm_per_s(), target);
  }

  // float laser_focus_shift_in_mm = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_laser_focus_shift_in_mm = this->_internal_laser_focus_shift_in_mm();
  ::uint32_t raw_laser_focus_shift_in_mm;
  memcpy(&raw_laser_focus_shift_in_mm, &tmp_laser_focus_shift_in_mm, sizeof(tmp_laser_focus_shift_in_mm));
  if (raw_laser_focus_shift_in_mm != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_laser_focus_shift_in_mm(), target);
  }

  // float point_exposure_time_in_us = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_point_exposure_time_in_us = this->_internal_point_exposure_time_in_us();
  ::uint32_t raw_point_exposure_time_in_us;
  memcpy(&raw_point_exposure_time_in_us, &tmp_point_exposure_time_in_us, sizeof(tmp_point_exposure_time_in_us));
  if (raw_point_exposure_time_in_us != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_point_exposure_time_in_us(), target);
  }

  // float jump_speed_in_mm_s = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_jump_speed_in_mm_s = this->_internal_jump_speed_in_mm_s();
  ::uint32_t raw_jump_speed_in_mm_s;
  memcpy(&raw_jump_speed_in_mm_s, &tmp_jump_speed_in_mm_s, sizeof(tmp_jump_speed_in_mm_s));
  if (raw_jump_speed_in_mm_s != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_jump_speed_in_mm_s(), target);
  }

  // float point_exposure_repetitions = 6;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_point_exposure_repetitions = this->_internal_point_exposure_repetitions();
  ::uint32_t raw_point_exposure_repetitions;
  memcpy(&raw_point_exposure_repetitions, &tmp_point_exposure_repetitions, sizeof(tmp_point_exposure_repetitions));
  if (raw_point_exposure_repetitions != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        6, this->_internal_point_exposure_repetitions(), target);
  }

  // uint64 repetition_rate_in_hz = 7;
  if (this->_internal_repetition_rate_in_hz() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        7, this->_internal_repetition_rate_in_hz(), target);
  }

  // uint64 laser_pulses_per_burst = 8;
  if (this->_internal_laser_pulses_per_burst() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        8, this->_internal_laser_pulses_per_burst(), target);
  }

  // uint64 pulseDurationInFemtoseconds = 9;
  if (this->_internal_pulsedurationinfemtoseconds() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        9, this->_internal_pulsedurationinfemtoseconds(), target);
  }

  // .open_vector_format.MarkingParams.MarkingMode marking_mode = 10;
  if (this->_internal_marking_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        10, this->_internal_marking_mode(), target);
  }

  // float jump_delay_in_us = 11;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_jump_delay_in_us = this->_internal_jump_delay_in_us();
  ::uint32_t raw_jump_delay_in_us;
  memcpy(&raw_jump_delay_in_us, &tmp_jump_delay_in_us, sizeof(tmp_jump_delay_in_us));
  if (raw_jump_delay_in_us != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        11, this->_internal_jump_delay_in_us(), target);
  }

  // float laser_off_delay_in_us = 12;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_laser_off_delay_in_us = this->_internal_laser_off_delay_in_us();
  ::uint32_t raw_laser_off_delay_in_us;
  memcpy(&raw_laser_off_delay_in_us, &tmp_laser_off_delay_in_us, sizeof(tmp_laser_off_delay_in_us));
  if (raw_laser_off_delay_in_us != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        12, this->_internal_laser_off_delay_in_us(), target);
  }

  // float laser_on_delay_in_us = 13;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_laser_on_delay_in_us = this->_internal_laser_on_delay_in_us();
  ::uint32_t raw_laser_on_delay_in_us;
  memcpy(&raw_laser_on_delay_in_us, &tmp_laser_on_delay_in_us, sizeof(tmp_laser_on_delay_in_us));
  if (raw_laser_on_delay_in_us != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        13, this->_internal_laser_on_delay_in_us(), target);
  }

  // float mark_delay_in_us = 14;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_mark_delay_in_us = this->_internal_mark_delay_in_us();
  ::uint32_t raw_mark_delay_in_us;
  memcpy(&raw_mark_delay_in_us, &tmp_mark_delay_in_us, sizeof(tmp_mark_delay_in_us));
  if (raw_mark_delay_in_us != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        14, this->_internal_mark_delay_in_us(), target);
  }

  // float polygon_delay_in_us = 15;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_polygon_delay_in_us = this->_internal_polygon_delay_in_us();
  ::uint32_t raw_polygon_delay_in_us;
  memcpy(&raw_polygon_delay_in_us, &tmp_polygon_delay_in_us, sizeof(tmp_polygon_delay_in_us));
  if (raw_polygon_delay_in_us != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        15, this->_internal_polygon_delay_in_us(), target);
  }

  // float time_lag_in_us = 16;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_time_lag_in_us = this->_internal_time_lag_in_us();
  ::uint32_t raw_time_lag_in_us;
  memcpy(&raw_time_lag_in_us, &tmp_time_lag_in_us, sizeof(tmp_time_lag_in_us));
  if (raw_time_lag_in_us != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        16, this->_internal_time_lag_in_us(), target);
  }

  // float laser_on_shift_in_us = 17;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_laser_on_shift_in_us = this->_internal_laser_on_shift_in_us();
  ::uint32_t raw_laser_on_shift_in_us;
  memcpy(&raw_laser_on_shift_in_us, &tmp_laser_on_shift_in_us, sizeof(tmp_laser_on_shift_in_us));
  if (raw_laser_on_shift_in_us != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        17, this->_internal_laser_on_shift_in_us(), target);
  }

  // float limit = 18;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_limit = this->_internal_limit();
  ::uint32_t raw_limit;
  memcpy(&raw_limit, &tmp_limit, sizeof(tmp_limit));
  if (raw_limit != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        18, this->_internal_limit(), target);
  }

  // float n_prev_in_us = 19;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_n_prev_in_us = this->_internal_n_prev_in_us();
  ::uint32_t raw_n_prev_in_us;
  memcpy(&raw_n_prev_in_us, &tmp_n_prev_in_us, sizeof(tmp_n_prev_in_us));
  if (raw_n_prev_in_us != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        19, this->_internal_n_prev_in_us(), target);
  }

  // float n_post_in_us = 20;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_n_post_in_us = this->_internal_n_post_in_us();
  ::uint32_t raw_n_post_in_us;
  memcpy(&raw_n_post_in_us, &tmp_n_post_in_us, sizeof(tmp_n_post_in_us));
  if (raw_n_post_in_us != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        20, this->_internal_n_post_in_us(), target);
  }

  // float wob_frequency_in_hz = 21;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_wob_frequency_in_hz = this->_internal_wob_frequency_in_hz();
  ::uint32_t raw_wob_frequency_in_hz;
  memcpy(&raw_wob_frequency_in_hz, &tmp_wob_frequency_in_hz, sizeof(tmp_wob_frequency_in_hz));
  if (raw_wob_frequency_in_hz != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        21, this->_internal_wob_frequency_in_hz(), target);
  }

  // float wob_amp_long_in_mm = 22;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_wob_amp_long_in_mm = this->_internal_wob_amp_long_in_mm();
  ::uint32_t raw_wob_amp_long_in_mm;
  memcpy(&raw_wob_amp_long_in_mm, &tmp_wob_amp_long_in_mm, sizeof(tmp_wob_amp_long_in_mm));
  if (raw_wob_amp_long_in_mm != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        22, this->_internal_wob_amp_long_in_mm(), target);
  }

  // float wob_amp_trans_in_mm = 23;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_wob_amp_trans_in_mm = this->_internal_wob_amp_trans_in_mm();
  ::uint32_t raw_wob_amp_trans_in_mm;
  memcpy(&raw_wob_amp_trans_in_mm, &tmp_wob_amp_trans_in_mm, sizeof(tmp_wob_amp_trans_in_mm));
  if (raw_wob_amp_trans_in_mm != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        23, this->_internal_wob_amp_trans_in_mm(), target);
  }

  // .open_vector_format.MarkingParams.WobbleMode wobble_mode = 24;
  if (this->_internal_wobble_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        24, this->_internal_wobble_mode(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .open_vector_format.PowerGradientParams powerGradient = 25;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(25, _Internal::powergradient(this),
        _Internal::powergradient(this).GetCachedSize(), target, stream);
  }

  // string name = 26;
  if (!this->_internal_name().empty()) {
    const std::string& _s = this->_internal_name();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "open_vector_format.MarkingParams.name");
    target = stream->WriteStringMaybeAliased(26, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:open_vector_format.MarkingParams)
  return target;
}

::size_t MarkingParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:open_vector_format.MarkingParams)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 26;
  if (!this->_internal_name().empty()) {
    total_size += 2 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_name());
  }

  // .open_vector_format.PowerGradientParams powerGradient = 25;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *_impl_.powergradient_);
  }

  // float laser_power_in_w = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_laser_power_in_w = this->_internal_laser_power_in_w();
  ::uint32_t raw_laser_power_in_w;
  memcpy(&raw_laser_power_in_w, &tmp_laser_power_in_w, sizeof(tmp_laser_power_in_w));
  if (raw_laser_power_in_w != 0) {
    total_size += 5;
  }

  // float laser_speed_in_mm_per_s = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_laser_speed_in_mm_per_s = this->_internal_laser_speed_in_mm_per_s();
  ::uint32_t raw_laser_speed_in_mm_per_s;
  memcpy(&raw_laser_speed_in_mm_per_s, &tmp_laser_speed_in_mm_per_s, sizeof(tmp_laser_speed_in_mm_per_s));
  if (raw_laser_speed_in_mm_per_s != 0) {
    total_size += 5;
  }

  // float laser_focus_shift_in_mm = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_laser_focus_shift_in_mm = this->_internal_laser_focus_shift_in_mm();
  ::uint32_t raw_laser_focus_shift_in_mm;
  memcpy(&raw_laser_focus_shift_in_mm, &tmp_laser_focus_shift_in_mm, sizeof(tmp_laser_focus_shift_in_mm));
  if (raw_laser_focus_shift_in_mm != 0) {
    total_size += 5;
  }

  // float point_exposure_time_in_us = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_point_exposure_time_in_us = this->_internal_point_exposure_time_in_us();
  ::uint32_t raw_point_exposure_time_in_us;
  memcpy(&raw_point_exposure_time_in_us, &tmp_point_exposure_time_in_us, sizeof(tmp_point_exposure_time_in_us));
  if (raw_point_exposure_time_in_us != 0) {
    total_size += 5;
  }

  // float jump_speed_in_mm_s = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_jump_speed_in_mm_s = this->_internal_jump_speed_in_mm_s();
  ::uint32_t raw_jump_speed_in_mm_s;
  memcpy(&raw_jump_speed_in_mm_s, &tmp_jump_speed_in_mm_s, sizeof(tmp_jump_speed_in_mm_s));
  if (raw_jump_speed_in_mm_s != 0) {
    total_size += 5;
  }

  // float point_exposure_repetitions = 6;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_point_exposure_repetitions = this->_internal_point_exposure_repetitions();
  ::uint32_t raw_point_exposure_repetitions;
  memcpy(&raw_point_exposure_repetitions, &tmp_point_exposure_repetitions, sizeof(tmp_point_exposure_repetitions));
  if (raw_point_exposure_repetitions != 0) {
    total_size += 5;
  }

  // uint64 repetition_rate_in_hz = 7;
  if (this->_internal_repetition_rate_in_hz() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_repetition_rate_in_hz());
  }

  // uint64 laser_pulses_per_burst = 8;
  if (this->_internal_laser_pulses_per_burst() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_laser_pulses_per_burst());
  }

  // uint64 pulseDurationInFemtoseconds = 9;
  if (this->_internal_pulsedurationinfemtoseconds() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_pulsedurationinfemtoseconds());
  }

  // .open_vector_format.MarkingParams.MarkingMode marking_mode = 10;
  if (this->_internal_marking_mode() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_marking_mode());
  }

  // float jump_delay_in_us = 11;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_jump_delay_in_us = this->_internal_jump_delay_in_us();
  ::uint32_t raw_jump_delay_in_us;
  memcpy(&raw_jump_delay_in_us, &tmp_jump_delay_in_us, sizeof(tmp_jump_delay_in_us));
  if (raw_jump_delay_in_us != 0) {
    total_size += 5;
  }

  // float laser_off_delay_in_us = 12;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_laser_off_delay_in_us = this->_internal_laser_off_delay_in_us();
  ::uint32_t raw_laser_off_delay_in_us;
  memcpy(&raw_laser_off_delay_in_us, &tmp_laser_off_delay_in_us, sizeof(tmp_laser_off_delay_in_us));
  if (raw_laser_off_delay_in_us != 0) {
    total_size += 5;
  }

  // float laser_on_delay_in_us = 13;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_laser_on_delay_in_us = this->_internal_laser_on_delay_in_us();
  ::uint32_t raw_laser_on_delay_in_us;
  memcpy(&raw_laser_on_delay_in_us, &tmp_laser_on_delay_in_us, sizeof(tmp_laser_on_delay_in_us));
  if (raw_laser_on_delay_in_us != 0) {
    total_size += 5;
  }

  // float mark_delay_in_us = 14;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_mark_delay_in_us = this->_internal_mark_delay_in_us();
  ::uint32_t raw_mark_delay_in_us;
  memcpy(&raw_mark_delay_in_us, &tmp_mark_delay_in_us, sizeof(tmp_mark_delay_in_us));
  if (raw_mark_delay_in_us != 0) {
    total_size += 5;
  }

  // float polygon_delay_in_us = 15;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_polygon_delay_in_us = this->_internal_polygon_delay_in_us();
  ::uint32_t raw_polygon_delay_in_us;
  memcpy(&raw_polygon_delay_in_us, &tmp_polygon_delay_in_us, sizeof(tmp_polygon_delay_in_us));
  if (raw_polygon_delay_in_us != 0) {
    total_size += 5;
  }

  // float time_lag_in_us = 16;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_time_lag_in_us = this->_internal_time_lag_in_us();
  ::uint32_t raw_time_lag_in_us;
  memcpy(&raw_time_lag_in_us, &tmp_time_lag_in_us, sizeof(tmp_time_lag_in_us));
  if (raw_time_lag_in_us != 0) {
    total_size += 6;
  }

  // float laser_on_shift_in_us = 17;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_laser_on_shift_in_us = this->_internal_laser_on_shift_in_us();
  ::uint32_t raw_laser_on_shift_in_us;
  memcpy(&raw_laser_on_shift_in_us, &tmp_laser_on_shift_in_us, sizeof(tmp_laser_on_shift_in_us));
  if (raw_laser_on_shift_in_us != 0) {
    total_size += 6;
  }

  // float limit = 18;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_limit = this->_internal_limit();
  ::uint32_t raw_limit;
  memcpy(&raw_limit, &tmp_limit, sizeof(tmp_limit));
  if (raw_limit != 0) {
    total_size += 6;
  }

  // float n_prev_in_us = 19;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_n_prev_in_us = this->_internal_n_prev_in_us();
  ::uint32_t raw_n_prev_in_us;
  memcpy(&raw_n_prev_in_us, &tmp_n_prev_in_us, sizeof(tmp_n_prev_in_us));
  if (raw_n_prev_in_us != 0) {
    total_size += 6;
  }

  // float n_post_in_us = 20;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_n_post_in_us = this->_internal_n_post_in_us();
  ::uint32_t raw_n_post_in_us;
  memcpy(&raw_n_post_in_us, &tmp_n_post_in_us, sizeof(tmp_n_post_in_us));
  if (raw_n_post_in_us != 0) {
    total_size += 6;
  }

  // float wob_frequency_in_hz = 21;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_wob_frequency_in_hz = this->_internal_wob_frequency_in_hz();
  ::uint32_t raw_wob_frequency_in_hz;
  memcpy(&raw_wob_frequency_in_hz, &tmp_wob_frequency_in_hz, sizeof(tmp_wob_frequency_in_hz));
  if (raw_wob_frequency_in_hz != 0) {
    total_size += 6;
  }

  // float wob_amp_long_in_mm = 22;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_wob_amp_long_in_mm = this->_internal_wob_amp_long_in_mm();
  ::uint32_t raw_wob_amp_long_in_mm;
  memcpy(&raw_wob_amp_long_in_mm, &tmp_wob_amp_long_in_mm, sizeof(tmp_wob_amp_long_in_mm));
  if (raw_wob_amp_long_in_mm != 0) {
    total_size += 6;
  }

  // float wob_amp_trans_in_mm = 23;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_wob_amp_trans_in_mm = this->_internal_wob_amp_trans_in_mm();
  ::uint32_t raw_wob_amp_trans_in_mm;
  memcpy(&raw_wob_amp_trans_in_mm, &tmp_wob_amp_trans_in_mm, sizeof(tmp_wob_amp_trans_in_mm));
  if (raw_wob_amp_trans_in_mm != 0) {
    total_size += 6;
  }

  // .open_vector_format.MarkingParams.WobbleMode wobble_mode = 24;
  if (this->_internal_wobble_mode() != 0) {
    total_size += 2 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_wobble_mode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData MarkingParams::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    MarkingParams::MergeImpl
};
const ::google::protobuf::Message::ClassData*MarkingParams::GetClassData() const { return &_class_data_; }


void MarkingParams::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<MarkingParams*>(&to_msg);
  auto& from = static_cast<const MarkingParams&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:open_vector_format.MarkingParams)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_powergradient()->::open_vector_format::PowerGradientParams::MergeFrom(
        from._internal_powergradient());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_laser_power_in_w = from._internal_laser_power_in_w();
  ::uint32_t raw_laser_power_in_w;
  memcpy(&raw_laser_power_in_w, &tmp_laser_power_in_w, sizeof(tmp_laser_power_in_w));
  if (raw_laser_power_in_w != 0) {
    _this->_internal_set_laser_power_in_w(from._internal_laser_power_in_w());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_laser_speed_in_mm_per_s = from._internal_laser_speed_in_mm_per_s();
  ::uint32_t raw_laser_speed_in_mm_per_s;
  memcpy(&raw_laser_speed_in_mm_per_s, &tmp_laser_speed_in_mm_per_s, sizeof(tmp_laser_speed_in_mm_per_s));
  if (raw_laser_speed_in_mm_per_s != 0) {
    _this->_internal_set_laser_speed_in_mm_per_s(from._internal_laser_speed_in_mm_per_s());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_laser_focus_shift_in_mm = from._internal_laser_focus_shift_in_mm();
  ::uint32_t raw_laser_focus_shift_in_mm;
  memcpy(&raw_laser_focus_shift_in_mm, &tmp_laser_focus_shift_in_mm, sizeof(tmp_laser_focus_shift_in_mm));
  if (raw_laser_focus_shift_in_mm != 0) {
    _this->_internal_set_laser_focus_shift_in_mm(from._internal_laser_focus_shift_in_mm());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_point_exposure_time_in_us = from._internal_point_exposure_time_in_us();
  ::uint32_t raw_point_exposure_time_in_us;
  memcpy(&raw_point_exposure_time_in_us, &tmp_point_exposure_time_in_us, sizeof(tmp_point_exposure_time_in_us));
  if (raw_point_exposure_time_in_us != 0) {
    _this->_internal_set_point_exposure_time_in_us(from._internal_point_exposure_time_in_us());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_jump_speed_in_mm_s = from._internal_jump_speed_in_mm_s();
  ::uint32_t raw_jump_speed_in_mm_s;
  memcpy(&raw_jump_speed_in_mm_s, &tmp_jump_speed_in_mm_s, sizeof(tmp_jump_speed_in_mm_s));
  if (raw_jump_speed_in_mm_s != 0) {
    _this->_internal_set_jump_speed_in_mm_s(from._internal_jump_speed_in_mm_s());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_point_exposure_repetitions = from._internal_point_exposure_repetitions();
  ::uint32_t raw_point_exposure_repetitions;
  memcpy(&raw_point_exposure_repetitions, &tmp_point_exposure_repetitions, sizeof(tmp_point_exposure_repetitions));
  if (raw_point_exposure_repetitions != 0) {
    _this->_internal_set_point_exposure_repetitions(from._internal_point_exposure_repetitions());
  }
  if (from._internal_repetition_rate_in_hz() != 0) {
    _this->_internal_set_repetition_rate_in_hz(from._internal_repetition_rate_in_hz());
  }
  if (from._internal_laser_pulses_per_burst() != 0) {
    _this->_internal_set_laser_pulses_per_burst(from._internal_laser_pulses_per_burst());
  }
  if (from._internal_pulsedurationinfemtoseconds() != 0) {
    _this->_internal_set_pulsedurationinfemtoseconds(from._internal_pulsedurationinfemtoseconds());
  }
  if (from._internal_marking_mode() != 0) {
    _this->_internal_set_marking_mode(from._internal_marking_mode());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_jump_delay_in_us = from._internal_jump_delay_in_us();
  ::uint32_t raw_jump_delay_in_us;
  memcpy(&raw_jump_delay_in_us, &tmp_jump_delay_in_us, sizeof(tmp_jump_delay_in_us));
  if (raw_jump_delay_in_us != 0) {
    _this->_internal_set_jump_delay_in_us(from._internal_jump_delay_in_us());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_laser_off_delay_in_us = from._internal_laser_off_delay_in_us();
  ::uint32_t raw_laser_off_delay_in_us;
  memcpy(&raw_laser_off_delay_in_us, &tmp_laser_off_delay_in_us, sizeof(tmp_laser_off_delay_in_us));
  if (raw_laser_off_delay_in_us != 0) {
    _this->_internal_set_laser_off_delay_in_us(from._internal_laser_off_delay_in_us());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_laser_on_delay_in_us = from._internal_laser_on_delay_in_us();
  ::uint32_t raw_laser_on_delay_in_us;
  memcpy(&raw_laser_on_delay_in_us, &tmp_laser_on_delay_in_us, sizeof(tmp_laser_on_delay_in_us));
  if (raw_laser_on_delay_in_us != 0) {
    _this->_internal_set_laser_on_delay_in_us(from._internal_laser_on_delay_in_us());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_mark_delay_in_us = from._internal_mark_delay_in_us();
  ::uint32_t raw_mark_delay_in_us;
  memcpy(&raw_mark_delay_in_us, &tmp_mark_delay_in_us, sizeof(tmp_mark_delay_in_us));
  if (raw_mark_delay_in_us != 0) {
    _this->_internal_set_mark_delay_in_us(from._internal_mark_delay_in_us());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_polygon_delay_in_us = from._internal_polygon_delay_in_us();
  ::uint32_t raw_polygon_delay_in_us;
  memcpy(&raw_polygon_delay_in_us, &tmp_polygon_delay_in_us, sizeof(tmp_polygon_delay_in_us));
  if (raw_polygon_delay_in_us != 0) {
    _this->_internal_set_polygon_delay_in_us(from._internal_polygon_delay_in_us());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_time_lag_in_us = from._internal_time_lag_in_us();
  ::uint32_t raw_time_lag_in_us;
  memcpy(&raw_time_lag_in_us, &tmp_time_lag_in_us, sizeof(tmp_time_lag_in_us));
  if (raw_time_lag_in_us != 0) {
    _this->_internal_set_time_lag_in_us(from._internal_time_lag_in_us());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_laser_on_shift_in_us = from._internal_laser_on_shift_in_us();
  ::uint32_t raw_laser_on_shift_in_us;
  memcpy(&raw_laser_on_shift_in_us, &tmp_laser_on_shift_in_us, sizeof(tmp_laser_on_shift_in_us));
  if (raw_laser_on_shift_in_us != 0) {
    _this->_internal_set_laser_on_shift_in_us(from._internal_laser_on_shift_in_us());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_limit = from._internal_limit();
  ::uint32_t raw_limit;
  memcpy(&raw_limit, &tmp_limit, sizeof(tmp_limit));
  if (raw_limit != 0) {
    _this->_internal_set_limit(from._internal_limit());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_n_prev_in_us = from._internal_n_prev_in_us();
  ::uint32_t raw_n_prev_in_us;
  memcpy(&raw_n_prev_in_us, &tmp_n_prev_in_us, sizeof(tmp_n_prev_in_us));
  if (raw_n_prev_in_us != 0) {
    _this->_internal_set_n_prev_in_us(from._internal_n_prev_in_us());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_n_post_in_us = from._internal_n_post_in_us();
  ::uint32_t raw_n_post_in_us;
  memcpy(&raw_n_post_in_us, &tmp_n_post_in_us, sizeof(tmp_n_post_in_us));
  if (raw_n_post_in_us != 0) {
    _this->_internal_set_n_post_in_us(from._internal_n_post_in_us());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_wob_frequency_in_hz = from._internal_wob_frequency_in_hz();
  ::uint32_t raw_wob_frequency_in_hz;
  memcpy(&raw_wob_frequency_in_hz, &tmp_wob_frequency_in_hz, sizeof(tmp_wob_frequency_in_hz));
  if (raw_wob_frequency_in_hz != 0) {
    _this->_internal_set_wob_frequency_in_hz(from._internal_wob_frequency_in_hz());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_wob_amp_long_in_mm = from._internal_wob_amp_long_in_mm();
  ::uint32_t raw_wob_amp_long_in_mm;
  memcpy(&raw_wob_amp_long_in_mm, &tmp_wob_amp_long_in_mm, sizeof(tmp_wob_amp_long_in_mm));
  if (raw_wob_amp_long_in_mm != 0) {
    _this->_internal_set_wob_amp_long_in_mm(from._internal_wob_amp_long_in_mm());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_wob_amp_trans_in_mm = from._internal_wob_amp_trans_in_mm();
  ::uint32_t raw_wob_amp_trans_in_mm;
  memcpy(&raw_wob_amp_trans_in_mm, &tmp_wob_amp_trans_in_mm, sizeof(tmp_wob_amp_trans_in_mm));
  if (raw_wob_amp_trans_in_mm != 0) {
    _this->_internal_set_wob_amp_trans_in_mm(from._internal_wob_amp_trans_in_mm());
  }
  if (from._internal_wobble_mode() != 0) {
    _this->_internal_set_wobble_mode(from._internal_wobble_mode());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void MarkingParams::CopyFrom(const MarkingParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:open_vector_format.MarkingParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool MarkingParams::IsInitialized() const {
  return true;
}

void MarkingParams::InternalSwap(MarkingParams* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena,
                                       &other->_impl_.name_, rhs_arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.wobble_mode_)
      + sizeof(MarkingParams::_impl_.wobble_mode_)
      - PROTOBUF_FIELD_OFFSET(MarkingParams, _impl_.powergradient_)>(
          reinterpret_cast<char*>(&_impl_.powergradient_),
          reinterpret_cast<char*>(&other->_impl_.powergradient_));
}

::google::protobuf::Metadata MarkingParams::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_open_5fvector_5fformat_2eproto_getter, &descriptor_table_open_5fvector_5fformat_2eproto_once,
      file_level_metadata_open_5fvector_5fformat_2eproto[5]);
}
// ===================================================================

class PowerGradientParams::_Internal {
 public:
};

PowerGradientParams::PowerGradientParams(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:open_vector_format.PowerGradientParams)
}
PowerGradientParams::PowerGradientParams(const PowerGradientParams& from)
    : ::google::protobuf::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:open_vector_format.PowerGradientParams)
}
inline void PowerGradientParams::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.minpowerinw_){0},
      decltype(_impl_.gradientinwpers_){0},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
PowerGradientParams::~PowerGradientParams() {
  // @@protoc_insertion_point(destructor:open_vector_format.PowerGradientParams)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void PowerGradientParams::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}
void PowerGradientParams::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void PowerGradientParams::Clear() {
// @@protoc_insertion_point(message_clear_start:open_vector_format.PowerGradientParams)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.minpowerinw_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.gradientinwpers_) -
      reinterpret_cast<char*>(&_impl_.minpowerinw_)) + sizeof(_impl_.gradientinwpers_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* PowerGradientParams::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> PowerGradientParams::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_PowerGradientParams_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // float gradientInWPerS = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(PowerGradientParams, _impl_.gradientinwpers_)}},
    // float minPowerInW = 1;
    {::_pbi::TcParser::FastF32S1,
     {13, 63, 0, PROTOBUF_FIELD_OFFSET(PowerGradientParams, _impl_.minpowerinw_)}},
  }}, {{
    65535, 65535
  }}, {{
    // float minPowerInW = 1;
    {PROTOBUF_FIELD_OFFSET(PowerGradientParams, _impl_.minpowerinw_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float gradientInWPerS = 2;
    {PROTOBUF_FIELD_OFFSET(PowerGradientParams, _impl_.gradientinwpers_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* PowerGradientParams::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:open_vector_format.PowerGradientParams)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // float minPowerInW = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_minpowerinw = this->_internal_minpowerinw();
  ::uint32_t raw_minpowerinw;
  memcpy(&raw_minpowerinw, &tmp_minpowerinw, sizeof(tmp_minpowerinw));
  if (raw_minpowerinw != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_minpowerinw(), target);
  }

  // float gradientInWPerS = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_gradientinwpers = this->_internal_gradientinwpers();
  ::uint32_t raw_gradientinwpers;
  memcpy(&raw_gradientinwpers, &tmp_gradientinwpers, sizeof(tmp_gradientinwpers));
  if (raw_gradientinwpers != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_gradientinwpers(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:open_vector_format.PowerGradientParams)
  return target;
}

::size_t PowerGradientParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:open_vector_format.PowerGradientParams)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float minPowerInW = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_minpowerinw = this->_internal_minpowerinw();
  ::uint32_t raw_minpowerinw;
  memcpy(&raw_minpowerinw, &tmp_minpowerinw, sizeof(tmp_minpowerinw));
  if (raw_minpowerinw != 0) {
    total_size += 5;
  }

  // float gradientInWPerS = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_gradientinwpers = this->_internal_gradientinwpers();
  ::uint32_t raw_gradientinwpers;
  memcpy(&raw_gradientinwpers, &tmp_gradientinwpers, sizeof(tmp_gradientinwpers));
  if (raw_gradientinwpers != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData PowerGradientParams::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    PowerGradientParams::MergeImpl
};
const ::google::protobuf::Message::ClassData*PowerGradientParams::GetClassData() const { return &_class_data_; }


void PowerGradientParams::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<PowerGradientParams*>(&to_msg);
  auto& from = static_cast<const PowerGradientParams&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:open_vector_format.PowerGradientParams)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_minpowerinw = from._internal_minpowerinw();
  ::uint32_t raw_minpowerinw;
  memcpy(&raw_minpowerinw, &tmp_minpowerinw, sizeof(tmp_minpowerinw));
  if (raw_minpowerinw != 0) {
    _this->_internal_set_minpowerinw(from._internal_minpowerinw());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_gradientinwpers = from._internal_gradientinwpers();
  ::uint32_t raw_gradientinwpers;
  memcpy(&raw_gradientinwpers, &tmp_gradientinwpers, sizeof(tmp_gradientinwpers));
  if (raw_gradientinwpers != 0) {
    _this->_internal_set_gradientinwpers(from._internal_gradientinwpers());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void PowerGradientParams::CopyFrom(const PowerGradientParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:open_vector_format.PowerGradientParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool PowerGradientParams::IsInitialized() const {
  return true;
}

void PowerGradientParams::InternalSwap(PowerGradientParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PowerGradientParams, _impl_.gradientinwpers_)
      + sizeof(PowerGradientParams::_impl_.gradientinwpers_)
      - PROTOBUF_FIELD_OFFSET(PowerGradientParams, _impl_.minpowerinw_)>(
          reinterpret_cast<char*>(&_impl_.minpowerinw_),
          reinterpret_cast<char*>(&other->_impl_.minpowerinw_));
}

::google::protobuf::Metadata PowerGradientParams::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_open_5fvector_5fformat_2eproto_getter, &descriptor_table_open_5fvector_5fformat_2eproto_once,
      file_level_metadata_open_5fvector_5fformat_2eproto[6]);
}
// ===================================================================

class Part_GeometryInfo::_Internal {
 public:
};

Part_GeometryInfo::Part_GeometryInfo(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:open_vector_format.Part.GeometryInfo)
}
Part_GeometryInfo::Part_GeometryInfo(const Part_GeometryInfo& from)
    : ::google::protobuf::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:open_vector_format.Part.GeometryInfo)
}
inline void Part_GeometryInfo::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.volume_in_mm3_){0},
      decltype(_impl_.support_volume_in_mm3_){0},
      decltype(_impl_.build_height_in_mm_){0},
      decltype(_impl_.surface_area_in_mm2_){0},
      decltype(_impl_.projected_surface_in_mm2_){0},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
Part_GeometryInfo::~Part_GeometryInfo() {
  // @@protoc_insertion_point(destructor:open_vector_format.Part.GeometryInfo)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Part_GeometryInfo::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}
void Part_GeometryInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void Part_GeometryInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:open_vector_format.Part.GeometryInfo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.volume_in_mm3_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.projected_surface_in_mm2_) -
      reinterpret_cast<char*>(&_impl_.volume_in_mm3_)) + sizeof(_impl_.projected_surface_in_mm2_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Part_GeometryInfo::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 0, 0, 2> Part_GeometryInfo::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_Part_GeometryInfo_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // double volume_in_mm3 = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(Part_GeometryInfo, _impl_.volume_in_mm3_)}},
    // double support_volume_in_mm3 = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(Part_GeometryInfo, _impl_.support_volume_in_mm3_)}},
    // double build_height_in_mm = 3;
    {::_pbi::TcParser::FastF64S1,
     {25, 63, 0, PROTOBUF_FIELD_OFFSET(Part_GeometryInfo, _impl_.build_height_in_mm_)}},
    // double surface_area_in_mm2 = 4;
    {::_pbi::TcParser::FastF64S1,
     {33, 63, 0, PROTOBUF_FIELD_OFFSET(Part_GeometryInfo, _impl_.surface_area_in_mm2_)}},
    // double projected_surface_in_mm2 = 5;
    {::_pbi::TcParser::FastF64S1,
     {41, 63, 0, PROTOBUF_FIELD_OFFSET(Part_GeometryInfo, _impl_.projected_surface_in_mm2_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // double volume_in_mm3 = 1;
    {PROTOBUF_FIELD_OFFSET(Part_GeometryInfo, _impl_.volume_in_mm3_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double support_volume_in_mm3 = 2;
    {PROTOBUF_FIELD_OFFSET(Part_GeometryInfo, _impl_.support_volume_in_mm3_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double build_height_in_mm = 3;
    {PROTOBUF_FIELD_OFFSET(Part_GeometryInfo, _impl_.build_height_in_mm_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double surface_area_in_mm2 = 4;
    {PROTOBUF_FIELD_OFFSET(Part_GeometryInfo, _impl_.surface_area_in_mm2_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double projected_surface_in_mm2 = 5;
    {PROTOBUF_FIELD_OFFSET(Part_GeometryInfo, _impl_.projected_surface_in_mm2_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* Part_GeometryInfo::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:open_vector_format.Part.GeometryInfo)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double volume_in_mm3 = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_volume_in_mm3 = this->_internal_volume_in_mm3();
  ::uint64_t raw_volume_in_mm3;
  memcpy(&raw_volume_in_mm3, &tmp_volume_in_mm3, sizeof(tmp_volume_in_mm3));
  if (raw_volume_in_mm3 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_volume_in_mm3(), target);
  }

  // double support_volume_in_mm3 = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_support_volume_in_mm3 = this->_internal_support_volume_in_mm3();
  ::uint64_t raw_support_volume_in_mm3;
  memcpy(&raw_support_volume_in_mm3, &tmp_support_volume_in_mm3, sizeof(tmp_support_volume_in_mm3));
  if (raw_support_volume_in_mm3 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_support_volume_in_mm3(), target);
  }

  // double build_height_in_mm = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_build_height_in_mm = this->_internal_build_height_in_mm();
  ::uint64_t raw_build_height_in_mm;
  memcpy(&raw_build_height_in_mm, &tmp_build_height_in_mm, sizeof(tmp_build_height_in_mm));
  if (raw_build_height_in_mm != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_build_height_in_mm(), target);
  }

  // double surface_area_in_mm2 = 4;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_surface_area_in_mm2 = this->_internal_surface_area_in_mm2();
  ::uint64_t raw_surface_area_in_mm2;
  memcpy(&raw_surface_area_in_mm2, &tmp_surface_area_in_mm2, sizeof(tmp_surface_area_in_mm2));
  if (raw_surface_area_in_mm2 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        4, this->_internal_surface_area_in_mm2(), target);
  }

  // double projected_surface_in_mm2 = 5;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_projected_surface_in_mm2 = this->_internal_projected_surface_in_mm2();
  ::uint64_t raw_projected_surface_in_mm2;
  memcpy(&raw_projected_surface_in_mm2, &tmp_projected_surface_in_mm2, sizeof(tmp_projected_surface_in_mm2));
  if (raw_projected_surface_in_mm2 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        5, this->_internal_projected_surface_in_mm2(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:open_vector_format.Part.GeometryInfo)
  return target;
}

::size_t Part_GeometryInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:open_vector_format.Part.GeometryInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double volume_in_mm3 = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_volume_in_mm3 = this->_internal_volume_in_mm3();
  ::uint64_t raw_volume_in_mm3;
  memcpy(&raw_volume_in_mm3, &tmp_volume_in_mm3, sizeof(tmp_volume_in_mm3));
  if (raw_volume_in_mm3 != 0) {
    total_size += 9;
  }

  // double support_volume_in_mm3 = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_support_volume_in_mm3 = this->_internal_support_volume_in_mm3();
  ::uint64_t raw_support_volume_in_mm3;
  memcpy(&raw_support_volume_in_mm3, &tmp_support_volume_in_mm3, sizeof(tmp_support_volume_in_mm3));
  if (raw_support_volume_in_mm3 != 0) {
    total_size += 9;
  }

  // double build_height_in_mm = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_build_height_in_mm = this->_internal_build_height_in_mm();
  ::uint64_t raw_build_height_in_mm;
  memcpy(&raw_build_height_in_mm, &tmp_build_height_in_mm, sizeof(tmp_build_height_in_mm));
  if (raw_build_height_in_mm != 0) {
    total_size += 9;
  }

  // double surface_area_in_mm2 = 4;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_surface_area_in_mm2 = this->_internal_surface_area_in_mm2();
  ::uint64_t raw_surface_area_in_mm2;
  memcpy(&raw_surface_area_in_mm2, &tmp_surface_area_in_mm2, sizeof(tmp_surface_area_in_mm2));
  if (raw_surface_area_in_mm2 != 0) {
    total_size += 9;
  }

  // double projected_surface_in_mm2 = 5;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_projected_surface_in_mm2 = this->_internal_projected_surface_in_mm2();
  ::uint64_t raw_projected_surface_in_mm2;
  memcpy(&raw_projected_surface_in_mm2, &tmp_projected_surface_in_mm2, sizeof(tmp_projected_surface_in_mm2));
  if (raw_projected_surface_in_mm2 != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Part_GeometryInfo::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    Part_GeometryInfo::MergeImpl
};
const ::google::protobuf::Message::ClassData*Part_GeometryInfo::GetClassData() const { return &_class_data_; }


void Part_GeometryInfo::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Part_GeometryInfo*>(&to_msg);
  auto& from = static_cast<const Part_GeometryInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:open_vector_format.Part.GeometryInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_volume_in_mm3 = from._internal_volume_in_mm3();
  ::uint64_t raw_volume_in_mm3;
  memcpy(&raw_volume_in_mm3, &tmp_volume_in_mm3, sizeof(tmp_volume_in_mm3));
  if (raw_volume_in_mm3 != 0) {
    _this->_internal_set_volume_in_mm3(from._internal_volume_in_mm3());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_support_volume_in_mm3 = from._internal_support_volume_in_mm3();
  ::uint64_t raw_support_volume_in_mm3;
  memcpy(&raw_support_volume_in_mm3, &tmp_support_volume_in_mm3, sizeof(tmp_support_volume_in_mm3));
  if (raw_support_volume_in_mm3 != 0) {
    _this->_internal_set_support_volume_in_mm3(from._internal_support_volume_in_mm3());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_build_height_in_mm = from._internal_build_height_in_mm();
  ::uint64_t raw_build_height_in_mm;
  memcpy(&raw_build_height_in_mm, &tmp_build_height_in_mm, sizeof(tmp_build_height_in_mm));
  if (raw_build_height_in_mm != 0) {
    _this->_internal_set_build_height_in_mm(from._internal_build_height_in_mm());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_surface_area_in_mm2 = from._internal_surface_area_in_mm2();
  ::uint64_t raw_surface_area_in_mm2;
  memcpy(&raw_surface_area_in_mm2, &tmp_surface_area_in_mm2, sizeof(tmp_surface_area_in_mm2));
  if (raw_surface_area_in_mm2 != 0) {
    _this->_internal_set_surface_area_in_mm2(from._internal_surface_area_in_mm2());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_projected_surface_in_mm2 = from._internal_projected_surface_in_mm2();
  ::uint64_t raw_projected_surface_in_mm2;
  memcpy(&raw_projected_surface_in_mm2, &tmp_projected_surface_in_mm2, sizeof(tmp_projected_surface_in_mm2));
  if (raw_projected_surface_in_mm2 != 0) {
    _this->_internal_set_projected_surface_in_mm2(from._internal_projected_surface_in_mm2());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Part_GeometryInfo::CopyFrom(const Part_GeometryInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:open_vector_format.Part.GeometryInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Part_GeometryInfo::IsInitialized() const {
  return true;
}

void Part_GeometryInfo::InternalSwap(Part_GeometryInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Part_GeometryInfo, _impl_.projected_surface_in_mm2_)
      + sizeof(Part_GeometryInfo::_impl_.projected_surface_in_mm2_)
      - PROTOBUF_FIELD_OFFSET(Part_GeometryInfo, _impl_.volume_in_mm3_)>(
          reinterpret_cast<char*>(&_impl_.volume_in_mm3_),
          reinterpret_cast<char*>(&other->_impl_.volume_in_mm3_));
}

::google::protobuf::Metadata Part_GeometryInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_open_5fvector_5fformat_2eproto_getter, &descriptor_table_open_5fvector_5fformat_2eproto_once,
      file_level_metadata_open_5fvector_5fformat_2eproto[7]);
}
// ===================================================================

class Part_Material::_Internal {
 public:
};

Part_Material::Part_Material(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:open_vector_format.Part.Material)
}
Part_Material::Part_Material(const Part_Material& from) : ::google::protobuf::Message() {
  Part_Material* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){},
      decltype(_impl_.id_){},
      /*decltype(_impl_._cached_size_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
  }
  _this->_impl_.id_ = from._impl_.id_;

  // @@protoc_insertion_point(copy_constructor:open_vector_format.Part.Material)
}
inline void Part_Material::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){},
      decltype(_impl_.id_){::uint64_t{0u}},
      /*decltype(_impl_._cached_size_)*/ {},
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}
Part_Material::~Part_Material() {
  // @@protoc_insertion_point(destructor:open_vector_format.Part.Material)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Part_Material::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}
void Part_Material::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void Part_Material::Clear() {
// @@protoc_insertion_point(message_clear_start:open_vector_format.Part.Material)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.id_ = ::uint64_t{0u};
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Part_Material::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 45, 2> Part_Material::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_Part_Material_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // string name = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(Part_Material, _impl_.name_)}},
    // uint64 id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(Part_Material, _impl_.id_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(Part_Material, _impl_.id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // uint64 id = 1;
    {PROTOBUF_FIELD_OFFSET(Part_Material, _impl_.id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt64)},
    // string name = 2;
    {PROTOBUF_FIELD_OFFSET(Part_Material, _impl_.name_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\40\0\4\0\0\0\0\0"
    "open_vector_format.Part.Material"
    "name"
  }},
};

::uint8_t* Part_Material::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:open_vector_format.Part.Material)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // uint64 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_id(), target);
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    const std::string& _s = this->_internal_name();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "open_vector_format.Part.Material.name");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:open_vector_format.Part.Material)
  return target;
}

::size_t Part_Material::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:open_vector_format.Part.Material)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 2;
  if (!this->_internal_name().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_name());
  }

  // uint64 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Part_Material::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    Part_Material::MergeImpl
};
const ::google::protobuf::Message::ClassData*Part_Material::GetClassData() const { return &_class_data_; }


void Part_Material::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Part_Material*>(&to_msg);
  auto& from = static_cast<const Part_Material&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:open_vector_format.Part.Material)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Part_Material::CopyFrom(const Part_Material& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:open_vector_format.Part.Material)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Part_Material::IsInitialized() const {
  return true;
}

void Part_Material::InternalSwap(Part_Material* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena,
                                       &other->_impl_.name_, rhs_arena);
        swap(_impl_.id_, other->_impl_.id_);
}

::google::protobuf::Metadata Part_Material::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_open_5fvector_5fformat_2eproto_getter, &descriptor_table_open_5fvector_5fformat_2eproto_once,
      file_level_metadata_open_5fvector_5fformat_2eproto[8]);
}
// ===================================================================

class Part_ProcessStrategy_ProprietaryParam::_Internal {
 public:
};

Part_ProcessStrategy_ProprietaryParam::Part_ProcessStrategy_ProprietaryParam(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:open_vector_format.Part.ProcessStrategy.ProprietaryParam)
}
Part_ProcessStrategy_ProprietaryParam::Part_ProcessStrategy_ProprietaryParam(const Part_ProcessStrategy_ProprietaryParam& from) : ::google::protobuf::Message() {
  Part_ProcessStrategy_ProprietaryParam* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.param_name_){},
      decltype(_impl_.param_description_){},
      decltype(_impl_.param_value_){},
      /*decltype(_impl_._cached_size_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _impl_.param_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.param_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_param_name().empty()) {
    _this->_impl_.param_name_.Set(from._internal_param_name(), _this->GetArenaForAllocation());
  }
  _impl_.param_description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.param_description_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_param_description().empty()) {
    _this->_impl_.param_description_.Set(from._internal_param_description(), _this->GetArenaForAllocation());
  }
  _this->_impl_.param_value_ = from._impl_.param_value_;

  // @@protoc_insertion_point(copy_constructor:open_vector_format.Part.ProcessStrategy.ProprietaryParam)
}
inline void Part_ProcessStrategy_ProprietaryParam::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.param_name_){},
      decltype(_impl_.param_description_){},
      decltype(_impl_.param_value_){0},
      /*decltype(_impl_._cached_size_)*/ {},
  };
  _impl_.param_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.param_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.param_description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.param_description_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}
Part_ProcessStrategy_ProprietaryParam::~Part_ProcessStrategy_ProprietaryParam() {
  // @@protoc_insertion_point(destructor:open_vector_format.Part.ProcessStrategy.ProprietaryParam)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Part_ProcessStrategy_ProprietaryParam::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.param_name_.Destroy();
  _impl_.param_description_.Destroy();
}
void Part_ProcessStrategy_ProprietaryParam::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void Part_ProcessStrategy_ProprietaryParam::Clear() {
// @@protoc_insertion_point(message_clear_start:open_vector_format.Part.ProcessStrategy.ProprietaryParam)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.param_name_.ClearToEmpty();
  _impl_.param_description_.ClearToEmpty();
  _impl_.param_value_ = 0;
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Part_ProcessStrategy_ProprietaryParam::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 92, 2> Part_ProcessStrategy_ProprietaryParam::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_Part_ProcessStrategy_ProprietaryParam_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string param_name = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(Part_ProcessStrategy_ProprietaryParam, _impl_.param_name_)}},
    // double param_value = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(Part_ProcessStrategy_ProprietaryParam, _impl_.param_value_)}},
    // string param_description = 3;
    {::_pbi::TcParser::FastUS1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(Part_ProcessStrategy_ProprietaryParam, _impl_.param_description_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string param_name = 1;
    {PROTOBUF_FIELD_OFFSET(Part_ProcessStrategy_ProprietaryParam, _impl_.param_name_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // double param_value = 2;
    {PROTOBUF_FIELD_OFFSET(Part_ProcessStrategy_ProprietaryParam, _impl_.param_value_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // string param_description = 3;
    {PROTOBUF_FIELD_OFFSET(Part_ProcessStrategy_ProprietaryParam, _impl_.param_description_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\70\12\0\21\0\0\0\0"
    "open_vector_format.Part.ProcessStrategy.ProprietaryParam"
    "param_name"
    "param_description"
  }},
};

::uint8_t* Part_ProcessStrategy_ProprietaryParam::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:open_vector_format.Part.ProcessStrategy.ProprietaryParam)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string param_name = 1;
  if (!this->_internal_param_name().empty()) {
    const std::string& _s = this->_internal_param_name();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "open_vector_format.Part.ProcessStrategy.ProprietaryParam.param_name");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // double param_value = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_param_value = this->_internal_param_value();
  ::uint64_t raw_param_value;
  memcpy(&raw_param_value, &tmp_param_value, sizeof(tmp_param_value));
  if (raw_param_value != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_param_value(), target);
  }

  // string param_description = 3;
  if (!this->_internal_param_description().empty()) {
    const std::string& _s = this->_internal_param_description();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "open_vector_format.Part.ProcessStrategy.ProprietaryParam.param_description");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:open_vector_format.Part.ProcessStrategy.ProprietaryParam)
  return target;
}

::size_t Part_ProcessStrategy_ProprietaryParam::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:open_vector_format.Part.ProcessStrategy.ProprietaryParam)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string param_name = 1;
  if (!this->_internal_param_name().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_param_name());
  }

  // string param_description = 3;
  if (!this->_internal_param_description().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_param_description());
  }

  // double param_value = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_param_value = this->_internal_param_value();
  ::uint64_t raw_param_value;
  memcpy(&raw_param_value, &tmp_param_value, sizeof(tmp_param_value));
  if (raw_param_value != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Part_ProcessStrategy_ProprietaryParam::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    Part_ProcessStrategy_ProprietaryParam::MergeImpl
};
const ::google::protobuf::Message::ClassData*Part_ProcessStrategy_ProprietaryParam::GetClassData() const { return &_class_data_; }


void Part_ProcessStrategy_ProprietaryParam::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Part_ProcessStrategy_ProprietaryParam*>(&to_msg);
  auto& from = static_cast<const Part_ProcessStrategy_ProprietaryParam&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:open_vector_format.Part.ProcessStrategy.ProprietaryParam)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_param_name().empty()) {
    _this->_internal_set_param_name(from._internal_param_name());
  }
  if (!from._internal_param_description().empty()) {
    _this->_internal_set_param_description(from._internal_param_description());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_param_value = from._internal_param_value();
  ::uint64_t raw_param_value;
  memcpy(&raw_param_value, &tmp_param_value, sizeof(tmp_param_value));
  if (raw_param_value != 0) {
    _this->_internal_set_param_value(from._internal_param_value());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Part_ProcessStrategy_ProprietaryParam::CopyFrom(const Part_ProcessStrategy_ProprietaryParam& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:open_vector_format.Part.ProcessStrategy.ProprietaryParam)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Part_ProcessStrategy_ProprietaryParam::IsInitialized() const {
  return true;
}

void Part_ProcessStrategy_ProprietaryParam::InternalSwap(Part_ProcessStrategy_ProprietaryParam* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.param_name_, lhs_arena,
                                       &other->_impl_.param_name_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.param_description_, lhs_arena,
                                       &other->_impl_.param_description_, rhs_arena);
        swap(_impl_.param_value_, other->_impl_.param_value_);
}

::google::protobuf::Metadata Part_ProcessStrategy_ProprietaryParam::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_open_5fvector_5fformat_2eproto_getter, &descriptor_table_open_5fvector_5fformat_2eproto_once,
      file_level_metadata_open_5fvector_5fformat_2eproto[9]);
}
// ===================================================================

class Part_ProcessStrategy::_Internal {
 public:
};

Part_ProcessStrategy::Part_ProcessStrategy(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:open_vector_format.Part.ProcessStrategy)
}
Part_ProcessStrategy::Part_ProcessStrategy(const Part_ProcessStrategy& from) : ::google::protobuf::Message() {
  Part_ProcessStrategy* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.additional_parameters_){from._impl_.additional_parameters_},
      decltype(_impl_.name_){},
      decltype(_impl_.rot_angle_in_deg_){},
      decltype(_impl_.increment_angle_in_deg_){},
      decltype(_impl_.shift_in_mm_){},
      decltype(_impl_.extend_into_in_mm_){},
      decltype(_impl_.layer_thickness_in_mm_){},
      decltype(_impl_.hatch_distance_in_mm_){},
      decltype(_impl_.hatch_contour_distance_in_mm_){},
      decltype(_impl_.overhang_angle_in_deg_){},
      decltype(_impl_.contour_offset_in_mm_){},
      decltype(_impl_.number_of_contours_){},
      decltype(_impl_.contour_distance_in_mm_){},
      decltype(_impl_.hatching_pattern_){},
      decltype(_impl_.pattern_hatch_length_in_mm_){},
      /*decltype(_impl_._cached_size_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.rot_angle_in_deg_, &from._impl_.rot_angle_in_deg_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.pattern_hatch_length_in_mm_) -
    reinterpret_cast<char*>(&_impl_.rot_angle_in_deg_)) + sizeof(_impl_.pattern_hatch_length_in_mm_));

  // @@protoc_insertion_point(copy_constructor:open_vector_format.Part.ProcessStrategy)
}
inline void Part_ProcessStrategy::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.additional_parameters_){arena},
      decltype(_impl_.name_){},
      decltype(_impl_.rot_angle_in_deg_){0},
      decltype(_impl_.increment_angle_in_deg_){0},
      decltype(_impl_.shift_in_mm_){0},
      decltype(_impl_.extend_into_in_mm_){0},
      decltype(_impl_.layer_thickness_in_mm_){0},
      decltype(_impl_.hatch_distance_in_mm_){0},
      decltype(_impl_.hatch_contour_distance_in_mm_){0},
      decltype(_impl_.overhang_angle_in_deg_){0},
      decltype(_impl_.contour_offset_in_mm_){0},
      decltype(_impl_.number_of_contours_){0},
      decltype(_impl_.contour_distance_in_mm_){0},
      decltype(_impl_.hatching_pattern_){0},
      decltype(_impl_.pattern_hatch_length_in_mm_){0},
      /*decltype(_impl_._cached_size_)*/ {},
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}
Part_ProcessStrategy::~Part_ProcessStrategy() {
  // @@protoc_insertion_point(destructor:open_vector_format.Part.ProcessStrategy)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Part_ProcessStrategy::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.additional_parameters_.~RepeatedPtrField();
  _impl_.name_.Destroy();
}
void Part_ProcessStrategy::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void Part_ProcessStrategy::Clear() {
// @@protoc_insertion_point(message_clear_start:open_vector_format.Part.ProcessStrategy)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_additional_parameters()->Clear();
  _impl_.name_.ClearToEmpty();
  ::memset(&_impl_.rot_angle_in_deg_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.pattern_hatch_length_in_mm_) -
      reinterpret_cast<char*>(&_impl_.rot_angle_in_deg_)) + sizeof(_impl_.pattern_hatch_length_in_mm_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Part_ProcessStrategy::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 15, 1, 60, 7> Part_ProcessStrategy::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    100, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294959104,  // skipmap
    offsetof(decltype(_table_), field_entries),
    15,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_Part_ProcessStrategy_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // float rot_angle_in_deg = 1;
    {::_pbi::TcParser::FastF32S1,
     {13, 63, 0, PROTOBUF_FIELD_OFFSET(Part_ProcessStrategy, _impl_.rot_angle_in_deg_)}},
    // float increment_angle_in_deg = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(Part_ProcessStrategy, _impl_.increment_angle_in_deg_)}},
    // float shift_in_mm = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 63, 0, PROTOBUF_FIELD_OFFSET(Part_ProcessStrategy, _impl_.shift_in_mm_)}},
    // float extend_into_in_mm = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 63, 0, PROTOBUF_FIELD_OFFSET(Part_ProcessStrategy, _impl_.extend_into_in_mm_)}},
    // float layer_thickness_in_mm = 5;
    {::_pbi::TcParser::FastF32S1,
     {45, 63, 0, PROTOBUF_FIELD_OFFSET(Part_ProcessStrategy, _impl_.layer_thickness_in_mm_)}},
    // float hatch_distance_in_mm = 6;
    {::_pbi::TcParser::FastF32S1,
     {53, 63, 0, PROTOBUF_FIELD_OFFSET(Part_ProcessStrategy, _impl_.hatch_distance_in_mm_)}},
    // float hatch_contour_distance_in_mm = 7;
    {::_pbi::TcParser::FastF32S1,
     {61, 63, 0, PROTOBUF_FIELD_OFFSET(Part_ProcessStrategy, _impl_.hatch_contour_distance_in_mm_)}},
    // float overhang_angle_in_deg = 8;
    {::_pbi::TcParser::FastF32S1,
     {69, 63, 0, PROTOBUF_FIELD_OFFSET(Part_ProcessStrategy, _impl_.overhang_angle_in_deg_)}},
    // float contour_offset_in_mm = 9;
    {::_pbi::TcParser::FastF32S1,
     {77, 63, 0, PROTOBUF_FIELD_OFFSET(Part_ProcessStrategy, _impl_.contour_offset_in_mm_)}},
    // int32 number_of_contours = 10;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Part_ProcessStrategy, _impl_.number_of_contours_), 63>(),
     {80, 63, 0, PROTOBUF_FIELD_OFFSET(Part_ProcessStrategy, _impl_.number_of_contours_)}},
    // float contour_distance_in_mm = 11;
    {::_pbi::TcParser::FastF32S1,
     {93, 63, 0, PROTOBUF_FIELD_OFFSET(Part_ProcessStrategy, _impl_.contour_distance_in_mm_)}},
    // .open_vector_format.Part.ProcessStrategy.HatchingPattern hatching_pattern = 12;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Part_ProcessStrategy, _impl_.hatching_pattern_), 63>(),
     {96, 63, 0, PROTOBUF_FIELD_OFFSET(Part_ProcessStrategy, _impl_.hatching_pattern_)}},
    // float pattern_hatch_length_in_mm = 13;
    {::_pbi::TcParser::FastF32S1,
     {109, 63, 0, PROTOBUF_FIELD_OFFSET(Part_ProcessStrategy, _impl_.pattern_hatch_length_in_mm_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    90, 0, 1,
    64510, 13,
    65535, 65535
  }}, {{
    // float rot_angle_in_deg = 1;
    {PROTOBUF_FIELD_OFFSET(Part_ProcessStrategy, _impl_.rot_angle_in_deg_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float increment_angle_in_deg = 2;
    {PROTOBUF_FIELD_OFFSET(Part_ProcessStrategy, _impl_.increment_angle_in_deg_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float shift_in_mm = 3;
    {PROTOBUF_FIELD_OFFSET(Part_ProcessStrategy, _impl_.shift_in_mm_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float extend_into_in_mm = 4;
    {PROTOBUF_FIELD_OFFSET(Part_ProcessStrategy, _impl_.extend_into_in_mm_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float layer_thickness_in_mm = 5;
    {PROTOBUF_FIELD_OFFSET(Part_ProcessStrategy, _impl_.layer_thickness_in_mm_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float hatch_distance_in_mm = 6;
    {PROTOBUF_FIELD_OFFSET(Part_ProcessStrategy, _impl_.hatch_distance_in_mm_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float hatch_contour_distance_in_mm = 7;
    {PROTOBUF_FIELD_OFFSET(Part_ProcessStrategy, _impl_.hatch_contour_distance_in_mm_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float overhang_angle_in_deg = 8;
    {PROTOBUF_FIELD_OFFSET(Part_ProcessStrategy, _impl_.overhang_angle_in_deg_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float contour_offset_in_mm = 9;
    {PROTOBUF_FIELD_OFFSET(Part_ProcessStrategy, _impl_.contour_offset_in_mm_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // int32 number_of_contours = 10;
    {PROTOBUF_FIELD_OFFSET(Part_ProcessStrategy, _impl_.number_of_contours_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // float contour_distance_in_mm = 11;
    {PROTOBUF_FIELD_OFFSET(Part_ProcessStrategy, _impl_.contour_distance_in_mm_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // .open_vector_format.Part.ProcessStrategy.HatchingPattern hatching_pattern = 12;
    {PROTOBUF_FIELD_OFFSET(Part_ProcessStrategy, _impl_.hatching_pattern_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // float pattern_hatch_length_in_mm = 13;
    {PROTOBUF_FIELD_OFFSET(Part_ProcessStrategy, _impl_.pattern_hatch_length_in_mm_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // string name = 90;
    {PROTOBUF_FIELD_OFFSET(Part_ProcessStrategy, _impl_.name_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // repeated .open_vector_format.Part.ProcessStrategy.ProprietaryParam additional_parameters = 100;
    {PROTOBUF_FIELD_OFFSET(Part_ProcessStrategy, _impl_.additional_parameters_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::open_vector_format::Part_ProcessStrategy_ProprietaryParam>()},
  }}, {{
    "\47\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0"
    "open_vector_format.Part.ProcessStrategy"
    "name"
  }},
};

::uint8_t* Part_ProcessStrategy::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:open_vector_format.Part.ProcessStrategy)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // float rot_angle_in_deg = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_rot_angle_in_deg = this->_internal_rot_angle_in_deg();
  ::uint32_t raw_rot_angle_in_deg;
  memcpy(&raw_rot_angle_in_deg, &tmp_rot_angle_in_deg, sizeof(tmp_rot_angle_in_deg));
  if (raw_rot_angle_in_deg != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_rot_angle_in_deg(), target);
  }

  // float increment_angle_in_deg = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_increment_angle_in_deg = this->_internal_increment_angle_in_deg();
  ::uint32_t raw_increment_angle_in_deg;
  memcpy(&raw_increment_angle_in_deg, &tmp_increment_angle_in_deg, sizeof(tmp_increment_angle_in_deg));
  if (raw_increment_angle_in_deg != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_increment_angle_in_deg(), target);
  }

  // float shift_in_mm = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_shift_in_mm = this->_internal_shift_in_mm();
  ::uint32_t raw_shift_in_mm;
  memcpy(&raw_shift_in_mm, &tmp_shift_in_mm, sizeof(tmp_shift_in_mm));
  if (raw_shift_in_mm != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_shift_in_mm(), target);
  }

  // float extend_into_in_mm = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_extend_into_in_mm = this->_internal_extend_into_in_mm();
  ::uint32_t raw_extend_into_in_mm;
  memcpy(&raw_extend_into_in_mm, &tmp_extend_into_in_mm, sizeof(tmp_extend_into_in_mm));
  if (raw_extend_into_in_mm != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_extend_into_in_mm(), target);
  }

  // float layer_thickness_in_mm = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_layer_thickness_in_mm = this->_internal_layer_thickness_in_mm();
  ::uint32_t raw_layer_thickness_in_mm;
  memcpy(&raw_layer_thickness_in_mm, &tmp_layer_thickness_in_mm, sizeof(tmp_layer_thickness_in_mm));
  if (raw_layer_thickness_in_mm != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_layer_thickness_in_mm(), target);
  }

  // float hatch_distance_in_mm = 6;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_hatch_distance_in_mm = this->_internal_hatch_distance_in_mm();
  ::uint32_t raw_hatch_distance_in_mm;
  memcpy(&raw_hatch_distance_in_mm, &tmp_hatch_distance_in_mm, sizeof(tmp_hatch_distance_in_mm));
  if (raw_hatch_distance_in_mm != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        6, this->_internal_hatch_distance_in_mm(), target);
  }

  // float hatch_contour_distance_in_mm = 7;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_hatch_contour_distance_in_mm = this->_internal_hatch_contour_distance_in_mm();
  ::uint32_t raw_hatch_contour_distance_in_mm;
  memcpy(&raw_hatch_contour_distance_in_mm, &tmp_hatch_contour_distance_in_mm, sizeof(tmp_hatch_contour_distance_in_mm));
  if (raw_hatch_contour_distance_in_mm != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        7, this->_internal_hatch_contour_distance_in_mm(), target);
  }

  // float overhang_angle_in_deg = 8;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_overhang_angle_in_deg = this->_internal_overhang_angle_in_deg();
  ::uint32_t raw_overhang_angle_in_deg;
  memcpy(&raw_overhang_angle_in_deg, &tmp_overhang_angle_in_deg, sizeof(tmp_overhang_angle_in_deg));
  if (raw_overhang_angle_in_deg != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        8, this->_internal_overhang_angle_in_deg(), target);
  }

  // float contour_offset_in_mm = 9;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_contour_offset_in_mm = this->_internal_contour_offset_in_mm();
  ::uint32_t raw_contour_offset_in_mm;
  memcpy(&raw_contour_offset_in_mm, &tmp_contour_offset_in_mm, sizeof(tmp_contour_offset_in_mm));
  if (raw_contour_offset_in_mm != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        9, this->_internal_contour_offset_in_mm(), target);
  }

  // int32 number_of_contours = 10;
  if (this->_internal_number_of_contours() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<10>(
            stream, this->_internal_number_of_contours(), target);
  }

  // float contour_distance_in_mm = 11;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_contour_distance_in_mm = this->_internal_contour_distance_in_mm();
  ::uint32_t raw_contour_distance_in_mm;
  memcpy(&raw_contour_distance_in_mm, &tmp_contour_distance_in_mm, sizeof(tmp_contour_distance_in_mm));
  if (raw_contour_distance_in_mm != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        11, this->_internal_contour_distance_in_mm(), target);
  }

  // .open_vector_format.Part.ProcessStrategy.HatchingPattern hatching_pattern = 12;
  if (this->_internal_hatching_pattern() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        12, this->_internal_hatching_pattern(), target);
  }

  // float pattern_hatch_length_in_mm = 13;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_pattern_hatch_length_in_mm = this->_internal_pattern_hatch_length_in_mm();
  ::uint32_t raw_pattern_hatch_length_in_mm;
  memcpy(&raw_pattern_hatch_length_in_mm, &tmp_pattern_hatch_length_in_mm, sizeof(tmp_pattern_hatch_length_in_mm));
  if (raw_pattern_hatch_length_in_mm != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        13, this->_internal_pattern_hatch_length_in_mm(), target);
  }

  // string name = 90;
  if (!this->_internal_name().empty()) {
    const std::string& _s = this->_internal_name();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "open_vector_format.Part.ProcessStrategy.name");
    target = stream->WriteStringMaybeAliased(90, _s, target);
  }

  // repeated .open_vector_format.Part.ProcessStrategy.ProprietaryParam additional_parameters = 100;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_additional_parameters_size()); i < n; i++) {
    const auto& repfield = this->_internal_additional_parameters().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(100, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:open_vector_format.Part.ProcessStrategy)
  return target;
}

::size_t Part_ProcessStrategy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:open_vector_format.Part.ProcessStrategy)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .open_vector_format.Part.ProcessStrategy.ProprietaryParam additional_parameters = 100;
  total_size += 2UL * this->_internal_additional_parameters_size();
  for (const auto& msg : this->_internal_additional_parameters()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // string name = 90;
  if (!this->_internal_name().empty()) {
    total_size += 2 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_name());
  }

  // float rot_angle_in_deg = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_rot_angle_in_deg = this->_internal_rot_angle_in_deg();
  ::uint32_t raw_rot_angle_in_deg;
  memcpy(&raw_rot_angle_in_deg, &tmp_rot_angle_in_deg, sizeof(tmp_rot_angle_in_deg));
  if (raw_rot_angle_in_deg != 0) {
    total_size += 5;
  }

  // float increment_angle_in_deg = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_increment_angle_in_deg = this->_internal_increment_angle_in_deg();
  ::uint32_t raw_increment_angle_in_deg;
  memcpy(&raw_increment_angle_in_deg, &tmp_increment_angle_in_deg, sizeof(tmp_increment_angle_in_deg));
  if (raw_increment_angle_in_deg != 0) {
    total_size += 5;
  }

  // float shift_in_mm = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_shift_in_mm = this->_internal_shift_in_mm();
  ::uint32_t raw_shift_in_mm;
  memcpy(&raw_shift_in_mm, &tmp_shift_in_mm, sizeof(tmp_shift_in_mm));
  if (raw_shift_in_mm != 0) {
    total_size += 5;
  }

  // float extend_into_in_mm = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_extend_into_in_mm = this->_internal_extend_into_in_mm();
  ::uint32_t raw_extend_into_in_mm;
  memcpy(&raw_extend_into_in_mm, &tmp_extend_into_in_mm, sizeof(tmp_extend_into_in_mm));
  if (raw_extend_into_in_mm != 0) {
    total_size += 5;
  }

  // float layer_thickness_in_mm = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_layer_thickness_in_mm = this->_internal_layer_thickness_in_mm();
  ::uint32_t raw_layer_thickness_in_mm;
  memcpy(&raw_layer_thickness_in_mm, &tmp_layer_thickness_in_mm, sizeof(tmp_layer_thickness_in_mm));
  if (raw_layer_thickness_in_mm != 0) {
    total_size += 5;
  }

  // float hatch_distance_in_mm = 6;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_hatch_distance_in_mm = this->_internal_hatch_distance_in_mm();
  ::uint32_t raw_hatch_distance_in_mm;
  memcpy(&raw_hatch_distance_in_mm, &tmp_hatch_distance_in_mm, sizeof(tmp_hatch_distance_in_mm));
  if (raw_hatch_distance_in_mm != 0) {
    total_size += 5;
  }

  // float hatch_contour_distance_in_mm = 7;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_hatch_contour_distance_in_mm = this->_internal_hatch_contour_distance_in_mm();
  ::uint32_t raw_hatch_contour_distance_in_mm;
  memcpy(&raw_hatch_contour_distance_in_mm, &tmp_hatch_contour_distance_in_mm, sizeof(tmp_hatch_contour_distance_in_mm));
  if (raw_hatch_contour_distance_in_mm != 0) {
    total_size += 5;
  }

  // float overhang_angle_in_deg = 8;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_overhang_angle_in_deg = this->_internal_overhang_angle_in_deg();
  ::uint32_t raw_overhang_angle_in_deg;
  memcpy(&raw_overhang_angle_in_deg, &tmp_overhang_angle_in_deg, sizeof(tmp_overhang_angle_in_deg));
  if (raw_overhang_angle_in_deg != 0) {
    total_size += 5;
  }

  // float contour_offset_in_mm = 9;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_contour_offset_in_mm = this->_internal_contour_offset_in_mm();
  ::uint32_t raw_contour_offset_in_mm;
  memcpy(&raw_contour_offset_in_mm, &tmp_contour_offset_in_mm, sizeof(tmp_contour_offset_in_mm));
  if (raw_contour_offset_in_mm != 0) {
    total_size += 5;
  }

  // int32 number_of_contours = 10;
  if (this->_internal_number_of_contours() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_number_of_contours());
  }

  // float contour_distance_in_mm = 11;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_contour_distance_in_mm = this->_internal_contour_distance_in_mm();
  ::uint32_t raw_contour_distance_in_mm;
  memcpy(&raw_contour_distance_in_mm, &tmp_contour_distance_in_mm, sizeof(tmp_contour_distance_in_mm));
  if (raw_contour_distance_in_mm != 0) {
    total_size += 5;
  }

  // .open_vector_format.Part.ProcessStrategy.HatchingPattern hatching_pattern = 12;
  if (this->_internal_hatching_pattern() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_hatching_pattern());
  }

  // float pattern_hatch_length_in_mm = 13;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_pattern_hatch_length_in_mm = this->_internal_pattern_hatch_length_in_mm();
  ::uint32_t raw_pattern_hatch_length_in_mm;
  memcpy(&raw_pattern_hatch_length_in_mm, &tmp_pattern_hatch_length_in_mm, sizeof(tmp_pattern_hatch_length_in_mm));
  if (raw_pattern_hatch_length_in_mm != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Part_ProcessStrategy::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    Part_ProcessStrategy::MergeImpl
};
const ::google::protobuf::Message::ClassData*Part_ProcessStrategy::GetClassData() const { return &_class_data_; }


void Part_ProcessStrategy::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Part_ProcessStrategy*>(&to_msg);
  auto& from = static_cast<const Part_ProcessStrategy&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:open_vector_format.Part.ProcessStrategy)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_additional_parameters()->MergeFrom(from._internal_additional_parameters());
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_rot_angle_in_deg = from._internal_rot_angle_in_deg();
  ::uint32_t raw_rot_angle_in_deg;
  memcpy(&raw_rot_angle_in_deg, &tmp_rot_angle_in_deg, sizeof(tmp_rot_angle_in_deg));
  if (raw_rot_angle_in_deg != 0) {
    _this->_internal_set_rot_angle_in_deg(from._internal_rot_angle_in_deg());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_increment_angle_in_deg = from._internal_increment_angle_in_deg();
  ::uint32_t raw_increment_angle_in_deg;
  memcpy(&raw_increment_angle_in_deg, &tmp_increment_angle_in_deg, sizeof(tmp_increment_angle_in_deg));
  if (raw_increment_angle_in_deg != 0) {
    _this->_internal_set_increment_angle_in_deg(from._internal_increment_angle_in_deg());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_shift_in_mm = from._internal_shift_in_mm();
  ::uint32_t raw_shift_in_mm;
  memcpy(&raw_shift_in_mm, &tmp_shift_in_mm, sizeof(tmp_shift_in_mm));
  if (raw_shift_in_mm != 0) {
    _this->_internal_set_shift_in_mm(from._internal_shift_in_mm());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_extend_into_in_mm = from._internal_extend_into_in_mm();
  ::uint32_t raw_extend_into_in_mm;
  memcpy(&raw_extend_into_in_mm, &tmp_extend_into_in_mm, sizeof(tmp_extend_into_in_mm));
  if (raw_extend_into_in_mm != 0) {
    _this->_internal_set_extend_into_in_mm(from._internal_extend_into_in_mm());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_layer_thickness_in_mm = from._internal_layer_thickness_in_mm();
  ::uint32_t raw_layer_thickness_in_mm;
  memcpy(&raw_layer_thickness_in_mm, &tmp_layer_thickness_in_mm, sizeof(tmp_layer_thickness_in_mm));
  if (raw_layer_thickness_in_mm != 0) {
    _this->_internal_set_layer_thickness_in_mm(from._internal_layer_thickness_in_mm());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_hatch_distance_in_mm = from._internal_hatch_distance_in_mm();
  ::uint32_t raw_hatch_distance_in_mm;
  memcpy(&raw_hatch_distance_in_mm, &tmp_hatch_distance_in_mm, sizeof(tmp_hatch_distance_in_mm));
  if (raw_hatch_distance_in_mm != 0) {
    _this->_internal_set_hatch_distance_in_mm(from._internal_hatch_distance_in_mm());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_hatch_contour_distance_in_mm = from._internal_hatch_contour_distance_in_mm();
  ::uint32_t raw_hatch_contour_distance_in_mm;
  memcpy(&raw_hatch_contour_distance_in_mm, &tmp_hatch_contour_distance_in_mm, sizeof(tmp_hatch_contour_distance_in_mm));
  if (raw_hatch_contour_distance_in_mm != 0) {
    _this->_internal_set_hatch_contour_distance_in_mm(from._internal_hatch_contour_distance_in_mm());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_overhang_angle_in_deg = from._internal_overhang_angle_in_deg();
  ::uint32_t raw_overhang_angle_in_deg;
  memcpy(&raw_overhang_angle_in_deg, &tmp_overhang_angle_in_deg, sizeof(tmp_overhang_angle_in_deg));
  if (raw_overhang_angle_in_deg != 0) {
    _this->_internal_set_overhang_angle_in_deg(from._internal_overhang_angle_in_deg());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_contour_offset_in_mm = from._internal_contour_offset_in_mm();
  ::uint32_t raw_contour_offset_in_mm;
  memcpy(&raw_contour_offset_in_mm, &tmp_contour_offset_in_mm, sizeof(tmp_contour_offset_in_mm));
  if (raw_contour_offset_in_mm != 0) {
    _this->_internal_set_contour_offset_in_mm(from._internal_contour_offset_in_mm());
  }
  if (from._internal_number_of_contours() != 0) {
    _this->_internal_set_number_of_contours(from._internal_number_of_contours());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_contour_distance_in_mm = from._internal_contour_distance_in_mm();
  ::uint32_t raw_contour_distance_in_mm;
  memcpy(&raw_contour_distance_in_mm, &tmp_contour_distance_in_mm, sizeof(tmp_contour_distance_in_mm));
  if (raw_contour_distance_in_mm != 0) {
    _this->_internal_set_contour_distance_in_mm(from._internal_contour_distance_in_mm());
  }
  if (from._internal_hatching_pattern() != 0) {
    _this->_internal_set_hatching_pattern(from._internal_hatching_pattern());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_pattern_hatch_length_in_mm = from._internal_pattern_hatch_length_in_mm();
  ::uint32_t raw_pattern_hatch_length_in_mm;
  memcpy(&raw_pattern_hatch_length_in_mm, &tmp_pattern_hatch_length_in_mm, sizeof(tmp_pattern_hatch_length_in_mm));
  if (raw_pattern_hatch_length_in_mm != 0) {
    _this->_internal_set_pattern_hatch_length_in_mm(from._internal_pattern_hatch_length_in_mm());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Part_ProcessStrategy::CopyFrom(const Part_ProcessStrategy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:open_vector_format.Part.ProcessStrategy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Part_ProcessStrategy::IsInitialized() const {
  return true;
}

void Part_ProcessStrategy::InternalSwap(Part_ProcessStrategy* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.additional_parameters_.InternalSwap(&other->_impl_.additional_parameters_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena,
                                       &other->_impl_.name_, rhs_arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Part_ProcessStrategy, _impl_.pattern_hatch_length_in_mm_)
      + sizeof(Part_ProcessStrategy::_impl_.pattern_hatch_length_in_mm_)
      - PROTOBUF_FIELD_OFFSET(Part_ProcessStrategy, _impl_.rot_angle_in_deg_)>(
          reinterpret_cast<char*>(&_impl_.rot_angle_in_deg_),
          reinterpret_cast<char*>(&other->_impl_.rot_angle_in_deg_));
}

::google::protobuf::Metadata Part_ProcessStrategy::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_open_5fvector_5fformat_2eproto_getter, &descriptor_table_open_5fvector_5fformat_2eproto_once,
      file_level_metadata_open_5fvector_5fformat_2eproto[10]);
}
// ===================================================================

class Part::_Internal {
 public:
  using HasBits = decltype(std::declval<Part>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Part, _impl_._has_bits_);
  static const ::open_vector_format::Part_GeometryInfo& geometry_info(const Part* msg);
  static void set_has_geometry_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::open_vector_format::Part_Material& material(const Part* msg);
  static void set_has_material(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::open_vector_format::Part_ProcessStrategy& process_strategy(const Part* msg);
  static void set_has_process_strategy(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::open_vector_format::Part_ProcessStrategy& up_skin_process_strategy(const Part* msg);
  static void set_has_up_skin_process_strategy(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::open_vector_format::Part_ProcessStrategy& down_skin_process_strategy(const Part* msg);
  static void set_has_down_skin_process_strategy(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::open_vector_format::Part_GeometryInfo& Part::_Internal::geometry_info(const Part* msg) {
  return *msg->_impl_.geometry_info_;
}
const ::open_vector_format::Part_Material& Part::_Internal::material(const Part* msg) {
  return *msg->_impl_.material_;
}
const ::open_vector_format::Part_ProcessStrategy& Part::_Internal::process_strategy(const Part* msg) {
  return *msg->_impl_.process_strategy_;
}
const ::open_vector_format::Part_ProcessStrategy& Part::_Internal::up_skin_process_strategy(const Part* msg) {
  return *msg->_impl_.up_skin_process_strategy_;
}
const ::open_vector_format::Part_ProcessStrategy& Part::_Internal::down_skin_process_strategy(const Part* msg) {
  return *msg->_impl_.down_skin_process_strategy_;
}
Part::Part(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:open_vector_format.Part)
}
Part::Part(const Part& from) : ::google::protobuf::Message() {
  Part* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.exposure_order_){from._impl_.exposure_order_},
      decltype(_impl_.name_){},
      decltype(_impl_.parent_part_name_){},
      decltype(_impl_.geometry_info_){nullptr},
      decltype(_impl_.material_){nullptr},
      decltype(_impl_.process_strategy_){nullptr},
      decltype(_impl_.up_skin_process_strategy_){nullptr},
      decltype(_impl_.down_skin_process_strategy_){nullptr},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
  }
  _impl_.parent_part_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.parent_part_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_parent_part_name().empty()) {
    _this->_impl_.parent_part_name_.Set(from._internal_parent_part_name(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.geometry_info_ = new ::open_vector_format::Part_GeometryInfo(*from._impl_.geometry_info_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.material_ = new ::open_vector_format::Part_Material(*from._impl_.material_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.process_strategy_ = new ::open_vector_format::Part_ProcessStrategy(*from._impl_.process_strategy_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.up_skin_process_strategy_ = new ::open_vector_format::Part_ProcessStrategy(*from._impl_.up_skin_process_strategy_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000010u) != 0) {
    _this->_impl_.down_skin_process_strategy_ = new ::open_vector_format::Part_ProcessStrategy(*from._impl_.down_skin_process_strategy_);
  }

  // @@protoc_insertion_point(copy_constructor:open_vector_format.Part)
}
inline void Part::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.exposure_order_){arena},
      decltype(_impl_.name_){},
      decltype(_impl_.parent_part_name_){},
      decltype(_impl_.geometry_info_){nullptr},
      decltype(_impl_.material_){nullptr},
      decltype(_impl_.process_strategy_){nullptr},
      decltype(_impl_.up_skin_process_strategy_){nullptr},
      decltype(_impl_.down_skin_process_strategy_){nullptr},
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.parent_part_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.parent_part_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}
Part::~Part() {
  // @@protoc_insertion_point(destructor:open_vector_format.Part)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Part::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.exposure_order_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  _impl_.parent_part_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.geometry_info_;
  if (this != internal_default_instance()) delete _impl_.material_;
  if (this != internal_default_instance()) delete _impl_.process_strategy_;
  if (this != internal_default_instance()) delete _impl_.up_skin_process_strategy_;
  if (this != internal_default_instance()) delete _impl_.down_skin_process_strategy_;
}
void Part::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void Part::Clear() {
// @@protoc_insertion_point(message_clear_start:open_vector_format.Part)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_exposure_order()->Clear();
  _impl_.name_.ClearToEmpty();
  _impl_.parent_part_name_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.geometry_info_ != nullptr);
      _impl_.geometry_info_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.material_ != nullptr);
      _impl_.material_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.process_strategy_ != nullptr);
      _impl_.process_strategy_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.up_skin_process_strategy_ != nullptr);
      _impl_.up_skin_process_strategy_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(_impl_.down_skin_process_strategy_ != nullptr);
      _impl_.down_skin_process_strategy_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Part::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 8, 6, 60, 2> Part::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Part, _impl_._has_bits_),
    0, // no _extensions_
    8, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    6,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_Part_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // string parent_part_name = 8;
    {::_pbi::TcParser::FastUS1,
     {66, 63, 0, PROTOBUF_FIELD_OFFSET(Part, _impl_.parent_part_name_)}},
    // string name = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(Part, _impl_.name_)}},
    // .open_vector_format.Part.GeometryInfo geometry_info = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(Part, _impl_.geometry_info_)}},
    // .open_vector_format.Part.Material material = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 1, 1, PROTOBUF_FIELD_OFFSET(Part, _impl_.material_)}},
    // .open_vector_format.Part.ProcessStrategy process_strategy = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 2, 2, PROTOBUF_FIELD_OFFSET(Part, _impl_.process_strategy_)}},
    // .open_vector_format.Part.ProcessStrategy up_skin_process_strategy = 5;
    {::_pbi::TcParser::FastMtS1,
     {42, 3, 3, PROTOBUF_FIELD_OFFSET(Part, _impl_.up_skin_process_strategy_)}},
    // .open_vector_format.Part.ProcessStrategy down_skin_process_strategy = 6;
    {::_pbi::TcParser::FastMtS1,
     {50, 4, 4, PROTOBUF_FIELD_OFFSET(Part, _impl_.down_skin_process_strategy_)}},
    // repeated .open_vector_format.VectorBlock.LPBFMetadata exposure_order = 7;
    {::_pbi::TcParser::FastMtR1,
     {58, 63, 5, PROTOBUF_FIELD_OFFSET(Part, _impl_.exposure_order_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string name = 1;
    {PROTOBUF_FIELD_OFFSET(Part, _impl_.name_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .open_vector_format.Part.GeometryInfo geometry_info = 2;
    {PROTOBUF_FIELD_OFFSET(Part, _impl_.geometry_info_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .open_vector_format.Part.Material material = 3;
    {PROTOBUF_FIELD_OFFSET(Part, _impl_.material_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .open_vector_format.Part.ProcessStrategy process_strategy = 4;
    {PROTOBUF_FIELD_OFFSET(Part, _impl_.process_strategy_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .open_vector_format.Part.ProcessStrategy up_skin_process_strategy = 5;
    {PROTOBUF_FIELD_OFFSET(Part, _impl_.up_skin_process_strategy_), _Internal::kHasBitsOffset + 3, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .open_vector_format.Part.ProcessStrategy down_skin_process_strategy = 6;
    {PROTOBUF_FIELD_OFFSET(Part, _impl_.down_skin_process_strategy_), _Internal::kHasBitsOffset + 4, 4,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .open_vector_format.VectorBlock.LPBFMetadata exposure_order = 7;
    {PROTOBUF_FIELD_OFFSET(Part, _impl_.exposure_order_), -1, 5,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // string parent_part_name = 8;
    {PROTOBUF_FIELD_OFFSET(Part, _impl_.parent_part_name_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }}, {{
    {::_pbi::TcParser::GetTable<::open_vector_format::Part_GeometryInfo>()},
    {::_pbi::TcParser::GetTable<::open_vector_format::Part_Material>()},
    {::_pbi::TcParser::GetTable<::open_vector_format::Part_ProcessStrategy>()},
    {::_pbi::TcParser::GetTable<::open_vector_format::Part_ProcessStrategy>()},
    {::_pbi::TcParser::GetTable<::open_vector_format::Part_ProcessStrategy>()},
    {::_pbi::TcParser::GetTable<::open_vector_format::VectorBlock_LPBFMetadata>()},
  }}, {{
    "\27\4\0\0\0\0\0\0\20\0\0\0\0\0\0\0"
    "open_vector_format.Part"
    "name"
    "parent_part_name"
  }},
};

::uint8_t* Part::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:open_vector_format.Part)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    const std::string& _s = this->_internal_name();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "open_vector_format.Part.name");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .open_vector_format.Part.GeometryInfo geometry_info = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::geometry_info(this),
        _Internal::geometry_info(this).GetCachedSize(), target, stream);
  }

  // .open_vector_format.Part.Material material = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::material(this),
        _Internal::material(this).GetCachedSize(), target, stream);
  }

  // .open_vector_format.Part.ProcessStrategy process_strategy = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::process_strategy(this),
        _Internal::process_strategy(this).GetCachedSize(), target, stream);
  }

  // .open_vector_format.Part.ProcessStrategy up_skin_process_strategy = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::up_skin_process_strategy(this),
        _Internal::up_skin_process_strategy(this).GetCachedSize(), target, stream);
  }

  // .open_vector_format.Part.ProcessStrategy down_skin_process_strategy = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::down_skin_process_strategy(this),
        _Internal::down_skin_process_strategy(this).GetCachedSize(), target, stream);
  }

  // repeated .open_vector_format.VectorBlock.LPBFMetadata exposure_order = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_exposure_order_size()); i < n; i++) {
    const auto& repfield = this->_internal_exposure_order().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string parent_part_name = 8;
  if (!this->_internal_parent_part_name().empty()) {
    const std::string& _s = this->_internal_parent_part_name();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "open_vector_format.Part.parent_part_name");
    target = stream->WriteStringMaybeAliased(8, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:open_vector_format.Part)
  return target;
}

::size_t Part::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:open_vector_format.Part)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .open_vector_format.VectorBlock.LPBFMetadata exposure_order = 7;
  total_size += 1UL * this->_internal_exposure_order_size();
  for (const auto& msg : this->_internal_exposure_order()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_name());
  }

  // string parent_part_name = 8;
  if (!this->_internal_parent_part_name().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_parent_part_name());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // .open_vector_format.Part.GeometryInfo geometry_info = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.geometry_info_);
    }

    // .open_vector_format.Part.Material material = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.material_);
    }

    // .open_vector_format.Part.ProcessStrategy process_strategy = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.process_strategy_);
    }

    // .open_vector_format.Part.ProcessStrategy up_skin_process_strategy = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.up_skin_process_strategy_);
    }

    // .open_vector_format.Part.ProcessStrategy down_skin_process_strategy = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.down_skin_process_strategy_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Part::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    Part::MergeImpl
};
const ::google::protobuf::Message::ClassData*Part::GetClassData() const { return &_class_data_; }


void Part::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Part*>(&to_msg);
  auto& from = static_cast<const Part&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:open_vector_format.Part)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_exposure_order()->MergeFrom(from._internal_exposure_order());
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_parent_part_name().empty()) {
    _this->_internal_set_parent_part_name(from._internal_parent_part_name());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_geometry_info()->::open_vector_format::Part_GeometryInfo::MergeFrom(
          from._internal_geometry_info());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_material()->::open_vector_format::Part_Material::MergeFrom(
          from._internal_material());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_process_strategy()->::open_vector_format::Part_ProcessStrategy::MergeFrom(
          from._internal_process_strategy());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_up_skin_process_strategy()->::open_vector_format::Part_ProcessStrategy::MergeFrom(
          from._internal_up_skin_process_strategy());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_down_skin_process_strategy()->::open_vector_format::Part_ProcessStrategy::MergeFrom(
          from._internal_down_skin_process_strategy());
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Part::CopyFrom(const Part& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:open_vector_format.Part)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Part::IsInitialized() const {
  return true;
}

void Part::InternalSwap(Part* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.exposure_order_.InternalSwap(&other->_impl_.exposure_order_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena,
                                       &other->_impl_.name_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.parent_part_name_, lhs_arena,
                                       &other->_impl_.parent_part_name_, rhs_arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Part, _impl_.down_skin_process_strategy_)
      + sizeof(Part::_impl_.down_skin_process_strategy_)
      - PROTOBUF_FIELD_OFFSET(Part, _impl_.geometry_info_)>(
          reinterpret_cast<char*>(&_impl_.geometry_info_),
          reinterpret_cast<char*>(&other->_impl_.geometry_info_));
}

::google::protobuf::Metadata Part::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_open_5fvector_5fformat_2eproto_getter, &descriptor_table_open_5fvector_5fformat_2eproto_once,
      file_level_metadata_open_5fvector_5fformat_2eproto[11]);
}
// ===================================================================

WorkPlane_WorkPlaneMetaData_PatchesMapEntry_DoNotUse::WorkPlane_WorkPlaneMetaData_PatchesMapEntry_DoNotUse() {}
WorkPlane_WorkPlaneMetaData_PatchesMapEntry_DoNotUse::WorkPlane_WorkPlaneMetaData_PatchesMapEntry_DoNotUse(::google::protobuf::Arena* arena)
    : SuperType(arena) {}
void WorkPlane_WorkPlaneMetaData_PatchesMapEntry_DoNotUse::MergeFrom(const WorkPlane_WorkPlaneMetaData_PatchesMapEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::google::protobuf::Metadata WorkPlane_WorkPlaneMetaData_PatchesMapEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_open_5fvector_5fformat_2eproto_getter, &descriptor_table_open_5fvector_5fformat_2eproto_once,
      file_level_metadata_open_5fvector_5fformat_2eproto[12]);
}
// ===================================================================

class WorkPlane_WorkPlaneMetaData_closedContour::_Internal {
 public:
};

WorkPlane_WorkPlaneMetaData_closedContour::WorkPlane_WorkPlaneMetaData_closedContour(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:open_vector_format.WorkPlane.WorkPlaneMetaData.closedContour)
}
WorkPlane_WorkPlaneMetaData_closedContour::WorkPlane_WorkPlaneMetaData_closedContour(const WorkPlane_WorkPlaneMetaData_closedContour& from) : ::google::protobuf::Message() {
  WorkPlane_WorkPlaneMetaData_closedContour* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.contour_section_vector_block_indices_){from._impl_.contour_section_vector_block_indices_},
      /* _impl_._contour_section_vector_block_indices_cached_byte_size_ = */ {0},
      decltype(_impl_.area_in_mm_2_){},
      decltype(_impl_.length_in_mm_){},
      decltype(_impl_.parent_index_){},
      decltype(_impl_.winding_number_){},
      decltype(_impl_.type_){},
      /*decltype(_impl_._cached_size_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  ::memcpy(&_impl_.area_in_mm_2_, &from._impl_.area_in_mm_2_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.area_in_mm_2_)) + sizeof(_impl_.type_));

  // @@protoc_insertion_point(copy_constructor:open_vector_format.WorkPlane.WorkPlaneMetaData.closedContour)
}
inline void WorkPlane_WorkPlaneMetaData_closedContour::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.contour_section_vector_block_indices_){arena},
      /* _impl_._contour_section_vector_block_indices_cached_byte_size_ = */ {0},
      decltype(_impl_.area_in_mm_2_){0},
      decltype(_impl_.length_in_mm_){0},
      decltype(_impl_.parent_index_){0},
      decltype(_impl_.winding_number_){0},
      decltype(_impl_.type_){0},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
WorkPlane_WorkPlaneMetaData_closedContour::~WorkPlane_WorkPlaneMetaData_closedContour() {
  // @@protoc_insertion_point(destructor:open_vector_format.WorkPlane.WorkPlaneMetaData.closedContour)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void WorkPlane_WorkPlaneMetaData_closedContour::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.contour_section_vector_block_indices_.~RepeatedField();
}
void WorkPlane_WorkPlaneMetaData_closedContour::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void WorkPlane_WorkPlaneMetaData_closedContour::Clear() {
// @@protoc_insertion_point(message_clear_start:open_vector_format.WorkPlane.WorkPlaneMetaData.closedContour)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_contour_section_vector_block_indices()->Clear();
  ::memset(&_impl_.area_in_mm_2_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.type_) -
      reinterpret_cast<char*>(&_impl_.area_in_mm_2_)) + sizeof(_impl_.type_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* WorkPlane_WorkPlaneMetaData_closedContour::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 0, 0, 2> WorkPlane_WorkPlaneMetaData_closedContour::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    7, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967176,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_WorkPlane_WorkPlaneMetaData_closedContour_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // repeated int32 contour_section_vector_block_indices = 1;
    {::_pbi::TcParser::FastV32P1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(WorkPlane_WorkPlaneMetaData_closedContour, _impl_.contour_section_vector_block_indices_)}},
    // float area_in_mm_2 = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(WorkPlane_WorkPlaneMetaData_closedContour, _impl_.area_in_mm_2_)}},
    // float length_in_mm = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 63, 0, PROTOBUF_FIELD_OFFSET(WorkPlane_WorkPlaneMetaData_closedContour, _impl_.length_in_mm_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // int32 parent_index = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(WorkPlane_WorkPlaneMetaData_closedContour, _impl_.parent_index_), 63>(),
     {40, 63, 0, PROTOBUF_FIELD_OFFSET(WorkPlane_WorkPlaneMetaData_closedContour, _impl_.parent_index_)}},
    // int32 winding_number = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(WorkPlane_WorkPlaneMetaData_closedContour, _impl_.winding_number_), 63>(),
     {48, 63, 0, PROTOBUF_FIELD_OFFSET(WorkPlane_WorkPlaneMetaData_closedContour, _impl_.winding_number_)}},
    // .open_vector_format.WorkPlane.WorkPlaneMetaData.closedContour.ContourType type = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(WorkPlane_WorkPlaneMetaData_closedContour, _impl_.type_), 63>(),
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(WorkPlane_WorkPlaneMetaData_closedContour, _impl_.type_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated int32 contour_section_vector_block_indices = 1;
    {PROTOBUF_FIELD_OFFSET(WorkPlane_WorkPlaneMetaData_closedContour, _impl_.contour_section_vector_block_indices_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
    // float area_in_mm_2 = 2;
    {PROTOBUF_FIELD_OFFSET(WorkPlane_WorkPlaneMetaData_closedContour, _impl_.area_in_mm_2_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float length_in_mm = 3;
    {PROTOBUF_FIELD_OFFSET(WorkPlane_WorkPlaneMetaData_closedContour, _impl_.length_in_mm_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // int32 parent_index = 5;
    {PROTOBUF_FIELD_OFFSET(WorkPlane_WorkPlaneMetaData_closedContour, _impl_.parent_index_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // int32 winding_number = 6;
    {PROTOBUF_FIELD_OFFSET(WorkPlane_WorkPlaneMetaData_closedContour, _impl_.winding_number_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // .open_vector_format.WorkPlane.WorkPlaneMetaData.closedContour.ContourType type = 7;
    {PROTOBUF_FIELD_OFFSET(WorkPlane_WorkPlaneMetaData_closedContour, _impl_.type_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* WorkPlane_WorkPlaneMetaData_closedContour::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:open_vector_format.WorkPlane.WorkPlaneMetaData.closedContour)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated int32 contour_section_vector_block_indices = 1;
  {
    int byte_size = _impl_._contour_section_vector_block_indices_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(1, _internal_contour_section_vector_block_indices(),
                                                 byte_size, target);
    }
  }

  // float area_in_mm_2 = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_area_in_mm_2 = this->_internal_area_in_mm_2();
  ::uint32_t raw_area_in_mm_2;
  memcpy(&raw_area_in_mm_2, &tmp_area_in_mm_2, sizeof(tmp_area_in_mm_2));
  if (raw_area_in_mm_2 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_area_in_mm_2(), target);
  }

  // float length_in_mm = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_length_in_mm = this->_internal_length_in_mm();
  ::uint32_t raw_length_in_mm;
  memcpy(&raw_length_in_mm, &tmp_length_in_mm, sizeof(tmp_length_in_mm));
  if (raw_length_in_mm != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_length_in_mm(), target);
  }

  // int32 parent_index = 5;
  if (this->_internal_parent_index() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<5>(
            stream, this->_internal_parent_index(), target);
  }

  // int32 winding_number = 6;
  if (this->_internal_winding_number() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<6>(
            stream, this->_internal_winding_number(), target);
  }

  // .open_vector_format.WorkPlane.WorkPlaneMetaData.closedContour.ContourType type = 7;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        7, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:open_vector_format.WorkPlane.WorkPlaneMetaData.closedContour)
  return target;
}

::size_t WorkPlane_WorkPlaneMetaData_closedContour::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:open_vector_format.WorkPlane.WorkPlaneMetaData.closedContour)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 contour_section_vector_block_indices = 1;
  {
    std::size_t data_size = ::_pbi::WireFormatLite::Int32Size(
        this->_internal_contour_section_vector_block_indices())
    ;
    _impl_._contour_section_vector_block_indices_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // float area_in_mm_2 = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_area_in_mm_2 = this->_internal_area_in_mm_2();
  ::uint32_t raw_area_in_mm_2;
  memcpy(&raw_area_in_mm_2, &tmp_area_in_mm_2, sizeof(tmp_area_in_mm_2));
  if (raw_area_in_mm_2 != 0) {
    total_size += 5;
  }

  // float length_in_mm = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_length_in_mm = this->_internal_length_in_mm();
  ::uint32_t raw_length_in_mm;
  memcpy(&raw_length_in_mm, &tmp_length_in_mm, sizeof(tmp_length_in_mm));
  if (raw_length_in_mm != 0) {
    total_size += 5;
  }

  // int32 parent_index = 5;
  if (this->_internal_parent_index() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_parent_index());
  }

  // int32 winding_number = 6;
  if (this->_internal_winding_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_winding_number());
  }

  // .open_vector_format.WorkPlane.WorkPlaneMetaData.closedContour.ContourType type = 7;
  if (this->_internal_type() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData WorkPlane_WorkPlaneMetaData_closedContour::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    WorkPlane_WorkPlaneMetaData_closedContour::MergeImpl
};
const ::google::protobuf::Message::ClassData*WorkPlane_WorkPlaneMetaData_closedContour::GetClassData() const { return &_class_data_; }


void WorkPlane_WorkPlaneMetaData_closedContour::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<WorkPlane_WorkPlaneMetaData_closedContour*>(&to_msg);
  auto& from = static_cast<const WorkPlane_WorkPlaneMetaData_closedContour&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:open_vector_format.WorkPlane.WorkPlaneMetaData.closedContour)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_contour_section_vector_block_indices()->MergeFrom(from._internal_contour_section_vector_block_indices());
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_area_in_mm_2 = from._internal_area_in_mm_2();
  ::uint32_t raw_area_in_mm_2;
  memcpy(&raw_area_in_mm_2, &tmp_area_in_mm_2, sizeof(tmp_area_in_mm_2));
  if (raw_area_in_mm_2 != 0) {
    _this->_internal_set_area_in_mm_2(from._internal_area_in_mm_2());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_length_in_mm = from._internal_length_in_mm();
  ::uint32_t raw_length_in_mm;
  memcpy(&raw_length_in_mm, &tmp_length_in_mm, sizeof(tmp_length_in_mm));
  if (raw_length_in_mm != 0) {
    _this->_internal_set_length_in_mm(from._internal_length_in_mm());
  }
  if (from._internal_parent_index() != 0) {
    _this->_internal_set_parent_index(from._internal_parent_index());
  }
  if (from._internal_winding_number() != 0) {
    _this->_internal_set_winding_number(from._internal_winding_number());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void WorkPlane_WorkPlaneMetaData_closedContour::CopyFrom(const WorkPlane_WorkPlaneMetaData_closedContour& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:open_vector_format.WorkPlane.WorkPlaneMetaData.closedContour)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool WorkPlane_WorkPlaneMetaData_closedContour::IsInitialized() const {
  return true;
}

void WorkPlane_WorkPlaneMetaData_closedContour::InternalSwap(WorkPlane_WorkPlaneMetaData_closedContour* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.contour_section_vector_block_indices_.InternalSwap(&other->_impl_.contour_section_vector_block_indices_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WorkPlane_WorkPlaneMetaData_closedContour, _impl_.type_)
      + sizeof(WorkPlane_WorkPlaneMetaData_closedContour::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(WorkPlane_WorkPlaneMetaData_closedContour, _impl_.area_in_mm_2_)>(
          reinterpret_cast<char*>(&_impl_.area_in_mm_2_),
          reinterpret_cast<char*>(&other->_impl_.area_in_mm_2_));
}

::google::protobuf::Metadata WorkPlane_WorkPlaneMetaData_closedContour::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_open_5fvector_5fformat_2eproto_getter, &descriptor_table_open_5fvector_5fformat_2eproto_once,
      file_level_metadata_open_5fvector_5fformat_2eproto[13]);
}
// ===================================================================

class WorkPlane_WorkPlaneMetaData::_Internal {
 public:
  using HasBits = decltype(std::declval<WorkPlane_WorkPlaneMetaData>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(WorkPlane_WorkPlaneMetaData, _impl_._has_bits_);
  static const ::open_vector_format::AxisAlignedBox2D& bounds(const WorkPlane_WorkPlaneMetaData* msg);
  static void set_has_bounds(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::open_vector_format::AxisAlignedBox2D& WorkPlane_WorkPlaneMetaData::_Internal::bounds(const WorkPlane_WorkPlaneMetaData* msg) {
  return *msg->_impl_.bounds_;
}
WorkPlane_WorkPlaneMetaData::WorkPlane_WorkPlaneMetaData(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:open_vector_format.WorkPlane.WorkPlaneMetaData)
}
WorkPlane_WorkPlaneMetaData::WorkPlane_WorkPlaneMetaData(const WorkPlane_WorkPlaneMetaData& from) : ::google::protobuf::Message() {
  WorkPlane_WorkPlaneMetaData* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      /* decltype(_impl_.patches_map_) */ {},
      decltype(_impl_.contours_){from._impl_.contours_},
      decltype(_impl_.bounds_){nullptr},
      decltype(_impl_.total_scan_distance_in_mm_){},
      decltype(_impl_.total_jump_distance_in_mm_){},
      decltype(_impl_.maxpower_){},
      decltype(_impl_.minpower_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _this->_impl_.patches_map_.MergeFrom(from._impl_.patches_map_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.bounds_ = new ::open_vector_format::AxisAlignedBox2D(*from._impl_.bounds_);
  }
  ::memcpy(&_impl_.total_scan_distance_in_mm_, &from._impl_.total_scan_distance_in_mm_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.minpower_) -
    reinterpret_cast<char*>(&_impl_.total_scan_distance_in_mm_)) + sizeof(_impl_.minpower_));

  // @@protoc_insertion_point(copy_constructor:open_vector_format.WorkPlane.WorkPlaneMetaData)
}
inline void WorkPlane_WorkPlaneMetaData::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      /* decltype(_impl_.patches_map_) */ {::google::protobuf::internal::ArenaInitialized(), arena},
      decltype(_impl_.contours_){arena},
      decltype(_impl_.bounds_){nullptr},
      decltype(_impl_.total_scan_distance_in_mm_){0},
      decltype(_impl_.total_jump_distance_in_mm_){0},
      decltype(_impl_.maxpower_){0},
      decltype(_impl_.minpower_){0},
  };
}
WorkPlane_WorkPlaneMetaData::~WorkPlane_WorkPlaneMetaData() {
  // @@protoc_insertion_point(destructor:open_vector_format.WorkPlane.WorkPlaneMetaData)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void WorkPlane_WorkPlaneMetaData::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.patches_map_.~MapField();
  _impl_.contours_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.bounds_;
}
void WorkPlane_WorkPlaneMetaData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void WorkPlane_WorkPlaneMetaData::Clear() {
// @@protoc_insertion_point(message_clear_start:open_vector_format.WorkPlane.WorkPlaneMetaData)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.patches_map_.Clear();
  _internal_mutable_contours()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.bounds_ != nullptr);
    _impl_.bounds_->Clear();
  }
  ::memset(&_impl_.total_scan_distance_in_mm_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.minpower_) -
      reinterpret_cast<char*>(&_impl_.total_scan_distance_in_mm_)) + sizeof(_impl_.minpower_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* WorkPlane_WorkPlaneMetaData::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 4, 0, 2> WorkPlane_WorkPlaneMetaData::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(WorkPlane_WorkPlaneMetaData, _impl_._has_bits_),
    0, // no _extensions_
    7, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    4,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_WorkPlane_WorkPlaneMetaData_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // double total_scan_distance_in_mm = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(WorkPlane_WorkPlaneMetaData, _impl_.total_scan_distance_in_mm_)}},
    // double total_jump_distance_in_mm = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(WorkPlane_WorkPlaneMetaData, _impl_.total_jump_distance_in_mm_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // float maxPower = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 63, 0, PROTOBUF_FIELD_OFFSET(WorkPlane_WorkPlaneMetaData, _impl_.maxpower_)}},
    // float minPower = 5;
    {::_pbi::TcParser::FastF32S1,
     {45, 63, 0, PROTOBUF_FIELD_OFFSET(WorkPlane_WorkPlaneMetaData, _impl_.minpower_)}},
    // repeated .open_vector_format.WorkPlane.WorkPlaneMetaData.closedContour contours = 6;
    {::_pbi::TcParser::FastMtR1,
     {50, 63, 2, PROTOBUF_FIELD_OFFSET(WorkPlane_WorkPlaneMetaData, _impl_.contours_)}},
    // .open_vector_format.AxisAlignedBox2D Bounds = 7;
    {::_pbi::TcParser::FastMtS1,
     {58, 0, 3, PROTOBUF_FIELD_OFFSET(WorkPlane_WorkPlaneMetaData, _impl_.bounds_)}},
  }}, {{
    65535, 65535
  }}, {{
    // double total_scan_distance_in_mm = 1;
    {PROTOBUF_FIELD_OFFSET(WorkPlane_WorkPlaneMetaData, _impl_.total_scan_distance_in_mm_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double total_jump_distance_in_mm = 2;
    {PROTOBUF_FIELD_OFFSET(WorkPlane_WorkPlaneMetaData, _impl_.total_jump_distance_in_mm_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // map<int32, .open_vector_format.WorkPlane.Patch> patches_map = 3;
    {PROTOBUF_FIELD_OFFSET(WorkPlane_WorkPlaneMetaData, _impl_.patches_map_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMap)},
    // float maxPower = 4;
    {PROTOBUF_FIELD_OFFSET(WorkPlane_WorkPlaneMetaData, _impl_.maxpower_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float minPower = 5;
    {PROTOBUF_FIELD_OFFSET(WorkPlane_WorkPlaneMetaData, _impl_.minpower_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // repeated .open_vector_format.WorkPlane.WorkPlaneMetaData.closedContour contours = 6;
    {PROTOBUF_FIELD_OFFSET(WorkPlane_WorkPlaneMetaData, _impl_.contours_), -1, 2,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // .open_vector_format.AxisAlignedBox2D Bounds = 7;
    {PROTOBUF_FIELD_OFFSET(WorkPlane_WorkPlaneMetaData, _impl_.bounds_), _Internal::kHasBitsOffset + 0, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetMapAuxInfo<decltype(WorkPlane_WorkPlaneMetaData()._impl_.patches_map_)>(1, 0, 0)},
    {::_pbi::TcParser::CreateInArenaStorageCb<::open_vector_format::WorkPlane_Patch>},
    {::_pbi::TcParser::GetTable<::open_vector_format::WorkPlane_WorkPlaneMetaData_closedContour>()},
    {::_pbi::TcParser::GetTable<::open_vector_format::AxisAlignedBox2D>()},
  }}, {{
  }},
};

::uint8_t* WorkPlane_WorkPlaneMetaData::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:open_vector_format.WorkPlane.WorkPlaneMetaData)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double total_scan_distance_in_mm = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_total_scan_distance_in_mm = this->_internal_total_scan_distance_in_mm();
  ::uint64_t raw_total_scan_distance_in_mm;
  memcpy(&raw_total_scan_distance_in_mm, &tmp_total_scan_distance_in_mm, sizeof(tmp_total_scan_distance_in_mm));
  if (raw_total_scan_distance_in_mm != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_total_scan_distance_in_mm(), target);
  }

  // double total_jump_distance_in_mm = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_total_jump_distance_in_mm = this->_internal_total_jump_distance_in_mm();
  ::uint64_t raw_total_jump_distance_in_mm;
  memcpy(&raw_total_jump_distance_in_mm, &tmp_total_jump_distance_in_mm, sizeof(tmp_total_jump_distance_in_mm));
  if (raw_total_jump_distance_in_mm != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_total_jump_distance_in_mm(), target);
  }

  // map<int32, .open_vector_format.WorkPlane.Patch> patches_map = 3;
  if (!_internal_patches_map().empty()) {
    using MapType = ::google::protobuf::Map<::int32_t, ::open_vector_format::WorkPlane_Patch>;
    using WireHelper = WorkPlane_WorkPlaneMetaData_PatchesMapEntry_DoNotUse::Funcs;
    const auto& field = _internal_patches_map();

    if (stream->IsSerializationDeterministic() && field.size() > 1) {
      for (const auto& entry : ::google::protobuf::internal::MapSorterFlat<MapType>(field)) {
        target = WireHelper::InternalSerialize(
            3, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : field) {
        target = WireHelper::InternalSerialize(
            3, entry.first, entry.second, target, stream);
      }
    }
  }

  // float maxPower = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_maxpower = this->_internal_maxpower();
  ::uint32_t raw_maxpower;
  memcpy(&raw_maxpower, &tmp_maxpower, sizeof(tmp_maxpower));
  if (raw_maxpower != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_maxpower(), target);
  }

  // float minPower = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_minpower = this->_internal_minpower();
  ::uint32_t raw_minpower;
  memcpy(&raw_minpower, &tmp_minpower, sizeof(tmp_minpower));
  if (raw_minpower != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_minpower(), target);
  }

  // repeated .open_vector_format.WorkPlane.WorkPlaneMetaData.closedContour contours = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_contours_size()); i < n; i++) {
    const auto& repfield = this->_internal_contours().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .open_vector_format.AxisAlignedBox2D Bounds = 7;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::bounds(this),
        _Internal::bounds(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:open_vector_format.WorkPlane.WorkPlaneMetaData)
  return target;
}

::size_t WorkPlane_WorkPlaneMetaData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:open_vector_format.WorkPlane.WorkPlaneMetaData)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<int32, .open_vector_format.WorkPlane.Patch> patches_map = 3;
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_patches_map_size());
  for (const auto& entry : _internal_patches_map()) {
    total_size += WorkPlane_WorkPlaneMetaData_PatchesMapEntry_DoNotUse::Funcs::ByteSizeLong(entry.first, entry.second);
  }
  // repeated .open_vector_format.WorkPlane.WorkPlaneMetaData.closedContour contours = 6;
  total_size += 1UL * this->_internal_contours_size();
  for (const auto& msg : this->_internal_contours()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // .open_vector_format.AxisAlignedBox2D Bounds = 7;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *_impl_.bounds_);
  }

  // double total_scan_distance_in_mm = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_total_scan_distance_in_mm = this->_internal_total_scan_distance_in_mm();
  ::uint64_t raw_total_scan_distance_in_mm;
  memcpy(&raw_total_scan_distance_in_mm, &tmp_total_scan_distance_in_mm, sizeof(tmp_total_scan_distance_in_mm));
  if (raw_total_scan_distance_in_mm != 0) {
    total_size += 9;
  }

  // double total_jump_distance_in_mm = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_total_jump_distance_in_mm = this->_internal_total_jump_distance_in_mm();
  ::uint64_t raw_total_jump_distance_in_mm;
  memcpy(&raw_total_jump_distance_in_mm, &tmp_total_jump_distance_in_mm, sizeof(tmp_total_jump_distance_in_mm));
  if (raw_total_jump_distance_in_mm != 0) {
    total_size += 9;
  }

  // float maxPower = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_maxpower = this->_internal_maxpower();
  ::uint32_t raw_maxpower;
  memcpy(&raw_maxpower, &tmp_maxpower, sizeof(tmp_maxpower));
  if (raw_maxpower != 0) {
    total_size += 5;
  }

  // float minPower = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_minpower = this->_internal_minpower();
  ::uint32_t raw_minpower;
  memcpy(&raw_minpower, &tmp_minpower, sizeof(tmp_minpower));
  if (raw_minpower != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData WorkPlane_WorkPlaneMetaData::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    WorkPlane_WorkPlaneMetaData::MergeImpl
};
const ::google::protobuf::Message::ClassData*WorkPlane_WorkPlaneMetaData::GetClassData() const { return &_class_data_; }


void WorkPlane_WorkPlaneMetaData::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<WorkPlane_WorkPlaneMetaData*>(&to_msg);
  auto& from = static_cast<const WorkPlane_WorkPlaneMetaData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:open_vector_format.WorkPlane.WorkPlaneMetaData)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.patches_map_.MergeFrom(from._impl_.patches_map_);
  _this->_internal_mutable_contours()->MergeFrom(from._internal_contours());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_bounds()->::open_vector_format::AxisAlignedBox2D::MergeFrom(
        from._internal_bounds());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_total_scan_distance_in_mm = from._internal_total_scan_distance_in_mm();
  ::uint64_t raw_total_scan_distance_in_mm;
  memcpy(&raw_total_scan_distance_in_mm, &tmp_total_scan_distance_in_mm, sizeof(tmp_total_scan_distance_in_mm));
  if (raw_total_scan_distance_in_mm != 0) {
    _this->_internal_set_total_scan_distance_in_mm(from._internal_total_scan_distance_in_mm());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_total_jump_distance_in_mm = from._internal_total_jump_distance_in_mm();
  ::uint64_t raw_total_jump_distance_in_mm;
  memcpy(&raw_total_jump_distance_in_mm, &tmp_total_jump_distance_in_mm, sizeof(tmp_total_jump_distance_in_mm));
  if (raw_total_jump_distance_in_mm != 0) {
    _this->_internal_set_total_jump_distance_in_mm(from._internal_total_jump_distance_in_mm());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_maxpower = from._internal_maxpower();
  ::uint32_t raw_maxpower;
  memcpy(&raw_maxpower, &tmp_maxpower, sizeof(tmp_maxpower));
  if (raw_maxpower != 0) {
    _this->_internal_set_maxpower(from._internal_maxpower());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_minpower = from._internal_minpower();
  ::uint32_t raw_minpower;
  memcpy(&raw_minpower, &tmp_minpower, sizeof(tmp_minpower));
  if (raw_minpower != 0) {
    _this->_internal_set_minpower(from._internal_minpower());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void WorkPlane_WorkPlaneMetaData::CopyFrom(const WorkPlane_WorkPlaneMetaData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:open_vector_format.WorkPlane.WorkPlaneMetaData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool WorkPlane_WorkPlaneMetaData::IsInitialized() const {
  return true;
}

void WorkPlane_WorkPlaneMetaData::InternalSwap(WorkPlane_WorkPlaneMetaData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.patches_map_.InternalSwap(&other->_impl_.patches_map_);
  _impl_.contours_.InternalSwap(&other->_impl_.contours_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WorkPlane_WorkPlaneMetaData, _impl_.minpower_)
      + sizeof(WorkPlane_WorkPlaneMetaData::_impl_.minpower_)
      - PROTOBUF_FIELD_OFFSET(WorkPlane_WorkPlaneMetaData, _impl_.bounds_)>(
          reinterpret_cast<char*>(&_impl_.bounds_),
          reinterpret_cast<char*>(&other->_impl_.bounds_));
}

::google::protobuf::Metadata WorkPlane_WorkPlaneMetaData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_open_5fvector_5fformat_2eproto_getter, &descriptor_table_open_5fvector_5fformat_2eproto_once,
      file_level_metadata_open_5fvector_5fformat_2eproto[14]);
}
// ===================================================================

class WorkPlane_Patch::_Internal {
 public:
  using HasBits = decltype(std::declval<WorkPlane_Patch>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(WorkPlane_Patch, _impl_._has_bits_);
  static const ::open_vector_format::VectorBlock_LineSequence& outer_contour(const WorkPlane_Patch* msg);
  static void set_has_outer_contour(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::open_vector_format::VectorBlock_LineSequence& WorkPlane_Patch::_Internal::outer_contour(const WorkPlane_Patch* msg) {
  return *msg->_impl_.outer_contour_;
}
WorkPlane_Patch::WorkPlane_Patch(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:open_vector_format.WorkPlane.Patch)
}
WorkPlane_Patch::WorkPlane_Patch(const WorkPlane_Patch& from) : ::google::protobuf::Message() {
  WorkPlane_Patch* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.outer_contour_){nullptr},
      decltype(_impl_.u_){},
      decltype(_impl_.v_){},
      decltype(_impl_.layer_id_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.outer_contour_ = new ::open_vector_format::VectorBlock_LineSequence(*from._impl_.outer_contour_);
  }
  ::memcpy(&_impl_.u_, &from._impl_.u_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.layer_id_) -
    reinterpret_cast<char*>(&_impl_.u_)) + sizeof(_impl_.layer_id_));

  // @@protoc_insertion_point(copy_constructor:open_vector_format.WorkPlane.Patch)
}
inline void WorkPlane_Patch::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.outer_contour_){nullptr},
      decltype(_impl_.u_){0},
      decltype(_impl_.v_){0},
      decltype(_impl_.layer_id_){0},
  };
}
WorkPlane_Patch::~WorkPlane_Patch() {
  // @@protoc_insertion_point(destructor:open_vector_format.WorkPlane.Patch)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void WorkPlane_Patch::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.outer_contour_;
}
void WorkPlane_Patch::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void WorkPlane_Patch::Clear() {
// @@protoc_insertion_point(message_clear_start:open_vector_format.WorkPlane.Patch)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.outer_contour_ != nullptr);
    _impl_.outer_contour_->Clear();
  }
  ::memset(&_impl_.u_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.layer_id_) -
      reinterpret_cast<char*>(&_impl_.u_)) + sizeof(_impl_.layer_id_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* WorkPlane_Patch::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 1, 0, 2> WorkPlane_Patch::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(WorkPlane_Patch, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_WorkPlane_Patch_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // int32 layer_id = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(WorkPlane_Patch, _impl_.layer_id_), 63>(),
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(WorkPlane_Patch, _impl_.layer_id_)}},
    // .open_vector_format.VectorBlock.LineSequence outer_contour = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(WorkPlane_Patch, _impl_.outer_contour_)}},
    // float u = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(WorkPlane_Patch, _impl_.u_)}},
    // float v = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 63, 0, PROTOBUF_FIELD_OFFSET(WorkPlane_Patch, _impl_.v_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .open_vector_format.VectorBlock.LineSequence outer_contour = 1;
    {PROTOBUF_FIELD_OFFSET(WorkPlane_Patch, _impl_.outer_contour_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // float u = 2;
    {PROTOBUF_FIELD_OFFSET(WorkPlane_Patch, _impl_.u_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float v = 3;
    {PROTOBUF_FIELD_OFFSET(WorkPlane_Patch, _impl_.v_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // int32 layer_id = 4;
    {PROTOBUF_FIELD_OFFSET(WorkPlane_Patch, _impl_.layer_id_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
  }}, {{
    {::_pbi::TcParser::GetTable<::open_vector_format::VectorBlock_LineSequence>()},
  }}, {{
  }},
};

::uint8_t* WorkPlane_Patch::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:open_vector_format.WorkPlane.Patch)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .open_vector_format.VectorBlock.LineSequence outer_contour = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::outer_contour(this),
        _Internal::outer_contour(this).GetCachedSize(), target, stream);
  }

  // float u = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_u = this->_internal_u();
  ::uint32_t raw_u;
  memcpy(&raw_u, &tmp_u, sizeof(tmp_u));
  if (raw_u != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_u(), target);
  }

  // float v = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_v = this->_internal_v();
  ::uint32_t raw_v;
  memcpy(&raw_v, &tmp_v, sizeof(tmp_v));
  if (raw_v != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_v(), target);
  }

  // int32 layer_id = 4;
  if (this->_internal_layer_id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<4>(
            stream, this->_internal_layer_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:open_vector_format.WorkPlane.Patch)
  return target;
}

::size_t WorkPlane_Patch::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:open_vector_format.WorkPlane.Patch)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .open_vector_format.VectorBlock.LineSequence outer_contour = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *_impl_.outer_contour_);
  }

  // float u = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_u = this->_internal_u();
  ::uint32_t raw_u;
  memcpy(&raw_u, &tmp_u, sizeof(tmp_u));
  if (raw_u != 0) {
    total_size += 5;
  }

  // float v = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_v = this->_internal_v();
  ::uint32_t raw_v;
  memcpy(&raw_v, &tmp_v, sizeof(tmp_v));
  if (raw_v != 0) {
    total_size += 5;
  }

  // int32 layer_id = 4;
  if (this->_internal_layer_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_layer_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData WorkPlane_Patch::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    WorkPlane_Patch::MergeImpl
};
const ::google::protobuf::Message::ClassData*WorkPlane_Patch::GetClassData() const { return &_class_data_; }


void WorkPlane_Patch::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<WorkPlane_Patch*>(&to_msg);
  auto& from = static_cast<const WorkPlane_Patch&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:open_vector_format.WorkPlane.Patch)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_outer_contour()->::open_vector_format::VectorBlock_LineSequence::MergeFrom(
        from._internal_outer_contour());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_u = from._internal_u();
  ::uint32_t raw_u;
  memcpy(&raw_u, &tmp_u, sizeof(tmp_u));
  if (raw_u != 0) {
    _this->_internal_set_u(from._internal_u());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_v = from._internal_v();
  ::uint32_t raw_v;
  memcpy(&raw_v, &tmp_v, sizeof(tmp_v));
  if (raw_v != 0) {
    _this->_internal_set_v(from._internal_v());
  }
  if (from._internal_layer_id() != 0) {
    _this->_internal_set_layer_id(from._internal_layer_id());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void WorkPlane_Patch::CopyFrom(const WorkPlane_Patch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:open_vector_format.WorkPlane.Patch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool WorkPlane_Patch::IsInitialized() const {
  return true;
}

void WorkPlane_Patch::InternalSwap(WorkPlane_Patch* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WorkPlane_Patch, _impl_.layer_id_)
      + sizeof(WorkPlane_Patch::_impl_.layer_id_)
      - PROTOBUF_FIELD_OFFSET(WorkPlane_Patch, _impl_.outer_contour_)>(
          reinterpret_cast<char*>(&_impl_.outer_contour_),
          reinterpret_cast<char*>(&other->_impl_.outer_contour_));
}

::google::protobuf::Metadata WorkPlane_Patch::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_open_5fvector_5fformat_2eproto_getter, &descriptor_table_open_5fvector_5fformat_2eproto_once,
      file_level_metadata_open_5fvector_5fformat_2eproto[15]);
}
// ===================================================================

class WorkPlane::_Internal {
 public:
  using HasBits = decltype(std::declval<WorkPlane>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(WorkPlane, _impl_._has_bits_);
  static const ::open_vector_format::WorkPlane_WorkPlaneMetaData& meta_data(const WorkPlane* msg);
  static void set_has_meta_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::open_vector_format::WorkPlane_WorkPlaneMetaData& WorkPlane::_Internal::meta_data(const WorkPlane* msg) {
  return *msg->_impl_.meta_data_;
}
WorkPlane::WorkPlane(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:open_vector_format.WorkPlane)
}
WorkPlane::WorkPlane(const WorkPlane& from) : ::google::protobuf::Message() {
  WorkPlane* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.vector_blocks_){from._impl_.vector_blocks_},
      decltype(_impl_.additional_axis_positions_){from._impl_.additional_axis_positions_},
      decltype(_impl_.machine_type_){},
      decltype(_impl_.meta_data_){nullptr},
      decltype(_impl_.x_pos_in_mm_){},
      decltype(_impl_.y_pos_in_mm_){},
      decltype(_impl_.z_pos_in_mm_){},
      decltype(_impl_.x_rot_in_deg_){},
      decltype(_impl_.y_rot_in_deg_){},
      decltype(_impl_.z_rot_in_deg_){},
      decltype(_impl_.num_blocks_){},
      decltype(_impl_.repeats_){},
      decltype(_impl_.work_plane_number_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _impl_.machine_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.machine_type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_machine_type().empty()) {
    _this->_impl_.machine_type_.Set(from._internal_machine_type(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.meta_data_ = new ::open_vector_format::WorkPlane_WorkPlaneMetaData(*from._impl_.meta_data_);
  }
  ::memcpy(&_impl_.x_pos_in_mm_, &from._impl_.x_pos_in_mm_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.work_plane_number_) -
    reinterpret_cast<char*>(&_impl_.x_pos_in_mm_)) + sizeof(_impl_.work_plane_number_));

  // @@protoc_insertion_point(copy_constructor:open_vector_format.WorkPlane)
}
inline void WorkPlane::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.vector_blocks_){arena},
      decltype(_impl_.additional_axis_positions_){arena},
      decltype(_impl_.machine_type_){},
      decltype(_impl_.meta_data_){nullptr},
      decltype(_impl_.x_pos_in_mm_){0},
      decltype(_impl_.y_pos_in_mm_){0},
      decltype(_impl_.z_pos_in_mm_){0},
      decltype(_impl_.x_rot_in_deg_){0},
      decltype(_impl_.y_rot_in_deg_){0},
      decltype(_impl_.z_rot_in_deg_){0},
      decltype(_impl_.num_blocks_){0},
      decltype(_impl_.repeats_){0u},
      decltype(_impl_.work_plane_number_){0},
  };
  _impl_.machine_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.machine_type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}
WorkPlane::~WorkPlane() {
  // @@protoc_insertion_point(destructor:open_vector_format.WorkPlane)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void WorkPlane::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.vector_blocks_.~RepeatedPtrField();
  _impl_.additional_axis_positions_.~RepeatedField();
  _impl_.machine_type_.Destroy();
  if (this != internal_default_instance()) delete _impl_.meta_data_;
}
void WorkPlane::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void WorkPlane::Clear() {
// @@protoc_insertion_point(message_clear_start:open_vector_format.WorkPlane)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_vector_blocks()->Clear();
  _internal_mutable_additional_axis_positions()->Clear();
  _impl_.machine_type_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.meta_data_ != nullptr);
    _impl_.meta_data_->Clear();
  }
  ::memset(&_impl_.x_pos_in_mm_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.work_plane_number_) -
      reinterpret_cast<char*>(&_impl_.x_pos_in_mm_)) + sizeof(_impl_.work_plane_number_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* WorkPlane::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 13, 2, 57, 2> WorkPlane::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(WorkPlane, _impl_._has_bits_),
    0, // no _extensions_
    13, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294959104,  // skipmap
    offsetof(decltype(_table_), field_entries),
    13,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_WorkPlane_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .open_vector_format.VectorBlock vector_blocks = 1;
    {::_pbi::TcParser::FastMtR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(WorkPlane, _impl_.vector_blocks_)}},
    // float x_pos_in_mm = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(WorkPlane, _impl_.x_pos_in_mm_)}},
    // float y_pos_in_mm = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 63, 0, PROTOBUF_FIELD_OFFSET(WorkPlane, _impl_.y_pos_in_mm_)}},
    // float z_pos_in_mm = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 63, 0, PROTOBUF_FIELD_OFFSET(WorkPlane, _impl_.z_pos_in_mm_)}},
    // float x_rot_in_deg = 5;
    {::_pbi::TcParser::FastF32S1,
     {45, 63, 0, PROTOBUF_FIELD_OFFSET(WorkPlane, _impl_.x_rot_in_deg_)}},
    // float y_rot_in_deg = 6;
    {::_pbi::TcParser::FastF32S1,
     {53, 63, 0, PROTOBUF_FIELD_OFFSET(WorkPlane, _impl_.y_rot_in_deg_)}},
    // float z_rot_in_deg = 7;
    {::_pbi::TcParser::FastF32S1,
     {61, 63, 0, PROTOBUF_FIELD_OFFSET(WorkPlane, _impl_.z_rot_in_deg_)}},
    // int32 num_blocks = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(WorkPlane, _impl_.num_blocks_), 63>(),
     {64, 63, 0, PROTOBUF_FIELD_OFFSET(WorkPlane, _impl_.num_blocks_)}},
    // uint32 repeats = 9;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(WorkPlane, _impl_.repeats_), 63>(),
     {72, 63, 0, PROTOBUF_FIELD_OFFSET(WorkPlane, _impl_.repeats_)}},
    // int32 work_plane_number = 10;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(WorkPlane, _impl_.work_plane_number_), 63>(),
     {80, 63, 0, PROTOBUF_FIELD_OFFSET(WorkPlane, _impl_.work_plane_number_)}},
    // string machine_type = 11;
    {::_pbi::TcParser::FastUS1,
     {90, 63, 0, PROTOBUF_FIELD_OFFSET(WorkPlane, _impl_.machine_type_)}},
    // repeated float additional_axis_positions = 12;
    {::_pbi::TcParser::FastF32P1,
     {98, 63, 0, PROTOBUF_FIELD_OFFSET(WorkPlane, _impl_.additional_axis_positions_)}},
    // .open_vector_format.WorkPlane.WorkPlaneMetaData meta_data = 13;
    {::_pbi::TcParser::FastMtS1,
     {106, 0, 1, PROTOBUF_FIELD_OFFSET(WorkPlane, _impl_.meta_data_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .open_vector_format.VectorBlock vector_blocks = 1;
    {PROTOBUF_FIELD_OFFSET(WorkPlane, _impl_.vector_blocks_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // float x_pos_in_mm = 2;
    {PROTOBUF_FIELD_OFFSET(WorkPlane, _impl_.x_pos_in_mm_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float y_pos_in_mm = 3;
    {PROTOBUF_FIELD_OFFSET(WorkPlane, _impl_.y_pos_in_mm_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float z_pos_in_mm = 4;
    {PROTOBUF_FIELD_OFFSET(WorkPlane, _impl_.z_pos_in_mm_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float x_rot_in_deg = 5;
    {PROTOBUF_FIELD_OFFSET(WorkPlane, _impl_.x_rot_in_deg_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float y_rot_in_deg = 6;
    {PROTOBUF_FIELD_OFFSET(WorkPlane, _impl_.y_rot_in_deg_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float z_rot_in_deg = 7;
    {PROTOBUF_FIELD_OFFSET(WorkPlane, _impl_.z_rot_in_deg_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // int32 num_blocks = 8;
    {PROTOBUF_FIELD_OFFSET(WorkPlane, _impl_.num_blocks_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // uint32 repeats = 9;
    {PROTOBUF_FIELD_OFFSET(WorkPlane, _impl_.repeats_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // int32 work_plane_number = 10;
    {PROTOBUF_FIELD_OFFSET(WorkPlane, _impl_.work_plane_number_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // string machine_type = 11;
    {PROTOBUF_FIELD_OFFSET(WorkPlane, _impl_.machine_type_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // repeated float additional_axis_positions = 12;
    {PROTOBUF_FIELD_OFFSET(WorkPlane, _impl_.additional_axis_positions_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedFloat)},
    // .open_vector_format.WorkPlane.WorkPlaneMetaData meta_data = 13;
    {PROTOBUF_FIELD_OFFSET(WorkPlane, _impl_.meta_data_), _Internal::kHasBitsOffset + 0, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::open_vector_format::VectorBlock>()},
    {::_pbi::TcParser::GetTable<::open_vector_format::WorkPlane_WorkPlaneMetaData>()},
  }}, {{
    "\34\0\0\0\0\0\0\0\0\0\0\14\0\0\0\0"
    "open_vector_format.WorkPlane"
    "machine_type"
  }},
};

::uint8_t* WorkPlane::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:open_vector_format.WorkPlane)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .open_vector_format.VectorBlock vector_blocks = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_vector_blocks_size()); i < n; i++) {
    const auto& repfield = this->_internal_vector_blocks().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // float x_pos_in_mm = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x_pos_in_mm = this->_internal_x_pos_in_mm();
  ::uint32_t raw_x_pos_in_mm;
  memcpy(&raw_x_pos_in_mm, &tmp_x_pos_in_mm, sizeof(tmp_x_pos_in_mm));
  if (raw_x_pos_in_mm != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_x_pos_in_mm(), target);
  }

  // float y_pos_in_mm = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y_pos_in_mm = this->_internal_y_pos_in_mm();
  ::uint32_t raw_y_pos_in_mm;
  memcpy(&raw_y_pos_in_mm, &tmp_y_pos_in_mm, sizeof(tmp_y_pos_in_mm));
  if (raw_y_pos_in_mm != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_y_pos_in_mm(), target);
  }

  // float z_pos_in_mm = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_z_pos_in_mm = this->_internal_z_pos_in_mm();
  ::uint32_t raw_z_pos_in_mm;
  memcpy(&raw_z_pos_in_mm, &tmp_z_pos_in_mm, sizeof(tmp_z_pos_in_mm));
  if (raw_z_pos_in_mm != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_z_pos_in_mm(), target);
  }

  // float x_rot_in_deg = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x_rot_in_deg = this->_internal_x_rot_in_deg();
  ::uint32_t raw_x_rot_in_deg;
  memcpy(&raw_x_rot_in_deg, &tmp_x_rot_in_deg, sizeof(tmp_x_rot_in_deg));
  if (raw_x_rot_in_deg != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_x_rot_in_deg(), target);
  }

  // float y_rot_in_deg = 6;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y_rot_in_deg = this->_internal_y_rot_in_deg();
  ::uint32_t raw_y_rot_in_deg;
  memcpy(&raw_y_rot_in_deg, &tmp_y_rot_in_deg, sizeof(tmp_y_rot_in_deg));
  if (raw_y_rot_in_deg != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        6, this->_internal_y_rot_in_deg(), target);
  }

  // float z_rot_in_deg = 7;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_z_rot_in_deg = this->_internal_z_rot_in_deg();
  ::uint32_t raw_z_rot_in_deg;
  memcpy(&raw_z_rot_in_deg, &tmp_z_rot_in_deg, sizeof(tmp_z_rot_in_deg));
  if (raw_z_rot_in_deg != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        7, this->_internal_z_rot_in_deg(), target);
  }

  // int32 num_blocks = 8;
  if (this->_internal_num_blocks() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<8>(
            stream, this->_internal_num_blocks(), target);
  }

  // uint32 repeats = 9;
  if (this->_internal_repeats() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        9, this->_internal_repeats(), target);
  }

  // int32 work_plane_number = 10;
  if (this->_internal_work_plane_number() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<10>(
            stream, this->_internal_work_plane_number(), target);
  }

  // string machine_type = 11;
  if (!this->_internal_machine_type().empty()) {
    const std::string& _s = this->_internal_machine_type();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "open_vector_format.WorkPlane.machine_type");
    target = stream->WriteStringMaybeAliased(11, _s, target);
  }

  // repeated float additional_axis_positions = 12;
  if (this->_internal_additional_axis_positions_size() > 0) {
    target = stream->WriteFixedPacked(12, _internal_additional_axis_positions(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .open_vector_format.WorkPlane.WorkPlaneMetaData meta_data = 13;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::meta_data(this),
        _Internal::meta_data(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:open_vector_format.WorkPlane)
  return target;
}

::size_t WorkPlane::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:open_vector_format.WorkPlane)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .open_vector_format.VectorBlock vector_blocks = 1;
  total_size += 1UL * this->_internal_vector_blocks_size();
  for (const auto& msg : this->_internal_vector_blocks()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated float additional_axis_positions = 12;
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_additional_axis_positions_size())
    ;
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // string machine_type = 11;
  if (!this->_internal_machine_type().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_machine_type());
  }

  // .open_vector_format.WorkPlane.WorkPlaneMetaData meta_data = 13;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *_impl_.meta_data_);
  }

  // float x_pos_in_mm = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x_pos_in_mm = this->_internal_x_pos_in_mm();
  ::uint32_t raw_x_pos_in_mm;
  memcpy(&raw_x_pos_in_mm, &tmp_x_pos_in_mm, sizeof(tmp_x_pos_in_mm));
  if (raw_x_pos_in_mm != 0) {
    total_size += 5;
  }

  // float y_pos_in_mm = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y_pos_in_mm = this->_internal_y_pos_in_mm();
  ::uint32_t raw_y_pos_in_mm;
  memcpy(&raw_y_pos_in_mm, &tmp_y_pos_in_mm, sizeof(tmp_y_pos_in_mm));
  if (raw_y_pos_in_mm != 0) {
    total_size += 5;
  }

  // float z_pos_in_mm = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_z_pos_in_mm = this->_internal_z_pos_in_mm();
  ::uint32_t raw_z_pos_in_mm;
  memcpy(&raw_z_pos_in_mm, &tmp_z_pos_in_mm, sizeof(tmp_z_pos_in_mm));
  if (raw_z_pos_in_mm != 0) {
    total_size += 5;
  }

  // float x_rot_in_deg = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x_rot_in_deg = this->_internal_x_rot_in_deg();
  ::uint32_t raw_x_rot_in_deg;
  memcpy(&raw_x_rot_in_deg, &tmp_x_rot_in_deg, sizeof(tmp_x_rot_in_deg));
  if (raw_x_rot_in_deg != 0) {
    total_size += 5;
  }

  // float y_rot_in_deg = 6;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y_rot_in_deg = this->_internal_y_rot_in_deg();
  ::uint32_t raw_y_rot_in_deg;
  memcpy(&raw_y_rot_in_deg, &tmp_y_rot_in_deg, sizeof(tmp_y_rot_in_deg));
  if (raw_y_rot_in_deg != 0) {
    total_size += 5;
  }

  // float z_rot_in_deg = 7;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_z_rot_in_deg = this->_internal_z_rot_in_deg();
  ::uint32_t raw_z_rot_in_deg;
  memcpy(&raw_z_rot_in_deg, &tmp_z_rot_in_deg, sizeof(tmp_z_rot_in_deg));
  if (raw_z_rot_in_deg != 0) {
    total_size += 5;
  }

  // int32 num_blocks = 8;
  if (this->_internal_num_blocks() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_num_blocks());
  }

  // uint32 repeats = 9;
  if (this->_internal_repeats() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_repeats());
  }

  // int32 work_plane_number = 10;
  if (this->_internal_work_plane_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_work_plane_number());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData WorkPlane::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    WorkPlane::MergeImpl
};
const ::google::protobuf::Message::ClassData*WorkPlane::GetClassData() const { return &_class_data_; }


void WorkPlane::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<WorkPlane*>(&to_msg);
  auto& from = static_cast<const WorkPlane&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:open_vector_format.WorkPlane)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_vector_blocks()->MergeFrom(from._internal_vector_blocks());
  _this->_internal_mutable_additional_axis_positions()->MergeFrom(from._internal_additional_axis_positions());
  if (!from._internal_machine_type().empty()) {
    _this->_internal_set_machine_type(from._internal_machine_type());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_meta_data()->::open_vector_format::WorkPlane_WorkPlaneMetaData::MergeFrom(
        from._internal_meta_data());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x_pos_in_mm = from._internal_x_pos_in_mm();
  ::uint32_t raw_x_pos_in_mm;
  memcpy(&raw_x_pos_in_mm, &tmp_x_pos_in_mm, sizeof(tmp_x_pos_in_mm));
  if (raw_x_pos_in_mm != 0) {
    _this->_internal_set_x_pos_in_mm(from._internal_x_pos_in_mm());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y_pos_in_mm = from._internal_y_pos_in_mm();
  ::uint32_t raw_y_pos_in_mm;
  memcpy(&raw_y_pos_in_mm, &tmp_y_pos_in_mm, sizeof(tmp_y_pos_in_mm));
  if (raw_y_pos_in_mm != 0) {
    _this->_internal_set_y_pos_in_mm(from._internal_y_pos_in_mm());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_z_pos_in_mm = from._internal_z_pos_in_mm();
  ::uint32_t raw_z_pos_in_mm;
  memcpy(&raw_z_pos_in_mm, &tmp_z_pos_in_mm, sizeof(tmp_z_pos_in_mm));
  if (raw_z_pos_in_mm != 0) {
    _this->_internal_set_z_pos_in_mm(from._internal_z_pos_in_mm());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x_rot_in_deg = from._internal_x_rot_in_deg();
  ::uint32_t raw_x_rot_in_deg;
  memcpy(&raw_x_rot_in_deg, &tmp_x_rot_in_deg, sizeof(tmp_x_rot_in_deg));
  if (raw_x_rot_in_deg != 0) {
    _this->_internal_set_x_rot_in_deg(from._internal_x_rot_in_deg());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y_rot_in_deg = from._internal_y_rot_in_deg();
  ::uint32_t raw_y_rot_in_deg;
  memcpy(&raw_y_rot_in_deg, &tmp_y_rot_in_deg, sizeof(tmp_y_rot_in_deg));
  if (raw_y_rot_in_deg != 0) {
    _this->_internal_set_y_rot_in_deg(from._internal_y_rot_in_deg());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_z_rot_in_deg = from._internal_z_rot_in_deg();
  ::uint32_t raw_z_rot_in_deg;
  memcpy(&raw_z_rot_in_deg, &tmp_z_rot_in_deg, sizeof(tmp_z_rot_in_deg));
  if (raw_z_rot_in_deg != 0) {
    _this->_internal_set_z_rot_in_deg(from._internal_z_rot_in_deg());
  }
  if (from._internal_num_blocks() != 0) {
    _this->_internal_set_num_blocks(from._internal_num_blocks());
  }
  if (from._internal_repeats() != 0) {
    _this->_internal_set_repeats(from._internal_repeats());
  }
  if (from._internal_work_plane_number() != 0) {
    _this->_internal_set_work_plane_number(from._internal_work_plane_number());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void WorkPlane::CopyFrom(const WorkPlane& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:open_vector_format.WorkPlane)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool WorkPlane::IsInitialized() const {
  return true;
}

void WorkPlane::InternalSwap(WorkPlane* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.vector_blocks_.InternalSwap(&other->_impl_.vector_blocks_);
  _impl_.additional_axis_positions_.InternalSwap(&other->_impl_.additional_axis_positions_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.machine_type_, lhs_arena,
                                       &other->_impl_.machine_type_, rhs_arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WorkPlane, _impl_.work_plane_number_)
      + sizeof(WorkPlane::_impl_.work_plane_number_)
      - PROTOBUF_FIELD_OFFSET(WorkPlane, _impl_.meta_data_)>(
          reinterpret_cast<char*>(&_impl_.meta_data_),
          reinterpret_cast<char*>(&other->_impl_.meta_data_));
}

::google::protobuf::Metadata WorkPlane::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_open_5fvector_5fformat_2eproto_getter, &descriptor_table_open_5fvector_5fformat_2eproto_once,
      file_level_metadata_open_5fvector_5fformat_2eproto[16]);
}
// ===================================================================

class VectorBlock_VectorBlockMetaData::_Internal {
 public:
  using HasBits = decltype(std::declval<VectorBlock_VectorBlockMetaData>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(VectorBlock_VectorBlockMetaData, _impl_._has_bits_);
  static const ::open_vector_format::AxisAlignedBox2D& bounds(const VectorBlock_VectorBlockMetaData* msg);
  static void set_has_bounds(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::open_vector_format::AxisAlignedBox2D& VectorBlock_VectorBlockMetaData::_Internal::bounds(const VectorBlock_VectorBlockMetaData* msg) {
  return *msg->_impl_.bounds_;
}
VectorBlock_VectorBlockMetaData::VectorBlock_VectorBlockMetaData(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:open_vector_format.VectorBlock.VectorBlockMetaData)
}
VectorBlock_VectorBlockMetaData::VectorBlock_VectorBlockMetaData(const VectorBlock_VectorBlockMetaData& from) : ::google::protobuf::Message() {
  VectorBlock_VectorBlockMetaData* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.bounds_){nullptr},
      decltype(_impl_.total_scan_distance_in_mm_){},
      decltype(_impl_.total_jump_distance_in_mm_){},
      decltype(_impl_.part_key_){},
      decltype(_impl_.patch_key_){},
      decltype(_impl_.contour_index_){},
      decltype(_impl_.display_color_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.bounds_ = new ::open_vector_format::AxisAlignedBox2D(*from._impl_.bounds_);
  }
  ::memcpy(&_impl_.total_scan_distance_in_mm_, &from._impl_.total_scan_distance_in_mm_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.display_color_) -
    reinterpret_cast<char*>(&_impl_.total_scan_distance_in_mm_)) + sizeof(_impl_.display_color_));

  // @@protoc_insertion_point(copy_constructor:open_vector_format.VectorBlock.VectorBlockMetaData)
}
inline void VectorBlock_VectorBlockMetaData::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.bounds_){nullptr},
      decltype(_impl_.total_scan_distance_in_mm_){0},
      decltype(_impl_.total_jump_distance_in_mm_){0},
      decltype(_impl_.part_key_){0},
      decltype(_impl_.patch_key_){0},
      decltype(_impl_.contour_index_){0},
      decltype(_impl_.display_color_){0},
  };
}
VectorBlock_VectorBlockMetaData::~VectorBlock_VectorBlockMetaData() {
  // @@protoc_insertion_point(destructor:open_vector_format.VectorBlock.VectorBlockMetaData)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void VectorBlock_VectorBlockMetaData::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.bounds_;
}
void VectorBlock_VectorBlockMetaData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void VectorBlock_VectorBlockMetaData::Clear() {
// @@protoc_insertion_point(message_clear_start:open_vector_format.VectorBlock.VectorBlockMetaData)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.bounds_ != nullptr);
    _impl_.bounds_->Clear();
  }
  ::memset(&_impl_.total_scan_distance_in_mm_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.display_color_) -
      reinterpret_cast<char*>(&_impl_.total_scan_distance_in_mm_)) + sizeof(_impl_.display_color_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* VectorBlock_VectorBlockMetaData::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 1, 0, 2> VectorBlock_VectorBlockMetaData::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(VectorBlock_VectorBlockMetaData, _impl_._has_bits_),
    0, // no _extensions_
    7, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_VectorBlock_VectorBlockMetaData_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // double total_scan_distance_in_mm = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_VectorBlockMetaData, _impl_.total_scan_distance_in_mm_)}},
    // double total_jump_distance_in_mm = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_VectorBlockMetaData, _impl_.total_jump_distance_in_mm_)}},
    // int32 part_key = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(VectorBlock_VectorBlockMetaData, _impl_.part_key_), 63>(),
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_VectorBlockMetaData, _impl_.part_key_)}},
    // int32 patch_key = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(VectorBlock_VectorBlockMetaData, _impl_.patch_key_), 63>(),
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_VectorBlockMetaData, _impl_.patch_key_)}},
    // int32 contour_index = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(VectorBlock_VectorBlockMetaData, _impl_.contour_index_), 63>(),
     {40, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_VectorBlockMetaData, _impl_.contour_index_)}},
    // .open_vector_format.AxisAlignedBox2D bounds = 6;
    {::_pbi::TcParser::FastMtS1,
     {50, 0, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_VectorBlockMetaData, _impl_.bounds_)}},
    // int32 display_color = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(VectorBlock_VectorBlockMetaData, _impl_.display_color_), 63>(),
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_VectorBlockMetaData, _impl_.display_color_)}},
  }}, {{
    65535, 65535
  }}, {{
    // double total_scan_distance_in_mm = 1;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_VectorBlockMetaData, _impl_.total_scan_distance_in_mm_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double total_jump_distance_in_mm = 2;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_VectorBlockMetaData, _impl_.total_jump_distance_in_mm_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // int32 part_key = 3;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_VectorBlockMetaData, _impl_.part_key_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // int32 patch_key = 4;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_VectorBlockMetaData, _impl_.patch_key_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // int32 contour_index = 5;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_VectorBlockMetaData, _impl_.contour_index_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // .open_vector_format.AxisAlignedBox2D bounds = 6;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_VectorBlockMetaData, _impl_.bounds_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // int32 display_color = 7;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_VectorBlockMetaData, _impl_.display_color_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
  }}, {{
    {::_pbi::TcParser::GetTable<::open_vector_format::AxisAlignedBox2D>()},
  }}, {{
  }},
};

::uint8_t* VectorBlock_VectorBlockMetaData::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:open_vector_format.VectorBlock.VectorBlockMetaData)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double total_scan_distance_in_mm = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_total_scan_distance_in_mm = this->_internal_total_scan_distance_in_mm();
  ::uint64_t raw_total_scan_distance_in_mm;
  memcpy(&raw_total_scan_distance_in_mm, &tmp_total_scan_distance_in_mm, sizeof(tmp_total_scan_distance_in_mm));
  if (raw_total_scan_distance_in_mm != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_total_scan_distance_in_mm(), target);
  }

  // double total_jump_distance_in_mm = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_total_jump_distance_in_mm = this->_internal_total_jump_distance_in_mm();
  ::uint64_t raw_total_jump_distance_in_mm;
  memcpy(&raw_total_jump_distance_in_mm, &tmp_total_jump_distance_in_mm, sizeof(tmp_total_jump_distance_in_mm));
  if (raw_total_jump_distance_in_mm != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_total_jump_distance_in_mm(), target);
  }

  // int32 part_key = 3;
  if (this->_internal_part_key() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<3>(
            stream, this->_internal_part_key(), target);
  }

  // int32 patch_key = 4;
  if (this->_internal_patch_key() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<4>(
            stream, this->_internal_patch_key(), target);
  }

  // int32 contour_index = 5;
  if (this->_internal_contour_index() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<5>(
            stream, this->_internal_contour_index(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .open_vector_format.AxisAlignedBox2D bounds = 6;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::bounds(this),
        _Internal::bounds(this).GetCachedSize(), target, stream);
  }

  // int32 display_color = 7;
  if (this->_internal_display_color() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<7>(
            stream, this->_internal_display_color(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:open_vector_format.VectorBlock.VectorBlockMetaData)
  return target;
}

::size_t VectorBlock_VectorBlockMetaData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:open_vector_format.VectorBlock.VectorBlockMetaData)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .open_vector_format.AxisAlignedBox2D bounds = 6;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *_impl_.bounds_);
  }

  // double total_scan_distance_in_mm = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_total_scan_distance_in_mm = this->_internal_total_scan_distance_in_mm();
  ::uint64_t raw_total_scan_distance_in_mm;
  memcpy(&raw_total_scan_distance_in_mm, &tmp_total_scan_distance_in_mm, sizeof(tmp_total_scan_distance_in_mm));
  if (raw_total_scan_distance_in_mm != 0) {
    total_size += 9;
  }

  // double total_jump_distance_in_mm = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_total_jump_distance_in_mm = this->_internal_total_jump_distance_in_mm();
  ::uint64_t raw_total_jump_distance_in_mm;
  memcpy(&raw_total_jump_distance_in_mm, &tmp_total_jump_distance_in_mm, sizeof(tmp_total_jump_distance_in_mm));
  if (raw_total_jump_distance_in_mm != 0) {
    total_size += 9;
  }

  // int32 part_key = 3;
  if (this->_internal_part_key() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_part_key());
  }

  // int32 patch_key = 4;
  if (this->_internal_patch_key() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_patch_key());
  }

  // int32 contour_index = 5;
  if (this->_internal_contour_index() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_contour_index());
  }

  // int32 display_color = 7;
  if (this->_internal_display_color() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_display_color());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData VectorBlock_VectorBlockMetaData::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    VectorBlock_VectorBlockMetaData::MergeImpl
};
const ::google::protobuf::Message::ClassData*VectorBlock_VectorBlockMetaData::GetClassData() const { return &_class_data_; }


void VectorBlock_VectorBlockMetaData::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<VectorBlock_VectorBlockMetaData*>(&to_msg);
  auto& from = static_cast<const VectorBlock_VectorBlockMetaData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:open_vector_format.VectorBlock.VectorBlockMetaData)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_bounds()->::open_vector_format::AxisAlignedBox2D::MergeFrom(
        from._internal_bounds());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_total_scan_distance_in_mm = from._internal_total_scan_distance_in_mm();
  ::uint64_t raw_total_scan_distance_in_mm;
  memcpy(&raw_total_scan_distance_in_mm, &tmp_total_scan_distance_in_mm, sizeof(tmp_total_scan_distance_in_mm));
  if (raw_total_scan_distance_in_mm != 0) {
    _this->_internal_set_total_scan_distance_in_mm(from._internal_total_scan_distance_in_mm());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_total_jump_distance_in_mm = from._internal_total_jump_distance_in_mm();
  ::uint64_t raw_total_jump_distance_in_mm;
  memcpy(&raw_total_jump_distance_in_mm, &tmp_total_jump_distance_in_mm, sizeof(tmp_total_jump_distance_in_mm));
  if (raw_total_jump_distance_in_mm != 0) {
    _this->_internal_set_total_jump_distance_in_mm(from._internal_total_jump_distance_in_mm());
  }
  if (from._internal_part_key() != 0) {
    _this->_internal_set_part_key(from._internal_part_key());
  }
  if (from._internal_patch_key() != 0) {
    _this->_internal_set_patch_key(from._internal_patch_key());
  }
  if (from._internal_contour_index() != 0) {
    _this->_internal_set_contour_index(from._internal_contour_index());
  }
  if (from._internal_display_color() != 0) {
    _this->_internal_set_display_color(from._internal_display_color());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void VectorBlock_VectorBlockMetaData::CopyFrom(const VectorBlock_VectorBlockMetaData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:open_vector_format.VectorBlock.VectorBlockMetaData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool VectorBlock_VectorBlockMetaData::IsInitialized() const {
  return true;
}

void VectorBlock_VectorBlockMetaData::InternalSwap(VectorBlock_VectorBlockMetaData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VectorBlock_VectorBlockMetaData, _impl_.display_color_)
      + sizeof(VectorBlock_VectorBlockMetaData::_impl_.display_color_)
      - PROTOBUF_FIELD_OFFSET(VectorBlock_VectorBlockMetaData, _impl_.bounds_)>(
          reinterpret_cast<char*>(&_impl_.bounds_),
          reinterpret_cast<char*>(&other->_impl_.bounds_));
}

::google::protobuf::Metadata VectorBlock_VectorBlockMetaData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_open_5fvector_5fformat_2eproto_getter, &descriptor_table_open_5fvector_5fformat_2eproto_once,
      file_level_metadata_open_5fvector_5fformat_2eproto[17]);
}
// ===================================================================

class VectorBlock_LPBFMetadata::_Internal {
 public:
};

VectorBlock_LPBFMetadata::VectorBlock_LPBFMetadata(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:open_vector_format.VectorBlock.LPBFMetadata)
}
VectorBlock_LPBFMetadata::VectorBlock_LPBFMetadata(const VectorBlock_LPBFMetadata& from)
    : ::google::protobuf::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:open_vector_format.VectorBlock.LPBFMetadata)
}
inline void VectorBlock_LPBFMetadata::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.part_area_){0},
      decltype(_impl_.skin_type_){0},
      decltype(_impl_.skin_core_strategy_area_){0},
      decltype(_impl_.structure_type_){0},
      decltype(_impl_.reexposure_){false},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
VectorBlock_LPBFMetadata::~VectorBlock_LPBFMetadata() {
  // @@protoc_insertion_point(destructor:open_vector_format.VectorBlock.LPBFMetadata)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void VectorBlock_LPBFMetadata::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}
void VectorBlock_LPBFMetadata::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void VectorBlock_LPBFMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:open_vector_format.VectorBlock.LPBFMetadata)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.part_area_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.reexposure_) -
      reinterpret_cast<char*>(&_impl_.part_area_)) + sizeof(_impl_.reexposure_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* VectorBlock_LPBFMetadata::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 0, 0, 2> VectorBlock_LPBFMetadata::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_VectorBlock_LPBFMetadata_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .open_vector_format.VectorBlock.PartArea part_area = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(VectorBlock_LPBFMetadata, _impl_.part_area_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_LPBFMetadata, _impl_.part_area_)}},
    // .open_vector_format.VectorBlock.LPBFMetadata.SkinType skin_type = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(VectorBlock_LPBFMetadata, _impl_.skin_type_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_LPBFMetadata, _impl_.skin_type_)}},
    // .open_vector_format.VectorBlock.LPBFMetadata.SkinCoreStrategyArea skin_core_strategy_area = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(VectorBlock_LPBFMetadata, _impl_.skin_core_strategy_area_), 63>(),
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_LPBFMetadata, _impl_.skin_core_strategy_area_)}},
    // .open_vector_format.VectorBlock.StructureType structure_type = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(VectorBlock_LPBFMetadata, _impl_.structure_type_), 63>(),
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_LPBFMetadata, _impl_.structure_type_)}},
    // bool reexposure = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(VectorBlock_LPBFMetadata, _impl_.reexposure_), 63>(),
     {40, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_LPBFMetadata, _impl_.reexposure_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // .open_vector_format.VectorBlock.PartArea part_area = 1;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_LPBFMetadata, _impl_.part_area_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .open_vector_format.VectorBlock.LPBFMetadata.SkinType skin_type = 2;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_LPBFMetadata, _impl_.skin_type_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .open_vector_format.VectorBlock.LPBFMetadata.SkinCoreStrategyArea skin_core_strategy_area = 3;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_LPBFMetadata, _impl_.skin_core_strategy_area_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .open_vector_format.VectorBlock.StructureType structure_type = 4;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_LPBFMetadata, _impl_.structure_type_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // bool reexposure = 5;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_LPBFMetadata, _impl_.reexposure_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* VectorBlock_LPBFMetadata::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:open_vector_format.VectorBlock.LPBFMetadata)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // .open_vector_format.VectorBlock.PartArea part_area = 1;
  if (this->_internal_part_area() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_part_area(), target);
  }

  // .open_vector_format.VectorBlock.LPBFMetadata.SkinType skin_type = 2;
  if (this->_internal_skin_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_skin_type(), target);
  }

  // .open_vector_format.VectorBlock.LPBFMetadata.SkinCoreStrategyArea skin_core_strategy_area = 3;
  if (this->_internal_skin_core_strategy_area() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        3, this->_internal_skin_core_strategy_area(), target);
  }

  // .open_vector_format.VectorBlock.StructureType structure_type = 4;
  if (this->_internal_structure_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_structure_type(), target);
  }

  // bool reexposure = 5;
  if (this->_internal_reexposure() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this->_internal_reexposure(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:open_vector_format.VectorBlock.LPBFMetadata)
  return target;
}

::size_t VectorBlock_LPBFMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:open_vector_format.VectorBlock.LPBFMetadata)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .open_vector_format.VectorBlock.PartArea part_area = 1;
  if (this->_internal_part_area() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_part_area());
  }

  // .open_vector_format.VectorBlock.LPBFMetadata.SkinType skin_type = 2;
  if (this->_internal_skin_type() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_skin_type());
  }

  // .open_vector_format.VectorBlock.LPBFMetadata.SkinCoreStrategyArea skin_core_strategy_area = 3;
  if (this->_internal_skin_core_strategy_area() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_skin_core_strategy_area());
  }

  // .open_vector_format.VectorBlock.StructureType structure_type = 4;
  if (this->_internal_structure_type() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_structure_type());
  }

  // bool reexposure = 5;
  if (this->_internal_reexposure() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData VectorBlock_LPBFMetadata::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    VectorBlock_LPBFMetadata::MergeImpl
};
const ::google::protobuf::Message::ClassData*VectorBlock_LPBFMetadata::GetClassData() const { return &_class_data_; }


void VectorBlock_LPBFMetadata::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<VectorBlock_LPBFMetadata*>(&to_msg);
  auto& from = static_cast<const VectorBlock_LPBFMetadata&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:open_vector_format.VectorBlock.LPBFMetadata)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_part_area() != 0) {
    _this->_internal_set_part_area(from._internal_part_area());
  }
  if (from._internal_skin_type() != 0) {
    _this->_internal_set_skin_type(from._internal_skin_type());
  }
  if (from._internal_skin_core_strategy_area() != 0) {
    _this->_internal_set_skin_core_strategy_area(from._internal_skin_core_strategy_area());
  }
  if (from._internal_structure_type() != 0) {
    _this->_internal_set_structure_type(from._internal_structure_type());
  }
  if (from._internal_reexposure() != 0) {
    _this->_internal_set_reexposure(from._internal_reexposure());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void VectorBlock_LPBFMetadata::CopyFrom(const VectorBlock_LPBFMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:open_vector_format.VectorBlock.LPBFMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool VectorBlock_LPBFMetadata::IsInitialized() const {
  return true;
}

void VectorBlock_LPBFMetadata::InternalSwap(VectorBlock_LPBFMetadata* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VectorBlock_LPBFMetadata, _impl_.reexposure_)
      + sizeof(VectorBlock_LPBFMetadata::_impl_.reexposure_)
      - PROTOBUF_FIELD_OFFSET(VectorBlock_LPBFMetadata, _impl_.part_area_)>(
          reinterpret_cast<char*>(&_impl_.part_area_),
          reinterpret_cast<char*>(&other->_impl_.part_area_));
}

::google::protobuf::Metadata VectorBlock_LPBFMetadata::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_open_5fvector_5fformat_2eproto_getter, &descriptor_table_open_5fvector_5fformat_2eproto_once,
      file_level_metadata_open_5fvector_5fformat_2eproto[18]);
}
// ===================================================================

class VectorBlock_MicroStructuringMetadata::_Internal {
 public:
};

VectorBlock_MicroStructuringMetadata::VectorBlock_MicroStructuringMetadata(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:open_vector_format.VectorBlock.MicroStructuringMetadata)
}
VectorBlock_MicroStructuringMetadata::VectorBlock_MicroStructuringMetadata(const VectorBlock_MicroStructuringMetadata& from)
    : ::google::protobuf::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:open_vector_format.VectorBlock.MicroStructuringMetadata)
}
inline void VectorBlock_MicroStructuringMetadata::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.part_area_){0},
      decltype(_impl_.structure_type_){0},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
VectorBlock_MicroStructuringMetadata::~VectorBlock_MicroStructuringMetadata() {
  // @@protoc_insertion_point(destructor:open_vector_format.VectorBlock.MicroStructuringMetadata)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void VectorBlock_MicroStructuringMetadata::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}
void VectorBlock_MicroStructuringMetadata::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void VectorBlock_MicroStructuringMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:open_vector_format.VectorBlock.MicroStructuringMetadata)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.part_area_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.structure_type_) -
      reinterpret_cast<char*>(&_impl_.part_area_)) + sizeof(_impl_.structure_type_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* VectorBlock_MicroStructuringMetadata::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> VectorBlock_MicroStructuringMetadata::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_VectorBlock_MicroStructuringMetadata_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // .open_vector_format.VectorBlock.StructureType structure_type = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(VectorBlock_MicroStructuringMetadata, _impl_.structure_type_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_MicroStructuringMetadata, _impl_.structure_type_)}},
    // .open_vector_format.VectorBlock.PartArea part_area = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(VectorBlock_MicroStructuringMetadata, _impl_.part_area_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_MicroStructuringMetadata, _impl_.part_area_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .open_vector_format.VectorBlock.PartArea part_area = 1;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_MicroStructuringMetadata, _impl_.part_area_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .open_vector_format.VectorBlock.StructureType structure_type = 2;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_MicroStructuringMetadata, _impl_.structure_type_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* VectorBlock_MicroStructuringMetadata::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:open_vector_format.VectorBlock.MicroStructuringMetadata)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // .open_vector_format.VectorBlock.PartArea part_area = 1;
  if (this->_internal_part_area() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_part_area(), target);
  }

  // .open_vector_format.VectorBlock.StructureType structure_type = 2;
  if (this->_internal_structure_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_structure_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:open_vector_format.VectorBlock.MicroStructuringMetadata)
  return target;
}

::size_t VectorBlock_MicroStructuringMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:open_vector_format.VectorBlock.MicroStructuringMetadata)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .open_vector_format.VectorBlock.PartArea part_area = 1;
  if (this->_internal_part_area() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_part_area());
  }

  // .open_vector_format.VectorBlock.StructureType structure_type = 2;
  if (this->_internal_structure_type() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_structure_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData VectorBlock_MicroStructuringMetadata::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    VectorBlock_MicroStructuringMetadata::MergeImpl
};
const ::google::protobuf::Message::ClassData*VectorBlock_MicroStructuringMetadata::GetClassData() const { return &_class_data_; }


void VectorBlock_MicroStructuringMetadata::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<VectorBlock_MicroStructuringMetadata*>(&to_msg);
  auto& from = static_cast<const VectorBlock_MicroStructuringMetadata&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:open_vector_format.VectorBlock.MicroStructuringMetadata)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_part_area() != 0) {
    _this->_internal_set_part_area(from._internal_part_area());
  }
  if (from._internal_structure_type() != 0) {
    _this->_internal_set_structure_type(from._internal_structure_type());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void VectorBlock_MicroStructuringMetadata::CopyFrom(const VectorBlock_MicroStructuringMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:open_vector_format.VectorBlock.MicroStructuringMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool VectorBlock_MicroStructuringMetadata::IsInitialized() const {
  return true;
}

void VectorBlock_MicroStructuringMetadata::InternalSwap(VectorBlock_MicroStructuringMetadata* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VectorBlock_MicroStructuringMetadata, _impl_.structure_type_)
      + sizeof(VectorBlock_MicroStructuringMetadata::_impl_.structure_type_)
      - PROTOBUF_FIELD_OFFSET(VectorBlock_MicroStructuringMetadata, _impl_.part_area_)>(
          reinterpret_cast<char*>(&_impl_.part_area_),
          reinterpret_cast<char*>(&other->_impl_.part_area_));
}

::google::protobuf::Metadata VectorBlock_MicroStructuringMetadata::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_open_5fvector_5fformat_2eproto_getter, &descriptor_table_open_5fvector_5fformat_2eproto_once,
      file_level_metadata_open_5fvector_5fformat_2eproto[19]);
}
// ===================================================================

class VectorBlock_PolishingMetadata::_Internal {
 public:
};

VectorBlock_PolishingMetadata::VectorBlock_PolishingMetadata(::google::protobuf::Arena* arena)
    : ::google::protobuf::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:open_vector_format.VectorBlock.PolishingMetadata)
}
VectorBlock_PolishingMetadata::VectorBlock_PolishingMetadata(const VectorBlock_PolishingMetadata& from) : ::google::protobuf::internal::ZeroFieldsBase() {
  VectorBlock_PolishingMetadata* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);

  // @@protoc_insertion_point(copy_constructor:open_vector_format.VectorBlock.PolishingMetadata)
}




const ::google::protobuf::Message::ClassData VectorBlock_PolishingMetadata::_class_data_ = {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl,
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl,
};
const ::google::protobuf::Message::ClassData*VectorBlock_PolishingMetadata::GetClassData() const { return &_class_data_; }







::google::protobuf::Metadata VectorBlock_PolishingMetadata::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_open_5fvector_5fformat_2eproto_getter, &descriptor_table_open_5fvector_5fformat_2eproto_once,
      file_level_metadata_open_5fvector_5fformat_2eproto[20]);
}
// ===================================================================

class VectorBlock_LineSequence::_Internal {
 public:
};

VectorBlock_LineSequence::VectorBlock_LineSequence(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:open_vector_format.VectorBlock.LineSequence)
}
VectorBlock_LineSequence::VectorBlock_LineSequence(const VectorBlock_LineSequence& from) : ::google::protobuf::Message() {
  VectorBlock_LineSequence* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.points_){from._impl_.points_},
      /*decltype(_impl_._cached_size_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);

  // @@protoc_insertion_point(copy_constructor:open_vector_format.VectorBlock.LineSequence)
}
inline void VectorBlock_LineSequence::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.points_){arena},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
VectorBlock_LineSequence::~VectorBlock_LineSequence() {
  // @@protoc_insertion_point(destructor:open_vector_format.VectorBlock.LineSequence)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void VectorBlock_LineSequence::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.points_.~RepeatedField();
}
void VectorBlock_LineSequence::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void VectorBlock_LineSequence::Clear() {
// @@protoc_insertion_point(message_clear_start:open_vector_format.VectorBlock.LineSequence)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_points()->Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* VectorBlock_LineSequence::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2> VectorBlock_LineSequence::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_VectorBlock_LineSequence_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // repeated float points = 1;
    {::_pbi::TcParser::FastF32P1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_LineSequence, _impl_.points_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated float points = 1;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_LineSequence, _impl_.points_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedFloat)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* VectorBlock_LineSequence::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:open_vector_format.VectorBlock.LineSequence)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated float points = 1;
  if (this->_internal_points_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_points(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:open_vector_format.VectorBlock.LineSequence)
  return target;
}

::size_t VectorBlock_LineSequence::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:open_vector_format.VectorBlock.LineSequence)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float points = 1;
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_points_size())
    ;
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData VectorBlock_LineSequence::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    VectorBlock_LineSequence::MergeImpl
};
const ::google::protobuf::Message::ClassData*VectorBlock_LineSequence::GetClassData() const { return &_class_data_; }


void VectorBlock_LineSequence::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<VectorBlock_LineSequence*>(&to_msg);
  auto& from = static_cast<const VectorBlock_LineSequence&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:open_vector_format.VectorBlock.LineSequence)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_points()->MergeFrom(from._internal_points());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void VectorBlock_LineSequence::CopyFrom(const VectorBlock_LineSequence& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:open_vector_format.VectorBlock.LineSequence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool VectorBlock_LineSequence::IsInitialized() const {
  return true;
}

void VectorBlock_LineSequence::InternalSwap(VectorBlock_LineSequence* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.points_.InternalSwap(&other->_impl_.points_);
}

::google::protobuf::Metadata VectorBlock_LineSequence::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_open_5fvector_5fformat_2eproto_getter, &descriptor_table_open_5fvector_5fformat_2eproto_once,
      file_level_metadata_open_5fvector_5fformat_2eproto[21]);
}
// ===================================================================

class VectorBlock_LineSequence3D::_Internal {
 public:
};

VectorBlock_LineSequence3D::VectorBlock_LineSequence3D(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:open_vector_format.VectorBlock.LineSequence3D)
}
VectorBlock_LineSequence3D::VectorBlock_LineSequence3D(const VectorBlock_LineSequence3D& from) : ::google::protobuf::Message() {
  VectorBlock_LineSequence3D* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.points_){from._impl_.points_},
      /*decltype(_impl_._cached_size_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);

  // @@protoc_insertion_point(copy_constructor:open_vector_format.VectorBlock.LineSequence3D)
}
inline void VectorBlock_LineSequence3D::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.points_){arena},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
VectorBlock_LineSequence3D::~VectorBlock_LineSequence3D() {
  // @@protoc_insertion_point(destructor:open_vector_format.VectorBlock.LineSequence3D)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void VectorBlock_LineSequence3D::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.points_.~RepeatedField();
}
void VectorBlock_LineSequence3D::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void VectorBlock_LineSequence3D::Clear() {
// @@protoc_insertion_point(message_clear_start:open_vector_format.VectorBlock.LineSequence3D)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_points()->Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* VectorBlock_LineSequence3D::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2> VectorBlock_LineSequence3D::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_VectorBlock_LineSequence3D_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // repeated float points = 1;
    {::_pbi::TcParser::FastF32P1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_LineSequence3D, _impl_.points_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated float points = 1;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_LineSequence3D, _impl_.points_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedFloat)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* VectorBlock_LineSequence3D::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:open_vector_format.VectorBlock.LineSequence3D)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated float points = 1;
  if (this->_internal_points_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_points(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:open_vector_format.VectorBlock.LineSequence3D)
  return target;
}

::size_t VectorBlock_LineSequence3D::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:open_vector_format.VectorBlock.LineSequence3D)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float points = 1;
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_points_size())
    ;
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData VectorBlock_LineSequence3D::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    VectorBlock_LineSequence3D::MergeImpl
};
const ::google::protobuf::Message::ClassData*VectorBlock_LineSequence3D::GetClassData() const { return &_class_data_; }


void VectorBlock_LineSequence3D::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<VectorBlock_LineSequence3D*>(&to_msg);
  auto& from = static_cast<const VectorBlock_LineSequence3D&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:open_vector_format.VectorBlock.LineSequence3D)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_points()->MergeFrom(from._internal_points());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void VectorBlock_LineSequence3D::CopyFrom(const VectorBlock_LineSequence3D& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:open_vector_format.VectorBlock.LineSequence3D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool VectorBlock_LineSequence3D::IsInitialized() const {
  return true;
}

void VectorBlock_LineSequence3D::InternalSwap(VectorBlock_LineSequence3D* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.points_.InternalSwap(&other->_impl_.points_);
}

::google::protobuf::Metadata VectorBlock_LineSequence3D::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_open_5fvector_5fformat_2eproto_getter, &descriptor_table_open_5fvector_5fformat_2eproto_once,
      file_level_metadata_open_5fvector_5fformat_2eproto[22]);
}
// ===================================================================

class VectorBlock_Hatches::_Internal {
 public:
};

VectorBlock_Hatches::VectorBlock_Hatches(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:open_vector_format.VectorBlock.Hatches)
}
VectorBlock_Hatches::VectorBlock_Hatches(const VectorBlock_Hatches& from) : ::google::protobuf::Message() {
  VectorBlock_Hatches* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.points_){from._impl_.points_},
      /*decltype(_impl_._cached_size_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);

  // @@protoc_insertion_point(copy_constructor:open_vector_format.VectorBlock.Hatches)
}
inline void VectorBlock_Hatches::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.points_){arena},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
VectorBlock_Hatches::~VectorBlock_Hatches() {
  // @@protoc_insertion_point(destructor:open_vector_format.VectorBlock.Hatches)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void VectorBlock_Hatches::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.points_.~RepeatedField();
}
void VectorBlock_Hatches::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void VectorBlock_Hatches::Clear() {
// @@protoc_insertion_point(message_clear_start:open_vector_format.VectorBlock.Hatches)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_points()->Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* VectorBlock_Hatches::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2> VectorBlock_Hatches::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_VectorBlock_Hatches_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // repeated float points = 1;
    {::_pbi::TcParser::FastF32P1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_Hatches, _impl_.points_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated float points = 1;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_Hatches, _impl_.points_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedFloat)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* VectorBlock_Hatches::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:open_vector_format.VectorBlock.Hatches)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated float points = 1;
  if (this->_internal_points_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_points(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:open_vector_format.VectorBlock.Hatches)
  return target;
}

::size_t VectorBlock_Hatches::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:open_vector_format.VectorBlock.Hatches)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float points = 1;
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_points_size())
    ;
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData VectorBlock_Hatches::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    VectorBlock_Hatches::MergeImpl
};
const ::google::protobuf::Message::ClassData*VectorBlock_Hatches::GetClassData() const { return &_class_data_; }


void VectorBlock_Hatches::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<VectorBlock_Hatches*>(&to_msg);
  auto& from = static_cast<const VectorBlock_Hatches&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:open_vector_format.VectorBlock.Hatches)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_points()->MergeFrom(from._internal_points());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void VectorBlock_Hatches::CopyFrom(const VectorBlock_Hatches& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:open_vector_format.VectorBlock.Hatches)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool VectorBlock_Hatches::IsInitialized() const {
  return true;
}

void VectorBlock_Hatches::InternalSwap(VectorBlock_Hatches* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.points_.InternalSwap(&other->_impl_.points_);
}

::google::protobuf::Metadata VectorBlock_Hatches::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_open_5fvector_5fformat_2eproto_getter, &descriptor_table_open_5fvector_5fformat_2eproto_once,
      file_level_metadata_open_5fvector_5fformat_2eproto[23]);
}
// ===================================================================

class VectorBlock_Hatches3D::_Internal {
 public:
};

VectorBlock_Hatches3D::VectorBlock_Hatches3D(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:open_vector_format.VectorBlock.Hatches3D)
}
VectorBlock_Hatches3D::VectorBlock_Hatches3D(const VectorBlock_Hatches3D& from) : ::google::protobuf::Message() {
  VectorBlock_Hatches3D* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.points_){from._impl_.points_},
      /*decltype(_impl_._cached_size_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);

  // @@protoc_insertion_point(copy_constructor:open_vector_format.VectorBlock.Hatches3D)
}
inline void VectorBlock_Hatches3D::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.points_){arena},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
VectorBlock_Hatches3D::~VectorBlock_Hatches3D() {
  // @@protoc_insertion_point(destructor:open_vector_format.VectorBlock.Hatches3D)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void VectorBlock_Hatches3D::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.points_.~RepeatedField();
}
void VectorBlock_Hatches3D::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void VectorBlock_Hatches3D::Clear() {
// @@protoc_insertion_point(message_clear_start:open_vector_format.VectorBlock.Hatches3D)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_points()->Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* VectorBlock_Hatches3D::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2> VectorBlock_Hatches3D::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_VectorBlock_Hatches3D_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // repeated float points = 1;
    {::_pbi::TcParser::FastF32P1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_Hatches3D, _impl_.points_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated float points = 1;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_Hatches3D, _impl_.points_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedFloat)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* VectorBlock_Hatches3D::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:open_vector_format.VectorBlock.Hatches3D)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated float points = 1;
  if (this->_internal_points_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_points(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:open_vector_format.VectorBlock.Hatches3D)
  return target;
}

::size_t VectorBlock_Hatches3D::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:open_vector_format.VectorBlock.Hatches3D)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float points = 1;
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_points_size())
    ;
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData VectorBlock_Hatches3D::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    VectorBlock_Hatches3D::MergeImpl
};
const ::google::protobuf::Message::ClassData*VectorBlock_Hatches3D::GetClassData() const { return &_class_data_; }


void VectorBlock_Hatches3D::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<VectorBlock_Hatches3D*>(&to_msg);
  auto& from = static_cast<const VectorBlock_Hatches3D&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:open_vector_format.VectorBlock.Hatches3D)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_points()->MergeFrom(from._internal_points());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void VectorBlock_Hatches3D::CopyFrom(const VectorBlock_Hatches3D& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:open_vector_format.VectorBlock.Hatches3D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool VectorBlock_Hatches3D::IsInitialized() const {
  return true;
}

void VectorBlock_Hatches3D::InternalSwap(VectorBlock_Hatches3D* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.points_.InternalSwap(&other->_impl_.points_);
}

::google::protobuf::Metadata VectorBlock_Hatches3D::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_open_5fvector_5fformat_2eproto_getter, &descriptor_table_open_5fvector_5fformat_2eproto_once,
      file_level_metadata_open_5fvector_5fformat_2eproto[24]);
}
// ===================================================================

class VectorBlock_PointSequence::_Internal {
 public:
};

VectorBlock_PointSequence::VectorBlock_PointSequence(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:open_vector_format.VectorBlock.PointSequence)
}
VectorBlock_PointSequence::VectorBlock_PointSequence(const VectorBlock_PointSequence& from) : ::google::protobuf::Message() {
  VectorBlock_PointSequence* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.points_){from._impl_.points_},
      /*decltype(_impl_._cached_size_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);

  // @@protoc_insertion_point(copy_constructor:open_vector_format.VectorBlock.PointSequence)
}
inline void VectorBlock_PointSequence::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.points_){arena},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
VectorBlock_PointSequence::~VectorBlock_PointSequence() {
  // @@protoc_insertion_point(destructor:open_vector_format.VectorBlock.PointSequence)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void VectorBlock_PointSequence::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.points_.~RepeatedField();
}
void VectorBlock_PointSequence::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void VectorBlock_PointSequence::Clear() {
// @@protoc_insertion_point(message_clear_start:open_vector_format.VectorBlock.PointSequence)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_points()->Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* VectorBlock_PointSequence::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2> VectorBlock_PointSequence::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_VectorBlock_PointSequence_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // repeated float points = 1;
    {::_pbi::TcParser::FastF32P1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_PointSequence, _impl_.points_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated float points = 1;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_PointSequence, _impl_.points_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedFloat)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* VectorBlock_PointSequence::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:open_vector_format.VectorBlock.PointSequence)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated float points = 1;
  if (this->_internal_points_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_points(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:open_vector_format.VectorBlock.PointSequence)
  return target;
}

::size_t VectorBlock_PointSequence::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:open_vector_format.VectorBlock.PointSequence)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float points = 1;
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_points_size())
    ;
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData VectorBlock_PointSequence::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    VectorBlock_PointSequence::MergeImpl
};
const ::google::protobuf::Message::ClassData*VectorBlock_PointSequence::GetClassData() const { return &_class_data_; }


void VectorBlock_PointSequence::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<VectorBlock_PointSequence*>(&to_msg);
  auto& from = static_cast<const VectorBlock_PointSequence&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:open_vector_format.VectorBlock.PointSequence)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_points()->MergeFrom(from._internal_points());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void VectorBlock_PointSequence::CopyFrom(const VectorBlock_PointSequence& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:open_vector_format.VectorBlock.PointSequence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool VectorBlock_PointSequence::IsInitialized() const {
  return true;
}

void VectorBlock_PointSequence::InternalSwap(VectorBlock_PointSequence* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.points_.InternalSwap(&other->_impl_.points_);
}

::google::protobuf::Metadata VectorBlock_PointSequence::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_open_5fvector_5fformat_2eproto_getter, &descriptor_table_open_5fvector_5fformat_2eproto_once,
      file_level_metadata_open_5fvector_5fformat_2eproto[25]);
}
// ===================================================================

class VectorBlock_PointSequence3D::_Internal {
 public:
};

VectorBlock_PointSequence3D::VectorBlock_PointSequence3D(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:open_vector_format.VectorBlock.PointSequence3D)
}
VectorBlock_PointSequence3D::VectorBlock_PointSequence3D(const VectorBlock_PointSequence3D& from) : ::google::protobuf::Message() {
  VectorBlock_PointSequence3D* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.points_){from._impl_.points_},
      /*decltype(_impl_._cached_size_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);

  // @@protoc_insertion_point(copy_constructor:open_vector_format.VectorBlock.PointSequence3D)
}
inline void VectorBlock_PointSequence3D::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.points_){arena},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
VectorBlock_PointSequence3D::~VectorBlock_PointSequence3D() {
  // @@protoc_insertion_point(destructor:open_vector_format.VectorBlock.PointSequence3D)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void VectorBlock_PointSequence3D::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.points_.~RepeatedField();
}
void VectorBlock_PointSequence3D::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void VectorBlock_PointSequence3D::Clear() {
// @@protoc_insertion_point(message_clear_start:open_vector_format.VectorBlock.PointSequence3D)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_points()->Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* VectorBlock_PointSequence3D::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2> VectorBlock_PointSequence3D::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_VectorBlock_PointSequence3D_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // repeated float points = 1;
    {::_pbi::TcParser::FastF32P1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_PointSequence3D, _impl_.points_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated float points = 1;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_PointSequence3D, _impl_.points_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedFloat)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* VectorBlock_PointSequence3D::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:open_vector_format.VectorBlock.PointSequence3D)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated float points = 1;
  if (this->_internal_points_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_points(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:open_vector_format.VectorBlock.PointSequence3D)
  return target;
}

::size_t VectorBlock_PointSequence3D::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:open_vector_format.VectorBlock.PointSequence3D)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float points = 1;
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_points_size())
    ;
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData VectorBlock_PointSequence3D::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    VectorBlock_PointSequence3D::MergeImpl
};
const ::google::protobuf::Message::ClassData*VectorBlock_PointSequence3D::GetClassData() const { return &_class_data_; }


void VectorBlock_PointSequence3D::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<VectorBlock_PointSequence3D*>(&to_msg);
  auto& from = static_cast<const VectorBlock_PointSequence3D&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:open_vector_format.VectorBlock.PointSequence3D)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_points()->MergeFrom(from._internal_points());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void VectorBlock_PointSequence3D::CopyFrom(const VectorBlock_PointSequence3D& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:open_vector_format.VectorBlock.PointSequence3D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool VectorBlock_PointSequence3D::IsInitialized() const {
  return true;
}

void VectorBlock_PointSequence3D::InternalSwap(VectorBlock_PointSequence3D* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.points_.InternalSwap(&other->_impl_.points_);
}

::google::protobuf::Metadata VectorBlock_PointSequence3D::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_open_5fvector_5fformat_2eproto_getter, &descriptor_table_open_5fvector_5fformat_2eproto_once,
      file_level_metadata_open_5fvector_5fformat_2eproto[26]);
}
// ===================================================================

class VectorBlock_Arcs::_Internal {
 public:
};

VectorBlock_Arcs::VectorBlock_Arcs(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:open_vector_format.VectorBlock.Arcs)
}
VectorBlock_Arcs::VectorBlock_Arcs(const VectorBlock_Arcs& from) : ::google::protobuf::Message() {
  VectorBlock_Arcs* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.centers_){from._impl_.centers_},
      decltype(_impl_.angle_){},
      decltype(_impl_.start_dx_){},
      decltype(_impl_.start_dy_){},
      /*decltype(_impl_._cached_size_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  ::memcpy(&_impl_.angle_, &from._impl_.angle_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.start_dy_) -
    reinterpret_cast<char*>(&_impl_.angle_)) + sizeof(_impl_.start_dy_));

  // @@protoc_insertion_point(copy_constructor:open_vector_format.VectorBlock.Arcs)
}
inline void VectorBlock_Arcs::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.centers_){arena},
      decltype(_impl_.angle_){0},
      decltype(_impl_.start_dx_){0},
      decltype(_impl_.start_dy_){0},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
VectorBlock_Arcs::~VectorBlock_Arcs() {
  // @@protoc_insertion_point(destructor:open_vector_format.VectorBlock.Arcs)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void VectorBlock_Arcs::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.centers_.~RepeatedField();
}
void VectorBlock_Arcs::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void VectorBlock_Arcs::Clear() {
// @@protoc_insertion_point(message_clear_start:open_vector_format.VectorBlock.Arcs)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_centers()->Clear();
  ::memset(&_impl_.angle_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.start_dy_) -
      reinterpret_cast<char*>(&_impl_.angle_)) + sizeof(_impl_.start_dy_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* VectorBlock_Arcs::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2> VectorBlock_Arcs::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_VectorBlock_Arcs_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // repeated float centers = 4;
    {::_pbi::TcParser::FastF32P1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_Arcs, _impl_.centers_)}},
    // double angle = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_Arcs, _impl_.angle_)}},
    // float start_dx = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_Arcs, _impl_.start_dx_)}},
    // float start_dy = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_Arcs, _impl_.start_dy_)}},
  }}, {{
    65535, 65535
  }}, {{
    // double angle = 1;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_Arcs, _impl_.angle_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // float start_dx = 2;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_Arcs, _impl_.start_dx_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float start_dy = 3;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_Arcs, _impl_.start_dy_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // repeated float centers = 4;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_Arcs, _impl_.centers_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedFloat)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* VectorBlock_Arcs::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:open_vector_format.VectorBlock.Arcs)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double angle = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_angle = this->_internal_angle();
  ::uint64_t raw_angle;
  memcpy(&raw_angle, &tmp_angle, sizeof(tmp_angle));
  if (raw_angle != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_angle(), target);
  }

  // float start_dx = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_start_dx = this->_internal_start_dx();
  ::uint32_t raw_start_dx;
  memcpy(&raw_start_dx, &tmp_start_dx, sizeof(tmp_start_dx));
  if (raw_start_dx != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_start_dx(), target);
  }

  // float start_dy = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_start_dy = this->_internal_start_dy();
  ::uint32_t raw_start_dy;
  memcpy(&raw_start_dy, &tmp_start_dy, sizeof(tmp_start_dy));
  if (raw_start_dy != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_start_dy(), target);
  }

  // repeated float centers = 4;
  if (this->_internal_centers_size() > 0) {
    target = stream->WriteFixedPacked(4, _internal_centers(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:open_vector_format.VectorBlock.Arcs)
  return target;
}

::size_t VectorBlock_Arcs::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:open_vector_format.VectorBlock.Arcs)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float centers = 4;
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_centers_size())
    ;
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // double angle = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_angle = this->_internal_angle();
  ::uint64_t raw_angle;
  memcpy(&raw_angle, &tmp_angle, sizeof(tmp_angle));
  if (raw_angle != 0) {
    total_size += 9;
  }

  // float start_dx = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_start_dx = this->_internal_start_dx();
  ::uint32_t raw_start_dx;
  memcpy(&raw_start_dx, &tmp_start_dx, sizeof(tmp_start_dx));
  if (raw_start_dx != 0) {
    total_size += 5;
  }

  // float start_dy = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_start_dy = this->_internal_start_dy();
  ::uint32_t raw_start_dy;
  memcpy(&raw_start_dy, &tmp_start_dy, sizeof(tmp_start_dy));
  if (raw_start_dy != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData VectorBlock_Arcs::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    VectorBlock_Arcs::MergeImpl
};
const ::google::protobuf::Message::ClassData*VectorBlock_Arcs::GetClassData() const { return &_class_data_; }


void VectorBlock_Arcs::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<VectorBlock_Arcs*>(&to_msg);
  auto& from = static_cast<const VectorBlock_Arcs&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:open_vector_format.VectorBlock.Arcs)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_centers()->MergeFrom(from._internal_centers());
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_angle = from._internal_angle();
  ::uint64_t raw_angle;
  memcpy(&raw_angle, &tmp_angle, sizeof(tmp_angle));
  if (raw_angle != 0) {
    _this->_internal_set_angle(from._internal_angle());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_start_dx = from._internal_start_dx();
  ::uint32_t raw_start_dx;
  memcpy(&raw_start_dx, &tmp_start_dx, sizeof(tmp_start_dx));
  if (raw_start_dx != 0) {
    _this->_internal_set_start_dx(from._internal_start_dx());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_start_dy = from._internal_start_dy();
  ::uint32_t raw_start_dy;
  memcpy(&raw_start_dy, &tmp_start_dy, sizeof(tmp_start_dy));
  if (raw_start_dy != 0) {
    _this->_internal_set_start_dy(from._internal_start_dy());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void VectorBlock_Arcs::CopyFrom(const VectorBlock_Arcs& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:open_vector_format.VectorBlock.Arcs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool VectorBlock_Arcs::IsInitialized() const {
  return true;
}

void VectorBlock_Arcs::InternalSwap(VectorBlock_Arcs* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.centers_.InternalSwap(&other->_impl_.centers_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VectorBlock_Arcs, _impl_.start_dy_)
      + sizeof(VectorBlock_Arcs::_impl_.start_dy_)
      - PROTOBUF_FIELD_OFFSET(VectorBlock_Arcs, _impl_.angle_)>(
          reinterpret_cast<char*>(&_impl_.angle_),
          reinterpret_cast<char*>(&other->_impl_.angle_));
}

::google::protobuf::Metadata VectorBlock_Arcs::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_open_5fvector_5fformat_2eproto_getter, &descriptor_table_open_5fvector_5fformat_2eproto_once,
      file_level_metadata_open_5fvector_5fformat_2eproto[27]);
}
// ===================================================================

class VectorBlock_Arcs3D::_Internal {
 public:
};

VectorBlock_Arcs3D::VectorBlock_Arcs3D(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:open_vector_format.VectorBlock.Arcs3D)
}
VectorBlock_Arcs3D::VectorBlock_Arcs3D(const VectorBlock_Arcs3D& from) : ::google::protobuf::Message() {
  VectorBlock_Arcs3D* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.centers_){from._impl_.centers_},
      decltype(_impl_.angle_){},
      decltype(_impl_.start_dx_){},
      decltype(_impl_.start_dy_){},
      decltype(_impl_.start_dz_){},
      /*decltype(_impl_._cached_size_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  ::memcpy(&_impl_.angle_, &from._impl_.angle_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.start_dz_) -
    reinterpret_cast<char*>(&_impl_.angle_)) + sizeof(_impl_.start_dz_));

  // @@protoc_insertion_point(copy_constructor:open_vector_format.VectorBlock.Arcs3D)
}
inline void VectorBlock_Arcs3D::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.centers_){arena},
      decltype(_impl_.angle_){0},
      decltype(_impl_.start_dx_){0},
      decltype(_impl_.start_dy_){0},
      decltype(_impl_.start_dz_){0},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
VectorBlock_Arcs3D::~VectorBlock_Arcs3D() {
  // @@protoc_insertion_point(destructor:open_vector_format.VectorBlock.Arcs3D)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void VectorBlock_Arcs3D::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.centers_.~RepeatedField();
}
void VectorBlock_Arcs3D::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void VectorBlock_Arcs3D::Clear() {
// @@protoc_insertion_point(message_clear_start:open_vector_format.VectorBlock.Arcs3D)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_centers()->Clear();
  ::memset(&_impl_.angle_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.start_dz_) -
      reinterpret_cast<char*>(&_impl_.angle_)) + sizeof(_impl_.start_dz_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* VectorBlock_Arcs3D::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 0, 0, 2> VectorBlock_Arcs3D::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_VectorBlock_Arcs3D_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // double angle = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_Arcs3D, _impl_.angle_)}},
    // float start_dx = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_Arcs3D, _impl_.start_dx_)}},
    // float start_dy = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_Arcs3D, _impl_.start_dy_)}},
    // float start_dz = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_Arcs3D, _impl_.start_dz_)}},
    // repeated float centers = 5;
    {::_pbi::TcParser::FastF32P1,
     {42, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_Arcs3D, _impl_.centers_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // double angle = 1;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_Arcs3D, _impl_.angle_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // float start_dx = 2;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_Arcs3D, _impl_.start_dx_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float start_dy = 3;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_Arcs3D, _impl_.start_dy_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float start_dz = 4;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_Arcs3D, _impl_.start_dz_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // repeated float centers = 5;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_Arcs3D, _impl_.centers_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedFloat)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* VectorBlock_Arcs3D::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:open_vector_format.VectorBlock.Arcs3D)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double angle = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_angle = this->_internal_angle();
  ::uint64_t raw_angle;
  memcpy(&raw_angle, &tmp_angle, sizeof(tmp_angle));
  if (raw_angle != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_angle(), target);
  }

  // float start_dx = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_start_dx = this->_internal_start_dx();
  ::uint32_t raw_start_dx;
  memcpy(&raw_start_dx, &tmp_start_dx, sizeof(tmp_start_dx));
  if (raw_start_dx != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_start_dx(), target);
  }

  // float start_dy = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_start_dy = this->_internal_start_dy();
  ::uint32_t raw_start_dy;
  memcpy(&raw_start_dy, &tmp_start_dy, sizeof(tmp_start_dy));
  if (raw_start_dy != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_start_dy(), target);
  }

  // float start_dz = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_start_dz = this->_internal_start_dz();
  ::uint32_t raw_start_dz;
  memcpy(&raw_start_dz, &tmp_start_dz, sizeof(tmp_start_dz));
  if (raw_start_dz != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_start_dz(), target);
  }

  // repeated float centers = 5;
  if (this->_internal_centers_size() > 0) {
    target = stream->WriteFixedPacked(5, _internal_centers(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:open_vector_format.VectorBlock.Arcs3D)
  return target;
}

::size_t VectorBlock_Arcs3D::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:open_vector_format.VectorBlock.Arcs3D)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float centers = 5;
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_centers_size())
    ;
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // double angle = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_angle = this->_internal_angle();
  ::uint64_t raw_angle;
  memcpy(&raw_angle, &tmp_angle, sizeof(tmp_angle));
  if (raw_angle != 0) {
    total_size += 9;
  }

  // float start_dx = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_start_dx = this->_internal_start_dx();
  ::uint32_t raw_start_dx;
  memcpy(&raw_start_dx, &tmp_start_dx, sizeof(tmp_start_dx));
  if (raw_start_dx != 0) {
    total_size += 5;
  }

  // float start_dy = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_start_dy = this->_internal_start_dy();
  ::uint32_t raw_start_dy;
  memcpy(&raw_start_dy, &tmp_start_dy, sizeof(tmp_start_dy));
  if (raw_start_dy != 0) {
    total_size += 5;
  }

  // float start_dz = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_start_dz = this->_internal_start_dz();
  ::uint32_t raw_start_dz;
  memcpy(&raw_start_dz, &tmp_start_dz, sizeof(tmp_start_dz));
  if (raw_start_dz != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData VectorBlock_Arcs3D::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    VectorBlock_Arcs3D::MergeImpl
};
const ::google::protobuf::Message::ClassData*VectorBlock_Arcs3D::GetClassData() const { return &_class_data_; }


void VectorBlock_Arcs3D::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<VectorBlock_Arcs3D*>(&to_msg);
  auto& from = static_cast<const VectorBlock_Arcs3D&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:open_vector_format.VectorBlock.Arcs3D)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_centers()->MergeFrom(from._internal_centers());
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_angle = from._internal_angle();
  ::uint64_t raw_angle;
  memcpy(&raw_angle, &tmp_angle, sizeof(tmp_angle));
  if (raw_angle != 0) {
    _this->_internal_set_angle(from._internal_angle());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_start_dx = from._internal_start_dx();
  ::uint32_t raw_start_dx;
  memcpy(&raw_start_dx, &tmp_start_dx, sizeof(tmp_start_dx));
  if (raw_start_dx != 0) {
    _this->_internal_set_start_dx(from._internal_start_dx());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_start_dy = from._internal_start_dy();
  ::uint32_t raw_start_dy;
  memcpy(&raw_start_dy, &tmp_start_dy, sizeof(tmp_start_dy));
  if (raw_start_dy != 0) {
    _this->_internal_set_start_dy(from._internal_start_dy());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_start_dz = from._internal_start_dz();
  ::uint32_t raw_start_dz;
  memcpy(&raw_start_dz, &tmp_start_dz, sizeof(tmp_start_dz));
  if (raw_start_dz != 0) {
    _this->_internal_set_start_dz(from._internal_start_dz());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void VectorBlock_Arcs3D::CopyFrom(const VectorBlock_Arcs3D& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:open_vector_format.VectorBlock.Arcs3D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool VectorBlock_Arcs3D::IsInitialized() const {
  return true;
}

void VectorBlock_Arcs3D::InternalSwap(VectorBlock_Arcs3D* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.centers_.InternalSwap(&other->_impl_.centers_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VectorBlock_Arcs3D, _impl_.start_dz_)
      + sizeof(VectorBlock_Arcs3D::_impl_.start_dz_)
      - PROTOBUF_FIELD_OFFSET(VectorBlock_Arcs3D, _impl_.angle_)>(
          reinterpret_cast<char*>(&_impl_.angle_),
          reinterpret_cast<char*>(&other->_impl_.angle_));
}

::google::protobuf::Metadata VectorBlock_Arcs3D::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_open_5fvector_5fformat_2eproto_getter, &descriptor_table_open_5fvector_5fformat_2eproto_once,
      file_level_metadata_open_5fvector_5fformat_2eproto[28]);
}
// ===================================================================

class VectorBlock_Ellipses::_Internal {
 public:
  using HasBits = decltype(std::declval<VectorBlock_Ellipses>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(VectorBlock_Ellipses, _impl_._has_bits_);
  static const ::open_vector_format::VectorBlock_Arcs& ellipses_arcs(const VectorBlock_Ellipses* msg);
  static void set_has_ellipses_arcs(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::open_vector_format::VectorBlock_Arcs& VectorBlock_Ellipses::_Internal::ellipses_arcs(const VectorBlock_Ellipses* msg) {
  return *msg->_impl_.ellipses_arcs_;
}
VectorBlock_Ellipses::VectorBlock_Ellipses(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:open_vector_format.VectorBlock.Ellipses)
}
VectorBlock_Ellipses::VectorBlock_Ellipses(const VectorBlock_Ellipses& from) : ::google::protobuf::Message() {
  VectorBlock_Ellipses* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.ellipses_arcs_){nullptr},
      decltype(_impl_.a_){},
      decltype(_impl_.b_){},
      decltype(_impl_.phi0_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.ellipses_arcs_ = new ::open_vector_format::VectorBlock_Arcs(*from._impl_.ellipses_arcs_);
  }
  ::memcpy(&_impl_.a_, &from._impl_.a_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.phi0_) -
    reinterpret_cast<char*>(&_impl_.a_)) + sizeof(_impl_.phi0_));

  // @@protoc_insertion_point(copy_constructor:open_vector_format.VectorBlock.Ellipses)
}
inline void VectorBlock_Ellipses::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.ellipses_arcs_){nullptr},
      decltype(_impl_.a_){0},
      decltype(_impl_.b_){0},
      decltype(_impl_.phi0_){0},
  };
}
VectorBlock_Ellipses::~VectorBlock_Ellipses() {
  // @@protoc_insertion_point(destructor:open_vector_format.VectorBlock.Ellipses)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void VectorBlock_Ellipses::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.ellipses_arcs_;
}
void VectorBlock_Ellipses::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void VectorBlock_Ellipses::Clear() {
// @@protoc_insertion_point(message_clear_start:open_vector_format.VectorBlock.Ellipses)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.ellipses_arcs_ != nullptr);
    _impl_.ellipses_arcs_->Clear();
  }
  ::memset(&_impl_.a_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.phi0_) -
      reinterpret_cast<char*>(&_impl_.a_)) + sizeof(_impl_.phi0_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* VectorBlock_Ellipses::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 1, 0, 2> VectorBlock_Ellipses::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(VectorBlock_Ellipses, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_VectorBlock_Ellipses_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // .open_vector_format.VectorBlock.Arcs ellipses_arcs = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 0, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_Ellipses, _impl_.ellipses_arcs_)}},
    // float a = 1;
    {::_pbi::TcParser::FastF32S1,
     {13, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_Ellipses, _impl_.a_)}},
    // float b = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_Ellipses, _impl_.b_)}},
    // double phi0 = 3;
    {::_pbi::TcParser::FastF64S1,
     {25, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_Ellipses, _impl_.phi0_)}},
  }}, {{
    65535, 65535
  }}, {{
    // float a = 1;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_Ellipses, _impl_.a_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float b = 2;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_Ellipses, _impl_.b_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // double phi0 = 3;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_Ellipses, _impl_.phi0_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // .open_vector_format.VectorBlock.Arcs ellipses_arcs = 4;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_Ellipses, _impl_.ellipses_arcs_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::open_vector_format::VectorBlock_Arcs>()},
  }}, {{
  }},
};

::uint8_t* VectorBlock_Ellipses::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:open_vector_format.VectorBlock.Ellipses)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // float a = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_a = this->_internal_a();
  ::uint32_t raw_a;
  memcpy(&raw_a, &tmp_a, sizeof(tmp_a));
  if (raw_a != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_a(), target);
  }

  // float b = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_b = this->_internal_b();
  ::uint32_t raw_b;
  memcpy(&raw_b, &tmp_b, sizeof(tmp_b));
  if (raw_b != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_b(), target);
  }

  // double phi0 = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_phi0 = this->_internal_phi0();
  ::uint64_t raw_phi0;
  memcpy(&raw_phi0, &tmp_phi0, sizeof(tmp_phi0));
  if (raw_phi0 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_phi0(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .open_vector_format.VectorBlock.Arcs ellipses_arcs = 4;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::ellipses_arcs(this),
        _Internal::ellipses_arcs(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:open_vector_format.VectorBlock.Ellipses)
  return target;
}

::size_t VectorBlock_Ellipses::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:open_vector_format.VectorBlock.Ellipses)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .open_vector_format.VectorBlock.Arcs ellipses_arcs = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *_impl_.ellipses_arcs_);
  }

  // float a = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_a = this->_internal_a();
  ::uint32_t raw_a;
  memcpy(&raw_a, &tmp_a, sizeof(tmp_a));
  if (raw_a != 0) {
    total_size += 5;
  }

  // float b = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_b = this->_internal_b();
  ::uint32_t raw_b;
  memcpy(&raw_b, &tmp_b, sizeof(tmp_b));
  if (raw_b != 0) {
    total_size += 5;
  }

  // double phi0 = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_phi0 = this->_internal_phi0();
  ::uint64_t raw_phi0;
  memcpy(&raw_phi0, &tmp_phi0, sizeof(tmp_phi0));
  if (raw_phi0 != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData VectorBlock_Ellipses::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    VectorBlock_Ellipses::MergeImpl
};
const ::google::protobuf::Message::ClassData*VectorBlock_Ellipses::GetClassData() const { return &_class_data_; }


void VectorBlock_Ellipses::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<VectorBlock_Ellipses*>(&to_msg);
  auto& from = static_cast<const VectorBlock_Ellipses&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:open_vector_format.VectorBlock.Ellipses)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_ellipses_arcs()->::open_vector_format::VectorBlock_Arcs::MergeFrom(
        from._internal_ellipses_arcs());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_a = from._internal_a();
  ::uint32_t raw_a;
  memcpy(&raw_a, &tmp_a, sizeof(tmp_a));
  if (raw_a != 0) {
    _this->_internal_set_a(from._internal_a());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_b = from._internal_b();
  ::uint32_t raw_b;
  memcpy(&raw_b, &tmp_b, sizeof(tmp_b));
  if (raw_b != 0) {
    _this->_internal_set_b(from._internal_b());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_phi0 = from._internal_phi0();
  ::uint64_t raw_phi0;
  memcpy(&raw_phi0, &tmp_phi0, sizeof(tmp_phi0));
  if (raw_phi0 != 0) {
    _this->_internal_set_phi0(from._internal_phi0());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void VectorBlock_Ellipses::CopyFrom(const VectorBlock_Ellipses& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:open_vector_format.VectorBlock.Ellipses)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool VectorBlock_Ellipses::IsInitialized() const {
  return true;
}

void VectorBlock_Ellipses::InternalSwap(VectorBlock_Ellipses* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VectorBlock_Ellipses, _impl_.phi0_)
      + sizeof(VectorBlock_Ellipses::_impl_.phi0_)
      - PROTOBUF_FIELD_OFFSET(VectorBlock_Ellipses, _impl_.ellipses_arcs_)>(
          reinterpret_cast<char*>(&_impl_.ellipses_arcs_),
          reinterpret_cast<char*>(&other->_impl_.ellipses_arcs_));
}

::google::protobuf::Metadata VectorBlock_Ellipses::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_open_5fvector_5fformat_2eproto_getter, &descriptor_table_open_5fvector_5fformat_2eproto_once,
      file_level_metadata_open_5fvector_5fformat_2eproto[29]);
}
// ===================================================================

class VectorBlock_ExposurePause::_Internal {
 public:
};

VectorBlock_ExposurePause::VectorBlock_ExposurePause(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:open_vector_format.VectorBlock.ExposurePause)
}
VectorBlock_ExposurePause::VectorBlock_ExposurePause(const VectorBlock_ExposurePause& from)
    : ::google::protobuf::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:open_vector_format.VectorBlock.ExposurePause)
}
inline void VectorBlock_ExposurePause::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.pause_in_us_){::uint64_t{0u}},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
VectorBlock_ExposurePause::~VectorBlock_ExposurePause() {
  // @@protoc_insertion_point(destructor:open_vector_format.VectorBlock.ExposurePause)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void VectorBlock_ExposurePause::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}
void VectorBlock_ExposurePause::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void VectorBlock_ExposurePause::Clear() {
// @@protoc_insertion_point(message_clear_start:open_vector_format.VectorBlock.ExposurePause)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.pause_in_us_ = ::uint64_t{0u};
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* VectorBlock_ExposurePause::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2> VectorBlock_ExposurePause::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_VectorBlock_ExposurePause_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // uint64 pause_in_us = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(VectorBlock_ExposurePause, _impl_.pause_in_us_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_ExposurePause, _impl_.pause_in_us_)}},
  }}, {{
    65535, 65535
  }}, {{
    // uint64 pause_in_us = 1;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_ExposurePause, _impl_.pause_in_us_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt64)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* VectorBlock_ExposurePause::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:open_vector_format.VectorBlock.ExposurePause)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // uint64 pause_in_us = 1;
  if (this->_internal_pause_in_us() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_pause_in_us(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:open_vector_format.VectorBlock.ExposurePause)
  return target;
}

::size_t VectorBlock_ExposurePause::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:open_vector_format.VectorBlock.ExposurePause)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 pause_in_us = 1;
  if (this->_internal_pause_in_us() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_pause_in_us());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData VectorBlock_ExposurePause::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    VectorBlock_ExposurePause::MergeImpl
};
const ::google::protobuf::Message::ClassData*VectorBlock_ExposurePause::GetClassData() const { return &_class_data_; }


void VectorBlock_ExposurePause::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<VectorBlock_ExposurePause*>(&to_msg);
  auto& from = static_cast<const VectorBlock_ExposurePause&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:open_vector_format.VectorBlock.ExposurePause)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_pause_in_us() != 0) {
    _this->_internal_set_pause_in_us(from._internal_pause_in_us());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void VectorBlock_ExposurePause::CopyFrom(const VectorBlock_ExposurePause& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:open_vector_format.VectorBlock.ExposurePause)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool VectorBlock_ExposurePause::IsInitialized() const {
  return true;
}

void VectorBlock_ExposurePause::InternalSwap(VectorBlock_ExposurePause* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
        swap(_impl_.pause_in_us_, other->_impl_.pause_in_us_);
}

::google::protobuf::Metadata VectorBlock_ExposurePause::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_open_5fvector_5fformat_2eproto_getter, &descriptor_table_open_5fvector_5fformat_2eproto_once,
      file_level_metadata_open_5fvector_5fformat_2eproto[30]);
}
// ===================================================================

class VectorBlock_LineSequenceParaAdapt::_Internal {
 public:
};

VectorBlock_LineSequenceParaAdapt::VectorBlock_LineSequenceParaAdapt(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:open_vector_format.VectorBlock.LineSequenceParaAdapt)
}
VectorBlock_LineSequenceParaAdapt::VectorBlock_LineSequenceParaAdapt(const VectorBlock_LineSequenceParaAdapt& from) : ::google::protobuf::Message() {
  VectorBlock_LineSequenceParaAdapt* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.points_with_paras_){from._impl_.points_with_paras_},
      decltype(_impl_.parameter_){},
      /*decltype(_impl_._cached_size_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _this->_impl_.parameter_ = from._impl_.parameter_;

  // @@protoc_insertion_point(copy_constructor:open_vector_format.VectorBlock.LineSequenceParaAdapt)
}
inline void VectorBlock_LineSequenceParaAdapt::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.points_with_paras_){arena},
      decltype(_impl_.parameter_){0},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
VectorBlock_LineSequenceParaAdapt::~VectorBlock_LineSequenceParaAdapt() {
  // @@protoc_insertion_point(destructor:open_vector_format.VectorBlock.LineSequenceParaAdapt)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void VectorBlock_LineSequenceParaAdapt::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.points_with_paras_.~RepeatedField();
}
void VectorBlock_LineSequenceParaAdapt::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void VectorBlock_LineSequenceParaAdapt::Clear() {
// @@protoc_insertion_point(message_clear_start:open_vector_format.VectorBlock.LineSequenceParaAdapt)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_points_with_paras()->Clear();
  _impl_.parameter_ = 0;
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* VectorBlock_LineSequenceParaAdapt::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> VectorBlock_LineSequenceParaAdapt::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_VectorBlock_LineSequenceParaAdapt_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // .open_vector_format.VectorBlock.LineSequenceParaAdapt.AdaptedParameter parameter = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(VectorBlock_LineSequenceParaAdapt, _impl_.parameter_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_LineSequenceParaAdapt, _impl_.parameter_)}},
    // repeated float points_with_paras = 1;
    {::_pbi::TcParser::FastF32P1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_LineSequenceParaAdapt, _impl_.points_with_paras_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated float points_with_paras = 1;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_LineSequenceParaAdapt, _impl_.points_with_paras_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedFloat)},
    // .open_vector_format.VectorBlock.LineSequenceParaAdapt.AdaptedParameter parameter = 2;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_LineSequenceParaAdapt, _impl_.parameter_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* VectorBlock_LineSequenceParaAdapt::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:open_vector_format.VectorBlock.LineSequenceParaAdapt)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated float points_with_paras = 1;
  if (this->_internal_points_with_paras_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_points_with_paras(), target);
  }

  // .open_vector_format.VectorBlock.LineSequenceParaAdapt.AdaptedParameter parameter = 2;
  if (this->_internal_parameter() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_parameter(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:open_vector_format.VectorBlock.LineSequenceParaAdapt)
  return target;
}

::size_t VectorBlock_LineSequenceParaAdapt::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:open_vector_format.VectorBlock.LineSequenceParaAdapt)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float points_with_paras = 1;
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_points_with_paras_size())
    ;
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // .open_vector_format.VectorBlock.LineSequenceParaAdapt.AdaptedParameter parameter = 2;
  if (this->_internal_parameter() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_parameter());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData VectorBlock_LineSequenceParaAdapt::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    VectorBlock_LineSequenceParaAdapt::MergeImpl
};
const ::google::protobuf::Message::ClassData*VectorBlock_LineSequenceParaAdapt::GetClassData() const { return &_class_data_; }


void VectorBlock_LineSequenceParaAdapt::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<VectorBlock_LineSequenceParaAdapt*>(&to_msg);
  auto& from = static_cast<const VectorBlock_LineSequenceParaAdapt&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:open_vector_format.VectorBlock.LineSequenceParaAdapt)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_points_with_paras()->MergeFrom(from._internal_points_with_paras());
  if (from._internal_parameter() != 0) {
    _this->_internal_set_parameter(from._internal_parameter());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void VectorBlock_LineSequenceParaAdapt::CopyFrom(const VectorBlock_LineSequenceParaAdapt& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:open_vector_format.VectorBlock.LineSequenceParaAdapt)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool VectorBlock_LineSequenceParaAdapt::IsInitialized() const {
  return true;
}

void VectorBlock_LineSequenceParaAdapt::InternalSwap(VectorBlock_LineSequenceParaAdapt* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.points_with_paras_.InternalSwap(&other->_impl_.points_with_paras_);
  swap(_impl_.parameter_, other->_impl_.parameter_);
}

::google::protobuf::Metadata VectorBlock_LineSequenceParaAdapt::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_open_5fvector_5fformat_2eproto_getter, &descriptor_table_open_5fvector_5fformat_2eproto_once,
      file_level_metadata_open_5fvector_5fformat_2eproto[31]);
}
// ===================================================================

class VectorBlock_HatchesParaAdapt::_Internal {
 public:
};

VectorBlock_HatchesParaAdapt::VectorBlock_HatchesParaAdapt(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:open_vector_format.VectorBlock.HatchesParaAdapt)
}
VectorBlock_HatchesParaAdapt::VectorBlock_HatchesParaAdapt(const VectorBlock_HatchesParaAdapt& from) : ::google::protobuf::Message() {
  VectorBlock_HatchesParaAdapt* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.hatchaslinesequence_){from._impl_.hatchaslinesequence_},
      /*decltype(_impl_._cached_size_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);

  // @@protoc_insertion_point(copy_constructor:open_vector_format.VectorBlock.HatchesParaAdapt)
}
inline void VectorBlock_HatchesParaAdapt::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.hatchaslinesequence_){arena},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
VectorBlock_HatchesParaAdapt::~VectorBlock_HatchesParaAdapt() {
  // @@protoc_insertion_point(destructor:open_vector_format.VectorBlock.HatchesParaAdapt)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void VectorBlock_HatchesParaAdapt::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.hatchaslinesequence_.~RepeatedPtrField();
}
void VectorBlock_HatchesParaAdapt::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void VectorBlock_HatchesParaAdapt::Clear() {
// @@protoc_insertion_point(message_clear_start:open_vector_format.VectorBlock.HatchesParaAdapt)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_hatchaslinesequence()->Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* VectorBlock_HatchesParaAdapt::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 1, 0, 2> VectorBlock_HatchesParaAdapt::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_VectorBlock_HatchesParaAdapt_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // repeated .open_vector_format.VectorBlock.LineSequenceParaAdapt hatchAsLinesequence = 1;
    {::_pbi::TcParser::FastMtR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock_HatchesParaAdapt, _impl_.hatchaslinesequence_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .open_vector_format.VectorBlock.LineSequenceParaAdapt hatchAsLinesequence = 1;
    {PROTOBUF_FIELD_OFFSET(VectorBlock_HatchesParaAdapt, _impl_.hatchaslinesequence_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::open_vector_format::VectorBlock_LineSequenceParaAdapt>()},
  }}, {{
  }},
};

::uint8_t* VectorBlock_HatchesParaAdapt::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:open_vector_format.VectorBlock.HatchesParaAdapt)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .open_vector_format.VectorBlock.LineSequenceParaAdapt hatchAsLinesequence = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_hatchaslinesequence_size()); i < n; i++) {
    const auto& repfield = this->_internal_hatchaslinesequence().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:open_vector_format.VectorBlock.HatchesParaAdapt)
  return target;
}

::size_t VectorBlock_HatchesParaAdapt::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:open_vector_format.VectorBlock.HatchesParaAdapt)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .open_vector_format.VectorBlock.LineSequenceParaAdapt hatchAsLinesequence = 1;
  total_size += 1UL * this->_internal_hatchaslinesequence_size();
  for (const auto& msg : this->_internal_hatchaslinesequence()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData VectorBlock_HatchesParaAdapt::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    VectorBlock_HatchesParaAdapt::MergeImpl
};
const ::google::protobuf::Message::ClassData*VectorBlock_HatchesParaAdapt::GetClassData() const { return &_class_data_; }


void VectorBlock_HatchesParaAdapt::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<VectorBlock_HatchesParaAdapt*>(&to_msg);
  auto& from = static_cast<const VectorBlock_HatchesParaAdapt&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:open_vector_format.VectorBlock.HatchesParaAdapt)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_hatchaslinesequence()->MergeFrom(from._internal_hatchaslinesequence());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void VectorBlock_HatchesParaAdapt::CopyFrom(const VectorBlock_HatchesParaAdapt& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:open_vector_format.VectorBlock.HatchesParaAdapt)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool VectorBlock_HatchesParaAdapt::IsInitialized() const {
  return true;
}

void VectorBlock_HatchesParaAdapt::InternalSwap(VectorBlock_HatchesParaAdapt* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.hatchaslinesequence_.InternalSwap(&other->_impl_.hatchaslinesequence_);
}

::google::protobuf::Metadata VectorBlock_HatchesParaAdapt::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_open_5fvector_5fformat_2eproto_getter, &descriptor_table_open_5fvector_5fformat_2eproto_once,
      file_level_metadata_open_5fvector_5fformat_2eproto[32]);
}
// ===================================================================

class VectorBlock::_Internal {
 public:
  using HasBits = decltype(std::declval<VectorBlock>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(VectorBlock, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::open_vector_format::VectorBlock, _impl_._oneof_case_);
  static const ::open_vector_format::VectorBlock_LineSequence& line_sequence(const VectorBlock* msg);
  static const ::open_vector_format::VectorBlock_Hatches& _hatches(const VectorBlock* msg);
  static const ::open_vector_format::VectorBlock_PointSequence& point_sequence(const VectorBlock* msg);
  static const ::open_vector_format::VectorBlock_Arcs& _arcs(const VectorBlock* msg);
  static const ::open_vector_format::VectorBlock_Ellipses& ellipses(const VectorBlock* msg);
  static const ::open_vector_format::VectorBlock_LineSequence3D& line_sequence_3d(const VectorBlock* msg);
  static const ::open_vector_format::VectorBlock_Hatches3D& hatches_3d(const VectorBlock* msg);
  static const ::open_vector_format::VectorBlock_PointSequence3D& point_sequence_3d(const VectorBlock* msg);
  static const ::open_vector_format::VectorBlock_Arcs3D& arcs_3d(const VectorBlock* msg);
  static const ::open_vector_format::VectorBlock_ExposurePause& exposure_pause(const VectorBlock* msg);
  static const ::open_vector_format::VectorBlock_LineSequenceParaAdapt& line_sequence_para_adapt(const VectorBlock* msg);
  static const ::open_vector_format::VectorBlock_HatchesParaAdapt& _hatchparaadapt(const VectorBlock* msg);
  static const ::open_vector_format::VectorBlock_VectorBlockMetaData& meta_data(const VectorBlock* msg);
  static void set_has_meta_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::open_vector_format::VectorBlock_LPBFMetadata& lpbf_metadata(const VectorBlock* msg);
  static const ::open_vector_format::VectorBlock_MicroStructuringMetadata& micro_structuring_metadata(const VectorBlock* msg);
  static const ::open_vector_format::VectorBlock_PolishingMetadata& polishing_metadata(const VectorBlock* msg);
};

const ::open_vector_format::VectorBlock_LineSequence& VectorBlock::_Internal::line_sequence(const VectorBlock* msg) {
  return *msg->_impl_.vector_data_.line_sequence_;
}
const ::open_vector_format::VectorBlock_Hatches& VectorBlock::_Internal::_hatches(const VectorBlock* msg) {
  return *msg->_impl_.vector_data_._hatches_;
}
const ::open_vector_format::VectorBlock_PointSequence& VectorBlock::_Internal::point_sequence(const VectorBlock* msg) {
  return *msg->_impl_.vector_data_.point_sequence_;
}
const ::open_vector_format::VectorBlock_Arcs& VectorBlock::_Internal::_arcs(const VectorBlock* msg) {
  return *msg->_impl_.vector_data_._arcs_;
}
const ::open_vector_format::VectorBlock_Ellipses& VectorBlock::_Internal::ellipses(const VectorBlock* msg) {
  return *msg->_impl_.vector_data_.ellipses_;
}
const ::open_vector_format::VectorBlock_LineSequence3D& VectorBlock::_Internal::line_sequence_3d(const VectorBlock* msg) {
  return *msg->_impl_.vector_data_.line_sequence_3d_;
}
const ::open_vector_format::VectorBlock_Hatches3D& VectorBlock::_Internal::hatches_3d(const VectorBlock* msg) {
  return *msg->_impl_.vector_data_.hatches_3d_;
}
const ::open_vector_format::VectorBlock_PointSequence3D& VectorBlock::_Internal::point_sequence_3d(const VectorBlock* msg) {
  return *msg->_impl_.vector_data_.point_sequence_3d_;
}
const ::open_vector_format::VectorBlock_Arcs3D& VectorBlock::_Internal::arcs_3d(const VectorBlock* msg) {
  return *msg->_impl_.vector_data_.arcs_3d_;
}
const ::open_vector_format::VectorBlock_ExposurePause& VectorBlock::_Internal::exposure_pause(const VectorBlock* msg) {
  return *msg->_impl_.vector_data_.exposure_pause_;
}
const ::open_vector_format::VectorBlock_LineSequenceParaAdapt& VectorBlock::_Internal::line_sequence_para_adapt(const VectorBlock* msg) {
  return *msg->_impl_.vector_data_.line_sequence_para_adapt_;
}
const ::open_vector_format::VectorBlock_HatchesParaAdapt& VectorBlock::_Internal::_hatchparaadapt(const VectorBlock* msg) {
  return *msg->_impl_.vector_data_._hatchparaadapt_;
}
const ::open_vector_format::VectorBlock_VectorBlockMetaData& VectorBlock::_Internal::meta_data(const VectorBlock* msg) {
  return *msg->_impl_.meta_data_;
}
const ::open_vector_format::VectorBlock_LPBFMetadata& VectorBlock::_Internal::lpbf_metadata(const VectorBlock* msg) {
  return *msg->_impl_.process_meta_data_.lpbf_metadata_;
}
const ::open_vector_format::VectorBlock_MicroStructuringMetadata& VectorBlock::_Internal::micro_structuring_metadata(const VectorBlock* msg) {
  return *msg->_impl_.process_meta_data_.micro_structuring_metadata_;
}
const ::open_vector_format::VectorBlock_PolishingMetadata& VectorBlock::_Internal::polishing_metadata(const VectorBlock* msg) {
  return *msg->_impl_.process_meta_data_.polishing_metadata_;
}
void VectorBlock::set_allocated_line_sequence(::open_vector_format::VectorBlock_LineSequence* line_sequence) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_vector_data();
  if (line_sequence) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(line_sequence);
    if (message_arena != submessage_arena) {
      line_sequence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, line_sequence, submessage_arena);
    }
    set_has_line_sequence();
    _impl_.vector_data_.line_sequence_ = line_sequence;
  }
  // @@protoc_insertion_point(field_set_allocated:open_vector_format.VectorBlock.line_sequence)
}
void VectorBlock::set_allocated__hatches(::open_vector_format::VectorBlock_Hatches* _hatches) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_vector_data();
  if (_hatches) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(_hatches);
    if (message_arena != submessage_arena) {
      _hatches = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, _hatches, submessage_arena);
    }
    set_has__hatches();
    _impl_.vector_data_._hatches_ = _hatches;
  }
  // @@protoc_insertion_point(field_set_allocated:open_vector_format.VectorBlock._hatches)
}
void VectorBlock::set_allocated_point_sequence(::open_vector_format::VectorBlock_PointSequence* point_sequence) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_vector_data();
  if (point_sequence) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(point_sequence);
    if (message_arena != submessage_arena) {
      point_sequence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, point_sequence, submessage_arena);
    }
    set_has_point_sequence();
    _impl_.vector_data_.point_sequence_ = point_sequence;
  }
  // @@protoc_insertion_point(field_set_allocated:open_vector_format.VectorBlock.point_sequence)
}
void VectorBlock::set_allocated__arcs(::open_vector_format::VectorBlock_Arcs* _arcs) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_vector_data();
  if (_arcs) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(_arcs);
    if (message_arena != submessage_arena) {
      _arcs = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, _arcs, submessage_arena);
    }
    set_has__arcs();
    _impl_.vector_data_._arcs_ = _arcs;
  }
  // @@protoc_insertion_point(field_set_allocated:open_vector_format.VectorBlock._arcs)
}
void VectorBlock::set_allocated_ellipses(::open_vector_format::VectorBlock_Ellipses* ellipses) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_vector_data();
  if (ellipses) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(ellipses);
    if (message_arena != submessage_arena) {
      ellipses = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ellipses, submessage_arena);
    }
    set_has_ellipses();
    _impl_.vector_data_.ellipses_ = ellipses;
  }
  // @@protoc_insertion_point(field_set_allocated:open_vector_format.VectorBlock.ellipses)
}
void VectorBlock::set_allocated_line_sequence_3d(::open_vector_format::VectorBlock_LineSequence3D* line_sequence_3d) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_vector_data();
  if (line_sequence_3d) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(line_sequence_3d);
    if (message_arena != submessage_arena) {
      line_sequence_3d = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, line_sequence_3d, submessage_arena);
    }
    set_has_line_sequence_3d();
    _impl_.vector_data_.line_sequence_3d_ = line_sequence_3d;
  }
  // @@protoc_insertion_point(field_set_allocated:open_vector_format.VectorBlock.line_sequence_3d)
}
void VectorBlock::set_allocated_hatches_3d(::open_vector_format::VectorBlock_Hatches3D* hatches_3d) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_vector_data();
  if (hatches_3d) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(hatches_3d);
    if (message_arena != submessage_arena) {
      hatches_3d = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, hatches_3d, submessage_arena);
    }
    set_has_hatches_3d();
    _impl_.vector_data_.hatches_3d_ = hatches_3d;
  }
  // @@protoc_insertion_point(field_set_allocated:open_vector_format.VectorBlock.hatches_3d)
}
void VectorBlock::set_allocated_point_sequence_3d(::open_vector_format::VectorBlock_PointSequence3D* point_sequence_3d) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_vector_data();
  if (point_sequence_3d) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(point_sequence_3d);
    if (message_arena != submessage_arena) {
      point_sequence_3d = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, point_sequence_3d, submessage_arena);
    }
    set_has_point_sequence_3d();
    _impl_.vector_data_.point_sequence_3d_ = point_sequence_3d;
  }
  // @@protoc_insertion_point(field_set_allocated:open_vector_format.VectorBlock.point_sequence_3d)
}
void VectorBlock::set_allocated_arcs_3d(::open_vector_format::VectorBlock_Arcs3D* arcs_3d) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_vector_data();
  if (arcs_3d) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(arcs_3d);
    if (message_arena != submessage_arena) {
      arcs_3d = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, arcs_3d, submessage_arena);
    }
    set_has_arcs_3d();
    _impl_.vector_data_.arcs_3d_ = arcs_3d;
  }
  // @@protoc_insertion_point(field_set_allocated:open_vector_format.VectorBlock.arcs_3d)
}
void VectorBlock::set_allocated_exposure_pause(::open_vector_format::VectorBlock_ExposurePause* exposure_pause) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_vector_data();
  if (exposure_pause) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(exposure_pause);
    if (message_arena != submessage_arena) {
      exposure_pause = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, exposure_pause, submessage_arena);
    }
    set_has_exposure_pause();
    _impl_.vector_data_.exposure_pause_ = exposure_pause;
  }
  // @@protoc_insertion_point(field_set_allocated:open_vector_format.VectorBlock.exposure_pause)
}
void VectorBlock::set_allocated_line_sequence_para_adapt(::open_vector_format::VectorBlock_LineSequenceParaAdapt* line_sequence_para_adapt) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_vector_data();
  if (line_sequence_para_adapt) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(line_sequence_para_adapt);
    if (message_arena != submessage_arena) {
      line_sequence_para_adapt = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, line_sequence_para_adapt, submessage_arena);
    }
    set_has_line_sequence_para_adapt();
    _impl_.vector_data_.line_sequence_para_adapt_ = line_sequence_para_adapt;
  }
  // @@protoc_insertion_point(field_set_allocated:open_vector_format.VectorBlock.line_sequence_para_adapt)
}
void VectorBlock::set_allocated__hatchparaadapt(::open_vector_format::VectorBlock_HatchesParaAdapt* _hatchparaadapt) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_vector_data();
  if (_hatchparaadapt) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(_hatchparaadapt);
    if (message_arena != submessage_arena) {
      _hatchparaadapt = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, _hatchparaadapt, submessage_arena);
    }
    set_has__hatchparaadapt();
    _impl_.vector_data_._hatchparaadapt_ = _hatchparaadapt;
  }
  // @@protoc_insertion_point(field_set_allocated:open_vector_format.VectorBlock._hatchParaAdapt)
}
void VectorBlock::set_allocated_lpbf_metadata(::open_vector_format::VectorBlock_LPBFMetadata* lpbf_metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_process_meta_data();
  if (lpbf_metadata) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(lpbf_metadata);
    if (message_arena != submessage_arena) {
      lpbf_metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lpbf_metadata, submessage_arena);
    }
    set_has_lpbf_metadata();
    _impl_.process_meta_data_.lpbf_metadata_ = lpbf_metadata;
  }
  // @@protoc_insertion_point(field_set_allocated:open_vector_format.VectorBlock.lpbf_metadata)
}
void VectorBlock::set_allocated_micro_structuring_metadata(::open_vector_format::VectorBlock_MicroStructuringMetadata* micro_structuring_metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_process_meta_data();
  if (micro_structuring_metadata) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(micro_structuring_metadata);
    if (message_arena != submessage_arena) {
      micro_structuring_metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, micro_structuring_metadata, submessage_arena);
    }
    set_has_micro_structuring_metadata();
    _impl_.process_meta_data_.micro_structuring_metadata_ = micro_structuring_metadata;
  }
  // @@protoc_insertion_point(field_set_allocated:open_vector_format.VectorBlock.micro_structuring_metadata)
}
void VectorBlock::set_allocated_polishing_metadata(::open_vector_format::VectorBlock_PolishingMetadata* polishing_metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_process_meta_data();
  if (polishing_metadata) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(polishing_metadata);
    if (message_arena != submessage_arena) {
      polishing_metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, polishing_metadata, submessage_arena);
    }
    set_has_polishing_metadata();
    _impl_.process_meta_data_.polishing_metadata_ = polishing_metadata;
  }
  // @@protoc_insertion_point(field_set_allocated:open_vector_format.VectorBlock.polishing_metadata)
}
VectorBlock::VectorBlock(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:open_vector_format.VectorBlock)
}
VectorBlock::VectorBlock(const VectorBlock& from) : ::google::protobuf::Message() {
  VectorBlock* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.meta_data_){nullptr},
      decltype(_impl_.marking_params_key_){},
      decltype(_impl_.laser_index_){},
      decltype(_impl_.repeats_){},
      decltype(_impl_.vector_data_){},
      decltype(_impl_.process_meta_data_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.meta_data_ = new ::open_vector_format::VectorBlock_VectorBlockMetaData(*from._impl_.meta_data_);
  }
  ::memcpy(&_impl_.marking_params_key_, &from._impl_.marking_params_key_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.repeats_) -
    reinterpret_cast<char*>(&_impl_.marking_params_key_)) + sizeof(_impl_.repeats_));
  clear_has_vector_data();
  switch (from.vector_data_case()) {
    case kLineSequence: {
      _this->_internal_mutable_line_sequence()->::open_vector_format::VectorBlock_LineSequence::MergeFrom(
          from._internal_line_sequence());
      break;
    }
    case kHatches: {
      _this->_internal_mutable__hatches()->::open_vector_format::VectorBlock_Hatches::MergeFrom(
          from._internal__hatches());
      break;
    }
    case kPointSequence: {
      _this->_internal_mutable_point_sequence()->::open_vector_format::VectorBlock_PointSequence::MergeFrom(
          from._internal_point_sequence());
      break;
    }
    case kArcs: {
      _this->_internal_mutable__arcs()->::open_vector_format::VectorBlock_Arcs::MergeFrom(
          from._internal__arcs());
      break;
    }
    case kEllipses: {
      _this->_internal_mutable_ellipses()->::open_vector_format::VectorBlock_Ellipses::MergeFrom(
          from._internal_ellipses());
      break;
    }
    case kLineSequence3D: {
      _this->_internal_mutable_line_sequence_3d()->::open_vector_format::VectorBlock_LineSequence3D::MergeFrom(
          from._internal_line_sequence_3d());
      break;
    }
    case kHatches3D: {
      _this->_internal_mutable_hatches_3d()->::open_vector_format::VectorBlock_Hatches3D::MergeFrom(
          from._internal_hatches_3d());
      break;
    }
    case kPointSequence3D: {
      _this->_internal_mutable_point_sequence_3d()->::open_vector_format::VectorBlock_PointSequence3D::MergeFrom(
          from._internal_point_sequence_3d());
      break;
    }
    case kArcs3D: {
      _this->_internal_mutable_arcs_3d()->::open_vector_format::VectorBlock_Arcs3D::MergeFrom(
          from._internal_arcs_3d());
      break;
    }
    case kExposurePause: {
      _this->_internal_mutable_exposure_pause()->::open_vector_format::VectorBlock_ExposurePause::MergeFrom(
          from._internal_exposure_pause());
      break;
    }
    case kLineSequenceParaAdapt: {
      _this->_internal_mutable_line_sequence_para_adapt()->::open_vector_format::VectorBlock_LineSequenceParaAdapt::MergeFrom(
          from._internal_line_sequence_para_adapt());
      break;
    }
    case kHatchParaAdapt: {
      _this->_internal_mutable__hatchparaadapt()->::open_vector_format::VectorBlock_HatchesParaAdapt::MergeFrom(
          from._internal__hatchparaadapt());
      break;
    }
    case VECTOR_DATA_NOT_SET: {
      break;
    }
  }
  clear_has_process_meta_data();
  switch (from.process_meta_data_case()) {
    case kLpbfMetadata: {
      _this->_internal_mutable_lpbf_metadata()->::open_vector_format::VectorBlock_LPBFMetadata::MergeFrom(
          from._internal_lpbf_metadata());
      break;
    }
    case kMicroStructuringMetadata: {
      _this->_internal_mutable_micro_structuring_metadata()->::open_vector_format::VectorBlock_MicroStructuringMetadata::MergeFrom(
          from._internal_micro_structuring_metadata());
      break;
    }
    case kPolishingMetadata: {
      _this->_internal_mutable_polishing_metadata()->::open_vector_format::VectorBlock_PolishingMetadata::MergeFrom(
          from._internal_polishing_metadata());
      break;
    }
    case PROCESS_META_DATA_NOT_SET: {
      break;
    }
  }

  // @@protoc_insertion_point(copy_constructor:open_vector_format.VectorBlock)
}
inline void VectorBlock::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.meta_data_){nullptr},
      decltype(_impl_.marking_params_key_){0},
      decltype(_impl_.laser_index_){0},
      decltype(_impl_.repeats_){::uint64_t{0u}},
      decltype(_impl_.vector_data_){},
      decltype(_impl_.process_meta_data_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  clear_has_vector_data();
  clear_has_process_meta_data();
}
VectorBlock::~VectorBlock() {
  // @@protoc_insertion_point(destructor:open_vector_format.VectorBlock)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void VectorBlock::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.meta_data_;
  if (has_vector_data()) {
    clear_vector_data();
  }
  if (has_process_meta_data()) {
    clear_process_meta_data();
  }
}
void VectorBlock::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VectorBlock::clear_vector_data() {
// @@protoc_insertion_point(one_of_clear_start:open_vector_format.VectorBlock)
  switch (vector_data_case()) {
    case kLineSequence: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.vector_data_.line_sequence_;
      }
      break;
    }
    case kHatches: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.vector_data_._hatches_;
      }
      break;
    }
    case kPointSequence: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.vector_data_.point_sequence_;
      }
      break;
    }
    case kArcs: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.vector_data_._arcs_;
      }
      break;
    }
    case kEllipses: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.vector_data_.ellipses_;
      }
      break;
    }
    case kLineSequence3D: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.vector_data_.line_sequence_3d_;
      }
      break;
    }
    case kHatches3D: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.vector_data_.hatches_3d_;
      }
      break;
    }
    case kPointSequence3D: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.vector_data_.point_sequence_3d_;
      }
      break;
    }
    case kArcs3D: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.vector_data_.arcs_3d_;
      }
      break;
    }
    case kExposurePause: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.vector_data_.exposure_pause_;
      }
      break;
    }
    case kLineSequenceParaAdapt: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.vector_data_.line_sequence_para_adapt_;
      }
      break;
    }
    case kHatchParaAdapt: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.vector_data_._hatchparaadapt_;
      }
      break;
    }
    case VECTOR_DATA_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = VECTOR_DATA_NOT_SET;
}

void VectorBlock::clear_process_meta_data() {
// @@protoc_insertion_point(one_of_clear_start:open_vector_format.VectorBlock)
  switch (process_meta_data_case()) {
    case kLpbfMetadata: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.process_meta_data_.lpbf_metadata_;
      }
      break;
    }
    case kMicroStructuringMetadata: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.process_meta_data_.micro_structuring_metadata_;
      }
      break;
    }
    case kPolishingMetadata: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.process_meta_data_.polishing_metadata_;
      }
      break;
    }
    case PROCESS_META_DATA_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = PROCESS_META_DATA_NOT_SET;
}


PROTOBUF_NOINLINE void VectorBlock::Clear() {
// @@protoc_insertion_point(message_clear_start:open_vector_format.VectorBlock)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.meta_data_ != nullptr);
    _impl_.meta_data_->Clear();
  }
  ::memset(&_impl_.marking_params_key_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.repeats_) -
      reinterpret_cast<char*>(&_impl_.marking_params_key_)) + sizeof(_impl_.repeats_));
  clear_vector_data();
  clear_process_meta_data();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* VectorBlock::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 19, 16, 0, 13> VectorBlock::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(VectorBlock, _impl_._has_bits_),
    0, // no _extensions_
    103, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294963200,  // skipmap
    offsetof(decltype(_table_), field_entries),
    19,  // num_field_entries
    16,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_VectorBlock_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // int32 marking_params_key = 50;
    {::_pbi::TcParser::FastV32S2,
     {912, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock, _impl_.marking_params_key_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // .open_vector_format.VectorBlock.VectorBlockMetaData meta_data = 100;
    {::_pbi::TcParser::FastMtS2,
     {1698, 0, 12, PROTOBUF_FIELD_OFFSET(VectorBlock, _impl_.meta_data_)}},
    // int32 laser_index = 53;
    {::_pbi::TcParser::FastV32S2,
     {936, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock, _impl_.laser_index_)}},
    // uint64 repeats = 54;
    {::_pbi::TcParser::FastV64S2,
     {944, 63, 0, PROTOBUF_FIELD_OFFSET(VectorBlock, _impl_.repeats_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    50, 0, 4,
    65510, 12, 65535, 15, 65535, 15, 65475, 15,
    65535, 65535
  }}, {{
    // .open_vector_format.VectorBlock.LineSequence line_sequence = 1;
    {PROTOBUF_FIELD_OFFSET(VectorBlock, _impl_.vector_data_.line_sequence_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .open_vector_format.VectorBlock.Hatches _hatches = 2;
    {PROTOBUF_FIELD_OFFSET(VectorBlock, _impl_.vector_data_._hatches_), _Internal::kOneofCaseOffset + 0, 1,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .open_vector_format.VectorBlock.PointSequence point_sequence = 3;
    {PROTOBUF_FIELD_OFFSET(VectorBlock, _impl_.vector_data_.point_sequence_), _Internal::kOneofCaseOffset + 0, 2,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .open_vector_format.VectorBlock.Arcs _arcs = 4;
    {PROTOBUF_FIELD_OFFSET(VectorBlock, _impl_.vector_data_._arcs_), _Internal::kOneofCaseOffset + 0, 3,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .open_vector_format.VectorBlock.Ellipses ellipses = 5;
    {PROTOBUF_FIELD_OFFSET(VectorBlock, _impl_.vector_data_.ellipses_), _Internal::kOneofCaseOffset + 0, 4,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .open_vector_format.VectorBlock.LineSequence3D line_sequence_3d = 6;
    {PROTOBUF_FIELD_OFFSET(VectorBlock, _impl_.vector_data_.line_sequence_3d_), _Internal::kOneofCaseOffset + 0, 5,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .open_vector_format.VectorBlock.Hatches3D hatches_3d = 7;
    {PROTOBUF_FIELD_OFFSET(VectorBlock, _impl_.vector_data_.hatches_3d_), _Internal::kOneofCaseOffset + 0, 6,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .open_vector_format.VectorBlock.PointSequence3D point_sequence_3d = 8;
    {PROTOBUF_FIELD_OFFSET(VectorBlock, _impl_.vector_data_.point_sequence_3d_), _Internal::kOneofCaseOffset + 0, 7,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .open_vector_format.VectorBlock.Arcs3D arcs_3d = 9;
    {PROTOBUF_FIELD_OFFSET(VectorBlock, _impl_.vector_data_.arcs_3d_), _Internal::kOneofCaseOffset + 0, 8,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .open_vector_format.VectorBlock.ExposurePause exposure_pause = 10;
    {PROTOBUF_FIELD_OFFSET(VectorBlock, _impl_.vector_data_.exposure_pause_), _Internal::kOneofCaseOffset + 0, 9,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .open_vector_format.VectorBlock.LineSequenceParaAdapt line_sequence_para_adapt = 11;
    {PROTOBUF_FIELD_OFFSET(VectorBlock, _impl_.vector_data_.line_sequence_para_adapt_), _Internal::kOneofCaseOffset + 0, 10,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .open_vector_format.VectorBlock.HatchesParaAdapt _hatchParaAdapt = 12;
    {PROTOBUF_FIELD_OFFSET(VectorBlock, _impl_.vector_data_._hatchparaadapt_), _Internal::kOneofCaseOffset + 0, 11,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // int32 marking_params_key = 50;
    {PROTOBUF_FIELD_OFFSET(VectorBlock, _impl_.marking_params_key_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // int32 laser_index = 53;
    {PROTOBUF_FIELD_OFFSET(VectorBlock, _impl_.laser_index_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // uint64 repeats = 54;
    {PROTOBUF_FIELD_OFFSET(VectorBlock, _impl_.repeats_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt64)},
    // .open_vector_format.VectorBlock.VectorBlockMetaData meta_data = 100;
    {PROTOBUF_FIELD_OFFSET(VectorBlock, _impl_.meta_data_), _Internal::kHasBitsOffset + 0, 12,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .open_vector_format.VectorBlock.LPBFMetadata lpbf_metadata = 101;
    {PROTOBUF_FIELD_OFFSET(VectorBlock, _impl_.process_meta_data_.lpbf_metadata_), _Internal::kOneofCaseOffset + 4, 13,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .open_vector_format.VectorBlock.MicroStructuringMetadata micro_structuring_metadata = 102;
    {PROTOBUF_FIELD_OFFSET(VectorBlock, _impl_.process_meta_data_.micro_structuring_metadata_), _Internal::kOneofCaseOffset + 4, 14,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .open_vector_format.VectorBlock.PolishingMetadata polishing_metadata = 103;
    {PROTOBUF_FIELD_OFFSET(VectorBlock, _impl_.process_meta_data_.polishing_metadata_), _Internal::kOneofCaseOffset + 4, 15,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvDefault)},
  }}, {{
    {::_pbi::TcParser::GetTable<::open_vector_format::VectorBlock_LineSequence>()},
    {::_pbi::TcParser::GetTable<::open_vector_format::VectorBlock_Hatches>()},
    {::_pbi::TcParser::GetTable<::open_vector_format::VectorBlock_PointSequence>()},
    {::_pbi::TcParser::GetTable<::open_vector_format::VectorBlock_Arcs>()},
    {::_pbi::TcParser::GetTable<::open_vector_format::VectorBlock_Ellipses>()},
    {::_pbi::TcParser::GetTable<::open_vector_format::VectorBlock_LineSequence3D>()},
    {::_pbi::TcParser::GetTable<::open_vector_format::VectorBlock_Hatches3D>()},
    {::_pbi::TcParser::GetTable<::open_vector_format::VectorBlock_PointSequence3D>()},
    {::_pbi::TcParser::GetTable<::open_vector_format::VectorBlock_Arcs3D>()},
    {::_pbi::TcParser::GetTable<::open_vector_format::VectorBlock_ExposurePause>()},
    {::_pbi::TcParser::GetTable<::open_vector_format::VectorBlock_LineSequenceParaAdapt>()},
    {::_pbi::TcParser::GetTable<::open_vector_format::VectorBlock_HatchesParaAdapt>()},
    {::_pbi::TcParser::GetTable<::open_vector_format::VectorBlock_VectorBlockMetaData>()},
    {::_pbi::TcParser::GetTable<::open_vector_format::VectorBlock_LPBFMetadata>()},
    {::_pbi::TcParser::GetTable<::open_vector_format::VectorBlock_MicroStructuringMetadata>()},
    {::_pbi::FieldAuxDefaultMessage{}, &::open_vector_format::_VectorBlock_PolishingMetadata_default_instance_},
  }}, {{
  }},
};

::uint8_t* VectorBlock::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:open_vector_format.VectorBlock)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  switch (vector_data_case()) {
    case kLineSequence: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::line_sequence(this),
          _Internal::line_sequence(this).GetCachedSize(), target, stream);
      break;
    }
    case kHatches: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::_hatches(this),
          _Internal::_hatches(this).GetCachedSize(), target, stream);
      break;
    }
    case kPointSequence: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::point_sequence(this),
          _Internal::point_sequence(this).GetCachedSize(), target, stream);
      break;
    }
    case kArcs: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::_arcs(this),
          _Internal::_arcs(this).GetCachedSize(), target, stream);
      break;
    }
    case kEllipses: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::ellipses(this),
          _Internal::ellipses(this).GetCachedSize(), target, stream);
      break;
    }
    case kLineSequence3D: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::line_sequence_3d(this),
          _Internal::line_sequence_3d(this).GetCachedSize(), target, stream);
      break;
    }
    case kHatches3D: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(7, _Internal::hatches_3d(this),
          _Internal::hatches_3d(this).GetCachedSize(), target, stream);
      break;
    }
    case kPointSequence3D: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(8, _Internal::point_sequence_3d(this),
          _Internal::point_sequence_3d(this).GetCachedSize(), target, stream);
      break;
    }
    case kArcs3D: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(9, _Internal::arcs_3d(this),
          _Internal::arcs_3d(this).GetCachedSize(), target, stream);
      break;
    }
    case kExposurePause: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(10, _Internal::exposure_pause(this),
          _Internal::exposure_pause(this).GetCachedSize(), target, stream);
      break;
    }
    case kLineSequenceParaAdapt: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(11, _Internal::line_sequence_para_adapt(this),
          _Internal::line_sequence_para_adapt(this).GetCachedSize(), target, stream);
      break;
    }
    case kHatchParaAdapt: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(12, _Internal::_hatchparaadapt(this),
          _Internal::_hatchparaadapt(this).GetCachedSize(), target, stream);
      break;
    }
    default:
      break;
  }
  // int32 marking_params_key = 50;
  if (this->_internal_marking_params_key() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        50, this->_internal_marking_params_key(), target);
  }

  // int32 laser_index = 53;
  if (this->_internal_laser_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        53, this->_internal_laser_index(), target);
  }

  // uint64 repeats = 54;
  if (this->_internal_repeats() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        54, this->_internal_repeats(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .open_vector_format.VectorBlock.VectorBlockMetaData meta_data = 100;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(100, _Internal::meta_data(this),
        _Internal::meta_data(this).GetCachedSize(), target, stream);
  }

  switch (process_meta_data_case()) {
    case kLpbfMetadata: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(101, _Internal::lpbf_metadata(this),
          _Internal::lpbf_metadata(this).GetCachedSize(), target, stream);
      break;
    }
    case kMicroStructuringMetadata: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(102, _Internal::micro_structuring_metadata(this),
          _Internal::micro_structuring_metadata(this).GetCachedSize(), target, stream);
      break;
    }
    case kPolishingMetadata: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(103, _Internal::polishing_metadata(this),
          _Internal::polishing_metadata(this).GetCachedSize(), target, stream);
      break;
    }
    default:
      break;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:open_vector_format.VectorBlock)
  return target;
}

::size_t VectorBlock::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:open_vector_format.VectorBlock)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .open_vector_format.VectorBlock.VectorBlockMetaData meta_data = 100;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *_impl_.meta_data_);
  }

  // int32 marking_params_key = 50;
  if (this->_internal_marking_params_key() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_marking_params_key());
  }

  // int32 laser_index = 53;
  if (this->_internal_laser_index() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_laser_index());
  }

  // uint64 repeats = 54;
  if (this->_internal_repeats() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::UInt64Size(
                                    this->_internal_repeats());
  }

  switch (vector_data_case()) {
    // .open_vector_format.VectorBlock.LineSequence line_sequence = 1;
    case kLineSequence: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.vector_data_.line_sequence_);
      break;
    }
    // .open_vector_format.VectorBlock.Hatches _hatches = 2;
    case kHatches: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.vector_data_._hatches_);
      break;
    }
    // .open_vector_format.VectorBlock.PointSequence point_sequence = 3;
    case kPointSequence: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.vector_data_.point_sequence_);
      break;
    }
    // .open_vector_format.VectorBlock.Arcs _arcs = 4;
    case kArcs: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.vector_data_._arcs_);
      break;
    }
    // .open_vector_format.VectorBlock.Ellipses ellipses = 5;
    case kEllipses: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.vector_data_.ellipses_);
      break;
    }
    // .open_vector_format.VectorBlock.LineSequence3D line_sequence_3d = 6;
    case kLineSequence3D: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.vector_data_.line_sequence_3d_);
      break;
    }
    // .open_vector_format.VectorBlock.Hatches3D hatches_3d = 7;
    case kHatches3D: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.vector_data_.hatches_3d_);
      break;
    }
    // .open_vector_format.VectorBlock.PointSequence3D point_sequence_3d = 8;
    case kPointSequence3D: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.vector_data_.point_sequence_3d_);
      break;
    }
    // .open_vector_format.VectorBlock.Arcs3D arcs_3d = 9;
    case kArcs3D: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.vector_data_.arcs_3d_);
      break;
    }
    // .open_vector_format.VectorBlock.ExposurePause exposure_pause = 10;
    case kExposurePause: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.vector_data_.exposure_pause_);
      break;
    }
    // .open_vector_format.VectorBlock.LineSequenceParaAdapt line_sequence_para_adapt = 11;
    case kLineSequenceParaAdapt: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.vector_data_.line_sequence_para_adapt_);
      break;
    }
    // .open_vector_format.VectorBlock.HatchesParaAdapt _hatchParaAdapt = 12;
    case kHatchParaAdapt: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.vector_data_._hatchparaadapt_);
      break;
    }
    case VECTOR_DATA_NOT_SET: {
      break;
    }
  }
  switch (process_meta_data_case()) {
    // .open_vector_format.VectorBlock.LPBFMetadata lpbf_metadata = 101;
    case kLpbfMetadata: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.process_meta_data_.lpbf_metadata_);
      break;
    }
    // .open_vector_format.VectorBlock.MicroStructuringMetadata micro_structuring_metadata = 102;
    case kMicroStructuringMetadata: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.process_meta_data_.micro_structuring_metadata_);
      break;
    }
    // .open_vector_format.VectorBlock.PolishingMetadata polishing_metadata = 103;
    case kPolishingMetadata: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.process_meta_data_.polishing_metadata_);
      break;
    }
    case PROCESS_META_DATA_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData VectorBlock::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    VectorBlock::MergeImpl
};
const ::google::protobuf::Message::ClassData*VectorBlock::GetClassData() const { return &_class_data_; }


void VectorBlock::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<VectorBlock*>(&to_msg);
  auto& from = static_cast<const VectorBlock&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:open_vector_format.VectorBlock)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_meta_data()->::open_vector_format::VectorBlock_VectorBlockMetaData::MergeFrom(
        from._internal_meta_data());
  }
  if (from._internal_marking_params_key() != 0) {
    _this->_internal_set_marking_params_key(from._internal_marking_params_key());
  }
  if (from._internal_laser_index() != 0) {
    _this->_internal_set_laser_index(from._internal_laser_index());
  }
  if (from._internal_repeats() != 0) {
    _this->_internal_set_repeats(from._internal_repeats());
  }
  switch (from.vector_data_case()) {
    case kLineSequence: {
      _this->_internal_mutable_line_sequence()->::open_vector_format::VectorBlock_LineSequence::MergeFrom(
          from._internal_line_sequence());
      break;
    }
    case kHatches: {
      _this->_internal_mutable__hatches()->::open_vector_format::VectorBlock_Hatches::MergeFrom(
          from._internal__hatches());
      break;
    }
    case kPointSequence: {
      _this->_internal_mutable_point_sequence()->::open_vector_format::VectorBlock_PointSequence::MergeFrom(
          from._internal_point_sequence());
      break;
    }
    case kArcs: {
      _this->_internal_mutable__arcs()->::open_vector_format::VectorBlock_Arcs::MergeFrom(
          from._internal__arcs());
      break;
    }
    case kEllipses: {
      _this->_internal_mutable_ellipses()->::open_vector_format::VectorBlock_Ellipses::MergeFrom(
          from._internal_ellipses());
      break;
    }
    case kLineSequence3D: {
      _this->_internal_mutable_line_sequence_3d()->::open_vector_format::VectorBlock_LineSequence3D::MergeFrom(
          from._internal_line_sequence_3d());
      break;
    }
    case kHatches3D: {
      _this->_internal_mutable_hatches_3d()->::open_vector_format::VectorBlock_Hatches3D::MergeFrom(
          from._internal_hatches_3d());
      break;
    }
    case kPointSequence3D: {
      _this->_internal_mutable_point_sequence_3d()->::open_vector_format::VectorBlock_PointSequence3D::MergeFrom(
          from._internal_point_sequence_3d());
      break;
    }
    case kArcs3D: {
      _this->_internal_mutable_arcs_3d()->::open_vector_format::VectorBlock_Arcs3D::MergeFrom(
          from._internal_arcs_3d());
      break;
    }
    case kExposurePause: {
      _this->_internal_mutable_exposure_pause()->::open_vector_format::VectorBlock_ExposurePause::MergeFrom(
          from._internal_exposure_pause());
      break;
    }
    case kLineSequenceParaAdapt: {
      _this->_internal_mutable_line_sequence_para_adapt()->::open_vector_format::VectorBlock_LineSequenceParaAdapt::MergeFrom(
          from._internal_line_sequence_para_adapt());
      break;
    }
    case kHatchParaAdapt: {
      _this->_internal_mutable__hatchparaadapt()->::open_vector_format::VectorBlock_HatchesParaAdapt::MergeFrom(
          from._internal__hatchparaadapt());
      break;
    }
    case VECTOR_DATA_NOT_SET: {
      break;
    }
  }
  switch (from.process_meta_data_case()) {
    case kLpbfMetadata: {
      _this->_internal_mutable_lpbf_metadata()->::open_vector_format::VectorBlock_LPBFMetadata::MergeFrom(
          from._internal_lpbf_metadata());
      break;
    }
    case kMicroStructuringMetadata: {
      _this->_internal_mutable_micro_structuring_metadata()->::open_vector_format::VectorBlock_MicroStructuringMetadata::MergeFrom(
          from._internal_micro_structuring_metadata());
      break;
    }
    case kPolishingMetadata: {
      _this->_internal_mutable_polishing_metadata()->::open_vector_format::VectorBlock_PolishingMetadata::MergeFrom(
          from._internal_polishing_metadata());
      break;
    }
    case PROCESS_META_DATA_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void VectorBlock::CopyFrom(const VectorBlock& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:open_vector_format.VectorBlock)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool VectorBlock::IsInitialized() const {
  return true;
}

void VectorBlock::InternalSwap(VectorBlock* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VectorBlock, _impl_.repeats_)
      + sizeof(VectorBlock::_impl_.repeats_)
      - PROTOBUF_FIELD_OFFSET(VectorBlock, _impl_.meta_data_)>(
          reinterpret_cast<char*>(&_impl_.meta_data_),
          reinterpret_cast<char*>(&other->_impl_.meta_data_));
  swap(_impl_.vector_data_, other->_impl_.vector_data_);
  swap(_impl_.process_meta_data_, other->_impl_.process_meta_data_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::google::protobuf::Metadata VectorBlock::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_open_5fvector_5fformat_2eproto_getter, &descriptor_table_open_5fvector_5fformat_2eproto_once,
      file_level_metadata_open_5fvector_5fformat_2eproto[33]);
}
// ===================================================================

class AxisAlignedBox2D::_Internal {
 public:
};

AxisAlignedBox2D::AxisAlignedBox2D(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:open_vector_format.AxisAlignedBox2D)
}
AxisAlignedBox2D::AxisAlignedBox2D(const AxisAlignedBox2D& from)
    : ::google::protobuf::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:open_vector_format.AxisAlignedBox2D)
}
inline void AxisAlignedBox2D::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.x_min_){0},
      decltype(_impl_.y_min_){0},
      decltype(_impl_.x_max_){0},
      decltype(_impl_.y_max_){0},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
AxisAlignedBox2D::~AxisAlignedBox2D() {
  // @@protoc_insertion_point(destructor:open_vector_format.AxisAlignedBox2D)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void AxisAlignedBox2D::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}
void AxisAlignedBox2D::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void AxisAlignedBox2D::Clear() {
// @@protoc_insertion_point(message_clear_start:open_vector_format.AxisAlignedBox2D)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_min_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.y_max_) -
      reinterpret_cast<char*>(&_impl_.x_min_)) + sizeof(_impl_.y_max_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* AxisAlignedBox2D::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2> AxisAlignedBox2D::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_AxisAlignedBox2D_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // float y_max = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 63, 0, PROTOBUF_FIELD_OFFSET(AxisAlignedBox2D, _impl_.y_max_)}},
    // float x_min = 1;
    {::_pbi::TcParser::FastF32S1,
     {13, 63, 0, PROTOBUF_FIELD_OFFSET(AxisAlignedBox2D, _impl_.x_min_)}},
    // float y_min = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(AxisAlignedBox2D, _impl_.y_min_)}},
    // float x_max = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 63, 0, PROTOBUF_FIELD_OFFSET(AxisAlignedBox2D, _impl_.x_max_)}},
  }}, {{
    65535, 65535
  }}, {{
    // float x_min = 1;
    {PROTOBUF_FIELD_OFFSET(AxisAlignedBox2D, _impl_.x_min_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float y_min = 2;
    {PROTOBUF_FIELD_OFFSET(AxisAlignedBox2D, _impl_.y_min_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float x_max = 3;
    {PROTOBUF_FIELD_OFFSET(AxisAlignedBox2D, _impl_.x_max_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float y_max = 4;
    {PROTOBUF_FIELD_OFFSET(AxisAlignedBox2D, _impl_.y_max_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* AxisAlignedBox2D::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:open_vector_format.AxisAlignedBox2D)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // float x_min = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x_min = this->_internal_x_min();
  ::uint32_t raw_x_min;
  memcpy(&raw_x_min, &tmp_x_min, sizeof(tmp_x_min));
  if (raw_x_min != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_x_min(), target);
  }

  // float y_min = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y_min = this->_internal_y_min();
  ::uint32_t raw_y_min;
  memcpy(&raw_y_min, &tmp_y_min, sizeof(tmp_y_min));
  if (raw_y_min != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_y_min(), target);
  }

  // float x_max = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x_max = this->_internal_x_max();
  ::uint32_t raw_x_max;
  memcpy(&raw_x_max, &tmp_x_max, sizeof(tmp_x_max));
  if (raw_x_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_x_max(), target);
  }

  // float y_max = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y_max = this->_internal_y_max();
  ::uint32_t raw_y_max;
  memcpy(&raw_y_max, &tmp_y_max, sizeof(tmp_y_max));
  if (raw_y_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_y_max(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:open_vector_format.AxisAlignedBox2D)
  return target;
}

::size_t AxisAlignedBox2D::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:open_vector_format.AxisAlignedBox2D)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x_min = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x_min = this->_internal_x_min();
  ::uint32_t raw_x_min;
  memcpy(&raw_x_min, &tmp_x_min, sizeof(tmp_x_min));
  if (raw_x_min != 0) {
    total_size += 5;
  }

  // float y_min = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y_min = this->_internal_y_min();
  ::uint32_t raw_y_min;
  memcpy(&raw_y_min, &tmp_y_min, sizeof(tmp_y_min));
  if (raw_y_min != 0) {
    total_size += 5;
  }

  // float x_max = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x_max = this->_internal_x_max();
  ::uint32_t raw_x_max;
  memcpy(&raw_x_max, &tmp_x_max, sizeof(tmp_x_max));
  if (raw_x_max != 0) {
    total_size += 5;
  }

  // float y_max = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y_max = this->_internal_y_max();
  ::uint32_t raw_y_max;
  memcpy(&raw_y_max, &tmp_y_max, sizeof(tmp_y_max));
  if (raw_y_max != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData AxisAlignedBox2D::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    AxisAlignedBox2D::MergeImpl
};
const ::google::protobuf::Message::ClassData*AxisAlignedBox2D::GetClassData() const { return &_class_data_; }


void AxisAlignedBox2D::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<AxisAlignedBox2D*>(&to_msg);
  auto& from = static_cast<const AxisAlignedBox2D&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:open_vector_format.AxisAlignedBox2D)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x_min = from._internal_x_min();
  ::uint32_t raw_x_min;
  memcpy(&raw_x_min, &tmp_x_min, sizeof(tmp_x_min));
  if (raw_x_min != 0) {
    _this->_internal_set_x_min(from._internal_x_min());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y_min = from._internal_y_min();
  ::uint32_t raw_y_min;
  memcpy(&raw_y_min, &tmp_y_min, sizeof(tmp_y_min));
  if (raw_y_min != 0) {
    _this->_internal_set_y_min(from._internal_y_min());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x_max = from._internal_x_max();
  ::uint32_t raw_x_max;
  memcpy(&raw_x_max, &tmp_x_max, sizeof(tmp_x_max));
  if (raw_x_max != 0) {
    _this->_internal_set_x_max(from._internal_x_max());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y_max = from._internal_y_max();
  ::uint32_t raw_y_max;
  memcpy(&raw_y_max, &tmp_y_max, sizeof(tmp_y_max));
  if (raw_y_max != 0) {
    _this->_internal_set_y_max(from._internal_y_max());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void AxisAlignedBox2D::CopyFrom(const AxisAlignedBox2D& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:open_vector_format.AxisAlignedBox2D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool AxisAlignedBox2D::IsInitialized() const {
  return true;
}

void AxisAlignedBox2D::InternalSwap(AxisAlignedBox2D* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AxisAlignedBox2D, _impl_.y_max_)
      + sizeof(AxisAlignedBox2D::_impl_.y_max_)
      - PROTOBUF_FIELD_OFFSET(AxisAlignedBox2D, _impl_.x_min_)>(
          reinterpret_cast<char*>(&_impl_.x_min_),
          reinterpret_cast<char*>(&other->_impl_.x_min_));
}

::google::protobuf::Metadata AxisAlignedBox2D::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_open_5fvector_5fformat_2eproto_getter, &descriptor_table_open_5fvector_5fformat_2eproto_once,
      file_level_metadata_open_5fvector_5fformat_2eproto[34]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace open_vector_format
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
